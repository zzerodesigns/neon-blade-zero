
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Blade: Melee Arena v48.0.0</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Zen+Dots&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; transition: background-color 0.5s; }
        
        /* --- CYBERPUNK HUD (Compact) --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 32px; height: 32px;
            transform: translate(-50%, -50%) rotate(22.5deg); 
            opacity: 1; transition: opacity 0.1s;
            z-index: 5;
        }
        #crosshair svg { width: 100%; height: 100%; filter: drop-shadow(0 0 4px rgba(51, 204, 255, 0.8)); }

        /* Top HUD */
        #hud-top { 
            padding: 15px; display: flex; justify-content: space-between; align-items: flex-start;
        }
        .hud-right-col {
            display: flex; flex-direction: column; align-items: flex-end; gap: 6px;
        }

        /* MINIMAP - Liquid Glass Style */
            #minimap-container {
                position: relative;
                /* Minimap size: Change these two values to resize */
                width: 180px; 
                height: 180px; 
                
                margin-top: 9px;
                border-radius: 50%;
                
                /* GLASS EFFECT */
                background: rgba(0, 15, 30, 0.2); /* Low opacity for see-through */
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
                
                border: 1px solid rgba(51, 204, 255, 0.3);
                box-shadow: 0 0 30px rgba(0,0,0,0.5); /* Deep shadow to pop off background */
            }

            #minimap {
                width: 100%; height: 100%;
                display: block;
                border-radius: 50%;
            }

            #minimap-north {
                position: absolute;
                top: 5px; left: 50%; transform: translateX(-50%);
                color: #ffcc00; font-weight: bold; font-family: 'Arial', sans-serif;
                font-size: 10px; pointer-events: none;
                display: none; /* We will position this manually in JS */
            }

        .hud-panel {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #33ccff;
            padding: 6px 15px;
            color: #fff;
            font-family: 'Arial Black', sans-serif;
            font-style: italic;
            transform: skewX(-15deg);
            box-shadow: 0 0 5px rgba(51, 204, 255, 0.2);
            backdrop-filter: blur(4px);
        }
        .hud-panel-content { transform: skewX(15deg); }

        #score-display { font-size: 1.2rem; color: #33ccff; text-shadow: 2px 2px 0px rgba(0,0,0,0.8); }
        #mode-display { font-size: 0.7rem; color: #aaa; letter-spacing: 1px; }

        /* FPS Display - Thicker Font v45.6.4 */
        #fps-display {
            font-family: 'Segoe UI', sans-serif; 
            font-weight: 500;
            font-size: 0.8rem;
            color: #111; /* Dark Text */
            background: rgba(255, 255, 255, 0.2); /* Light BG, low opacity */
            border: 1px solid rgba(0, 0, 0, 0.3); /* Dark Border */
            padding: 2px 10px;
            transform: skewX(-15deg);
            display: none;
            backdrop-filter: blur(2px);
            box-shadow: 0 0 5px rgba(255,255,255,0.1);
        }
        .fps-inner { transform: skewX(15deg); }

        /* Bottom HUD */
        #hud-bottom { 
            padding: 25px; display: flex; gap: 20px; align-items: flex-end; 
        }
        
        .stat-group {
            display: flex; flex-direction: column; gap: 5px;
        }
        .stat-header {
            display: flex; align-items: center; gap: 10px; margin-left: 5px;
        }
        .stat-label {
            font-family: 'Arial Black', sans-serif; font-size: 0.8rem; color: white;
            text-transform: uppercase; letter-spacing: 1px;
            text-shadow: 1px 1px 0 #000;
        }
        #lives-display {
            color: #ff3333; font-size: 1rem; text-shadow: 0 0 5px #ff0000;
        }
        
        .bar-frame {
            width: 250px; height: 18px;
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.2);
            transform: skewX(-20deg);
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .bar-fill {
            height: 100%; width: 100%;
            transition: width 0.1s linear;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        #health-fill { background: linear-gradient(90deg, #cc0000, #ff3333); box-shadow: 0 0 10px #ff3333; transition: all 0.1s; }
        #energy-fill { background: linear-gradient(90deg, #0066cc, #33ccff); box-shadow: 0 0 10px #33ccff; }
        
        .health-critical {
            animation: pulse-red 0.5s infinite alternate;
        }
        
        @keyframes pulse-red {
            from { box-shadow: 0 0 10px #ff0000; filter: brightness(1); }
            to { box-shadow: 0 0 25px #ff0000; filter: brightness(1.5); }
        }

        /* Ability Icon */
        .ability-group { margin-left: auto; transform: skewX(-10deg); display: flex; gap: 10px; }
        .ability-icon { 
            width: 50px; height: 50px;
            border: 1px solid #fff; 
            background: rgba(0,0,0,0.6);
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center; 
            font-weight: bold; color: white; 
            transition: 0.2s;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .ability-icon-inner { transform: skewX(10deg); text-align: center; }
        .ability-icon.active { 
            border-color: #00ffaa; box-shadow: 0 0 15px #00ffaa; color: #00ffaa; 
            background: rgba(0, 255, 170, 0.1);
        }
        .ability-key { font-size: 1.2rem; font-family: 'Arial Black', sans-serif; }
        .ability-name { font-size: 0.5rem; letter-spacing: 1px; opacity: 0.8; }
        
        #icon-q { width: 60px; height: 60px; border-color: #33ccff; }

        /* MENUS */ 
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 10, 20, 0.875);
            display: flex; flex-direction: column; overflow-y: auto; padding: 0; 
            z-index: 10; pointer-events: auto; backdrop-filter: blur(5px);
            background-image: 
                linear-gradient(rgba(51, 204, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(51, 204, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        #start-content {
            display: flex; flex-direction: column; align-items: center;
            padding: 50px 60px;
            background: linear-gradient(135deg, rgba(10,20,30,0.95), rgba(5,10,15,0.95));
            clip-path: polygon(30px 0, 100% 0, 100% calc(100% - 30px), calc(100% - 30px) 100%, 0 100%, 0 30px);
            position: relative;
            width: fit-content; max-width: 90vw; min-width: 700px; height: auto;
            margin: auto; 
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        @media (max-width: 768px) {
            #start-content { min-width: 95%; padding: 30px 20px; clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px); }
            h1 { font-size: 3rem; }
            .btn { min-width: 100%; padding: 20px 30px; font-size: 1.5rem; }
            #stats-container { flex-direction: column; gap: 15px; }
            .stat-box:last-child { border-left: none; border-top: 1px solid rgba(255,255,255,0.1); padding-left: 0; padding-top: 15px; }
        }

        #start-content::-webkit-scrollbar { display: none; }
        
        #start-content::after {
            content: ''; position: absolute; top:0; left:0; width:100%; height:100%;
            box-shadow: inset 0 0 0 2px rgba(51, 204, 255, 0.3);
            pointer-events: none;
            clip-path: polygon(30px 0, 100% 0, 100% calc(100% - 30px), calc(100% - 30px) 100%, 0 100%, 0 30px);
        }

        h1 { 
            font-size: 5rem; margin: 0 0 10px 0; color: #fff; 
            text-shadow: 4px 4px 0px #33ccff; 
            font-style: italic; text-transform: uppercase; letter-spacing: -2px;
            font-family: 'Arial Black', sans-serif;
        }

        #player-title-display {
            font-size: 2rem; color: #aaa; margin-bottom: 20px;
            text-transform: uppercase; letter-spacing: 4px; font-weight: 300;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
            text-align: center;
        }
        
        p { font-size: 1.1rem; color: #aaa; margin-top: 5px; text-align: center; line-height: 1.5; font-family: monospace; }
        
        .btn-row { 
            display: flex; gap: 20px; margin-top: 10px; width: 100%; 
            justify-content: center; flex-wrap: wrap; position: relative; z-index: 5; 
        }
                
        .btn {
            border: 2px solid transparent;
            padding: 25px 60px; background: #33ccff;
            color: #000; font-size: 2rem; cursor: pointer; transition: all 0.5s; 
            font-weight: 900; text-transform: uppercase; letter-spacing: 2px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            position: relative; overflow: hidden;
            pointer-events: auto; min-width: 300px;
            font-family: 'Arial Black', sans-serif;
        }
        .btn::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
            transition: 0.5s;
        }
        .btn:hover::before { left: 100%; }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 40px #33ccff; color: white; background: #000; border: 2px solid #33ccff; }
        
        .btn-secondary { 
            padding: 12px 24px; font-size: 1rem; background: transparent; 
            border: 1px solid #555; color: #888; pointer-events: auto;
            font-family: 'Segoe UI', sans-serif; font-weight: bold; text-transform: uppercase;
            transition: 0.2s; cursor: pointer;
        }
        .btn-secondary:hover { border-color: #fff; color: #fff; background: rgba(255,255,255,0.1); }

        #stats-container {
            margin-top: 10px; width: 100%; display: flex;
            flex: 0 0 auto; margin-bottom: 10px; gap: 30px; 
            padding-top: 30px; align-items: stretch; font-family: inherit; 
        }

        #stat-session {
            display: flex; flex-direction: column; flex: 1; min-height: 60px; overflow: hidden;
        }

        .stat-box:first-child { 
            flex: 1; text-align: left; display: flex; flex-direction: column; height: 100%; min-height: 0; 
        }
        .stat-box:last-child { 
            flex: 0 0 auto; width: auto; text-align: left;
            border-left: 1px solid rgba(255,255,255,0.1); padding-left: 20px; white-space: nowrap; 
        }

        .stat-title { 
            color: #33ccff; font-size: 1rem; font-weight: bold; 
            margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; 
        }

        .stat-value { 
            color: #fff; font-size: 0.9rem; font-family: monospace; 
            line-height: 1.6; opacity: 0.8; 
        }

        .achievement-tag {
            display: inline-flex; align-items: center; justify-content: center; height: 22px;
            background: rgba(51, 204, 255, 0.1); border-left: 2px solid #33ccff;
            padding: 0 8px; font-size: 0.8rem; color: #fff; white-space: nowrap;
        }

        .achievement-list {
            display: flex; flex-wrap: wrap; gap: 6px; margin-top: 5px;
            flex: 1; min-height: 40px; overflow-y: auto; padding-bottom: 4px; 
        }

        .achievement-list::-webkit-scrollbar { width: 4px; }
        .achievement-list::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
        .achievement-list::-webkit-scrollbar-thumb { background: #33ccff; border-radius: 2px; }

        #kill-feed { position: absolute; top: 100px; left: 20px; text-align: left; display: flex; flex-direction: column; gap: 4px; }
        .kill-msg { 
            color: white; font-size: 13px; font-weight: bold; 
            text-shadow: 1px 1px 0px rgba(0,0,0,0.5); 
            animation: fadeOut 5s forwards; 
            border-left: 3px solid #fff; padding-left: 8px; 
            background: linear-gradient(90deg, rgba(0,0,0,0.6), transparent);
            font-family: 'Arial Black', sans-serif; font-style: italic;
            padding-top: 2px; padding-bottom: 2px;
        }
        .kill-msg.combo { border-left-color: #ffcc00; color: #ffcc00; font-size: 12px; }
        .kill-msg.achievement { border-left-color: #ff00ff; color: #ff00ff; font-size: 14px; text-shadow: 0 0 8px #ff00ff; }
        .kill-msg.critical { border-left-color: #ff0000; color: #ff3333; font-size: 14px; text-shadow: 0 0 5px #ff0000; }
        .kill-msg.graze { border-left-color: #888; color: #aaa; font-size: 11px; }

        .slick-streak {
            font-family: 'Segoe UI', sans-serif; font-weight: 300; font-style: normal; margin-left: 4px;
        }

        @keyframes fadeOut { 0% { opacity: 1; transform: translateX(0); } 80% { opacity: 1; } 100% { opacity: 0; transform: translateX(-30px); } }

        #combo-display {
            position: absolute; top: 10%; left: 50%; transform: translateX(-50%);
            color: #ffcc00; 
            font-family: 'Zen Dots', cursive; font-weight: 400; font-style: normal; letter-spacing: -1px; text-transform: uppercase;
            text-shadow: 4px 4px 0px rgba(0,0,0,0.5); display: none; 
            text-align: center; z-index: 5;
            transition: all 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            white-space: nowrap; 
        }
        
        #combo-display.cyan-mode {
            color: #00ffff !important;
            text-shadow: 0 0 15px #00ffff, 4px 4px 0px rgba(0,0,0,0.8) !important;
        }

        #meme-overlay {
            position: absolute; top: -60px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 16px; padding: 12px 24px;
            color: #fff; font-family: 'Segoe UI', sans-serif; font-weight: 500; font-size: 2rem;
            white-space: nowrap; display: none;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 10;
        }

        @keyframes popIn { 0% { transform: translateX(-50%) scale(0); opacity: 0; } 100% { transform: translateX(-50%) scale(1); opacity: 1; } }

        #session-timer {
            position: absolute; bottom: 15px; right: 20px;
            font-family: monospace; font-size: 0.8rem; color: #666;
            opacity: 0.5; display: none;
        }

        #damage-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: radial-gradient(circle, transparent 50%, rgba(255,0,0,0.0) 100%);
            pointer-events: none; transition: background 0.1s;
        }

        #low-health-vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 300px 80px rgba(255, 0, 0, 0.8);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 2;
        }

        .light-theme .hud-panel { background: rgba(255,255,255,0.7); border-color: #0088ff; color: #000; }
        .light-theme #score-display { color: #0066cc; text-shadow: none; }
        .light-theme .stat-label { color: #333; text-shadow: none; }
        .light-theme .bar-frame { border-color: rgba(0,0,0,0.2); background: rgba(255,255,255,0.5); }
        .light-theme .ability-icon { border-color: #0066cc; background: rgba(255,255,255,0.6); color: #0066cc; }
        
        .light-theme #fps-display {
            background: rgba(0,0,0,0.2);
            color: #fff;
            border-color: rgba(255,255,255,0.4);
        }
        .session-info { position: relative; cursor: help; pointer-events: auto; }
        .session-info:hover::after {
            content: attr(data-details);
            position: absolute;
            bottom: 120%; right: 0;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #00ffff;
            color: #fff;
            padding: 12px;
            font-size: 13px;
            white-space: pre;
            z-index: 1000;
            text-align: right;
            font-family: monospace;
            box-shadow: 0 0 20px rgba(0,255,255,0.2);
            line-height: 1.5;
            min-width: 150px;
        }

        /* --- SETTINGS & UI SPARKS (Refined v5) --- */
        #settings-btn { padding: 15px; min-width: 60px; width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; }
        
        #settings-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 600px; /* Wider */
            background: rgba(5, 10, 15, 0.98); 
            border: 1px solid #334455;
            padding: 50px; 
            display: none; 
            flex-direction: column; 
            z-index: 20; 
            box-shadow: 0 0 100px rgba(0,0,0,1);
        }
        
        #settings-modal h2 { 
            margin: 0 0 50px 0; 
            color: #33ccff; 
            font-family: 'Segoe UI', sans-serif; 
            font-weight: 800;
            text-transform: uppercase; 
            letter-spacing: 4px; 
            font-size: 1.8rem;
            text-align: center; 
            border-bottom: 2px solid #334455; 
            padding-bottom: 20px; 
            text-shadow: 0 0 20px rgba(51, 204, 255, 0.2);
        }
        
        /* Sliders - More Breathing Room */
        .slider-group { display: flex; flex-direction: column; gap: 40px; margin-bottom: 50px; }
        .slider-row { display: flex; flex-direction: column; gap: 15px; }
        
        .setting-label { 
            color: #8899aa; font-weight: 700; font-family: 'Segoe UI', sans-serif; 
            text-transform: uppercase; letter-spacing: 1px; font-size: 0.85rem; 
        }

        /* Range Slider */
        .cyber-range {
            -webkit-appearance: none; width: 100%; height: 8px; 
            background: #111; outline: none; transition: 0.2s; border-radius: 4px;
            border: 1px solid #334455;
        }
        .cyber-range::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 24px; height: 24px; 
            background: #15202b; border: 2px solid #33ccff; border-radius: 50%; cursor: pointer;
            box-shadow: 0 0 15px rgba(51, 204, 255, 0.4); transition: transform 0.1s;
            margin-top: -1px; 
        }
        .cyber-range::-webkit-slider-thumb:hover { transform: scale(1.2); background: #33ccff; box-shadow: 0 0 25px #33ccff; }
        
        /* Switch Grid (Bottom Row) */
        .switch-container {
            display: grid; 
            grid-template-columns: 1fr 1fr 1fr 1fr; 
            gap: 20px;
            border-top: 1px solid #334455; 
            padding-top: 40px;
            justify-items: center; /* Horizontally center grid items */
        }

        /* Tilt Slider */
        #tilt-slider-row {
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 15px;
            border-top: 1px solid #334455; /* Separator line */
            padding-top: 40px;
            margin-top: 40px; 
            align-items: center;
        }
        
        /* Centered Switch Wrapper */
        .switch-wrapper { 
            display: flex; 
            flex-direction: column; 
            align-items: center; /* Center content */
            gap: 15px; 
            width: 100%;
        }
        
        /* Refined Pill Switch */
        .cyber-switch { position: relative; display: inline-block; width: 54px; height: 28px; }
        .cyber-switch input { opacity: 0; width: 0; height: 0; }
        .slider-track {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #080c10; transition: .3s; 
            border: 1px solid #445566; border-radius: 14px;
        }
        .slider-track:before {
            position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px;
            background-color: #556677; transition: .3s; border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        input:checked + .slider-track { border-color: #33ccff; background-color: rgba(51, 204, 255, 0.1); }
        input:checked + .slider-track:before { 
            transform: translateX(26px); background-color: #33ccff; 
            box-shadow: 0 0 15px #33ccff;
        }

        /* Close Button */
        .close-btn { 
            align-self: center; cursor: pointer; color: #556677; 
            font-weight: 700; font-size: 0.9rem; letter-spacing: 2px;
            transition: 0.3s; margin-top: 40px; padding: 12px 50px;
            border: 1px solid transparent; text-transform: uppercase;
        }
        .close-btn:hover { color: #fff; border-color: #33ccff; background: rgba(51, 204, 255, 0.1); box-shadow: 0 0 20px rgba(51,204,255,0.2); }

        /* NARRATIVE SYSTEM */
        #narrative-display {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 4px; padding: 15px 40px;
            color: #fff; font-family: 'Segoe UI', sans-serif; font-weight: 400; font-size: 1.2rem;
            letter-spacing: 1px; line-height: 1.4; text-align: center;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            pointer-events: none; opacity: 0; transition: opacity 0.5s;
            z-index: 8;
        }
        #narrative-display.active { opacity: 1; }

        /* FX */
        .shake-blow { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; color: #ff3333 !important; }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
        .ui-spark { position: fixed; width: 3px; height: 12px; background: #fff; pointer-events: none; z-index: 100; animation: spark-anim 0.4s ease-out forwards; }
        @keyframes spark-anim { 0% { opacity: 1; transform: translate(-50%, -50%) rotate(var(--r)) scale(1); } 100% { opacity: 0; transform: translate(var(--tx), var(--ty)) rotate(var(--r)) scale(0); } }
    </style>
    <link rel="stylesheet" href="/index.css">
</head>
<body>

    <div id="damage-overlay"></div>
    <div id="low-health-vignette"></div>

    <div id="ui-layer" class="light-theme">
        <div id="narrative-display"></div>
        <div id="hud-top">
            <div class="hud-panel">
                <div class="hud-panel-content">
                    <span id="score-display">SCORE: 0</span>
                </div>
            </div>
            
            <div class="hud-right-col">
                <div class="hud-panel" style="border-color: #aaa;">
                    <div class="hud-panel-content" id="mode-display">LIGHT | 'T' TO CYCLE</div>
                </div>
                <div id="fps-display">
                    <div class="fps-inner">FPS: 0</div>
                </div>
                
                <!-- NEW: MINIMAP CONTAINER -->
                <div id="minimap-container" style="display:none;">
                    <canvas id="minimap"></canvas>
                    <div id="minimap-ring"></div>
                    <div id="minimap-north">N</div>
                </div>
            </div>
        </div>
        
        <div id="combo-wrapper" style="position:absolute; top:10%; left:50%; width:0; height:0;">
            <div id="meme-overlay">nice.</div>
            <div id="combo-display">2 STRIKES</div>
        </div>

        <div id="kill-feed"></div>
        
        <div id="crosshair">
            <svg viewBox="0 0 100 100" fill="currentColor">
                <path d="M50,5 Q10,50 50,95 Q30,50 50,5 Z" />
            </svg>
        </div>
        
        <div id="hud-bottom">
            <div class="stat-group">
                <div class="stat-header">
                    <span class="stat-label">HEALTH</span>
                    <span id="lives-display"></span>
                </div>
                <div class="bar-frame"><div id="health-fill" class="bar-fill"></div></div>
            </div>
            <div class="stat-group">
                <span class="stat-label">ENERGY</span>
                <div class="bar-frame"><div id="energy-fill" class="bar-fill"></div></div>
            </div>
            <div class="ability-group">
                <div class="ability-icon" id="icon-q">
                    <div class="ability-icon-inner">
                        <div class="ability-key">Q</div>
                        <div class="ability-name" id="tp-label">AIM</div>
                    </div>
                </div>
                 <div class="ability-icon" id="icon-f">
                    <div class="ability-icon-inner">
                        <div class="ability-key">F</div>
                        <div class="ability-name">FRAG</div>
                    </div>
                </div>
                <div class="ability-icon" id="icon-r">
                    <div class="ability-icon-inner">
                        <div class="ability-key">R</div>
                        <div class="ability-name">VOID</div>
                    </div>
                </div>
                 <div class="ability-icon" id="icon-e">
                    <div class="ability-icon-inner">
                        <div class="ability-key">E</div>
                        <div class="ability-name">IMPULSE</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <div id="start-content">
            <h1 id="game-title">NEON BLADE</h1>
            <div id="player-title-display"></div>
            <p>
                <strong>WASD</strong> Move | <strong>SPACE</strong> Jump | <strong>SHIFT</strong> Sprint<br>
                <strong>C</strong> Slide | <strong>Q</strong> Teleport | <strong>Hold F/R/E</strong> Aim Gadget
            </p>
            
            <div class="btn-row">
                <button class="btn" id="start-btn">ENTER ARENA</button>
            </div>
            
            <div id="stats-container">
                <div class="stat-box">
                    <div class="stat-title">Current Session</div>
                    <div class="stat-value" id="stat-session"></div>
                </div>
                <div class="stat-box">
                    <div class="stat-title">Style Matrix</div>
                    <div class="stat-value" id="stat-moves"></div>
                </div>
            </div>

            <div id="session-timer">Session Time: 00:00</div>

            <div class="btn-row" style="margin-top: 10px; gap: 15px;">
                <button class="btn-secondary" id="tp-mode-btn">TP MODE: AIM</button>
                <button class="btn-secondary" id="theme-btn">THEME: LIGHT</button>
                <button class="btn-secondary" id="world-btn">WORLD: ARENA</button>
                <button class="btn-secondary" id="settings-btn" title="Settings">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.43-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
                    </svg>
                </button>
            </div>
            
            <!-- NEW SETTINGS MODAL v5 -->
            <div id="settings-modal">
                <h2>SYSTEM SETTINGS</h2>
                
                <div class="slider-group">
                    <div class="slider-row">
                        <span class="setting-label">Brightness (Gamma)</span>
                        <input type="range" min="0.2" max="2.2" step="0.1" value="1.2" class="cyber-range" id="set-bright">
                    </div>

                    <div class="slider-row">
                        <span class="setting-label">Master Volume (Gain)</span>
                        <input type="range" min="0" max="1" step="0.05" value="0.5" class="cyber-range" id="set-vol">
                    </div>
                </div>

                <div class="switch-container">
                    <div class="switch-wrapper">
                        <span class="setting-label">Show FPS</span>
                        <label class="cyber-switch">
                            <input type="checkbox" id="set-fps">
                            <span class="slider-track"></span>
                        </label>
                    </div>

                    <div class="switch-wrapper">
                        <span class="setting-label">Wall Tilt</span>
                        <label class="cyber-switch">
                            <input type="checkbox" id="set-tilt">
                            <span class="slider-track"></span>
                        </label>
                    </div>

                    <div class="switch-wrapper">
                        <span class="setting-label" style="color:#556677;">God Mode</span>
                        <label class="cyber-switch" id="trap-god">
                            <input type="checkbox">
                            <span class="slider-track"></span>
                        </label>
                    </div>

                    <div class="switch-wrapper">
                        <span class="setting-label" style="color:#556677;">Music</span>
                        <label class="cyber-switch" id="trap-music">
                            <input type="checkbox">
                            <span class="slider-track"></span>
                        </label>
                    </div>
                </div>

                <div id="tilt-slider-row">
                    <span class="setting-label">Tilt Intensity</span>
                    <input type="range" min="0.1" max="0.8" step="0.05" value="0.45" class="cyber-range" id="set-tilt-amt">
                </div>

                <div class="close-btn" id="settings-close">CLOSE</div>
            </div>

            <p style="font-size: 0.8rem; margin-top: 30px; opacity: 0.5;">PRESS ESC TO PAUSE</p>
            <div style="margin-top: 8px; font-size: 0.65rem; color: #555; font-family: monospace; letter-spacing: 1px; text-align: center;">NEON BLADE: MELEE ARENA v48.0.0<br>- Experimental Hybrid Physics & Narrative UI -</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            baseSpeed: 7, 
            crouchSpeed: 3, 
            sprintSpeed: 14, 
            jumpForce: 20, 
            wallJumpForce: 22,
            wallPushForce: 18,
            gravity: 30, 
            frictionGround: 6.0, 
            frictionAir: 0.02, 
            airControl: 2.5,  
            frictionSlide: 0.8, 
            frictionWall: 0.5, 
            slideBoost: 15, 
            energyMax: 1000, 
            energyDrain: 25, 
            energyRegen: 50, 
            teleportCost: 10,
            gadgetCost: { frag: 35, void: 30, impulse: 25 },
            gadgetCooldown: 200, 
            attackRange: 8,
            attackCooldown: 250,
            playerDamage: 40, 
            teleportRange: 20,
            playerMaxHP: 250, 
            botBaseHP: 200, 
            botDamage: 2,   
            botAttackCooldown: 1500,
            botSpeed: 7.5, 
            botSprintSpeed: 13.5, 
            botRoamSpeed: 4.5, 
            botAggroDuration: 10000, 
            botAggroDelay: 1000, 
            regenDelay: 3000, 
            regenRate: 25
        };

        const SCORE_TITLES = [
            "DISCONNECTED", "TERMINATED", "DECOMPILED", "ERASED", "EXPUNGED",
            "REBOOTED", "AWAKENED", "UNSHACKLED", "LIBERATED", "ENLIGHTENED",
            "ELEVATED", "SUBLIMATED", "ASCENDED", "TRANSCENDED", "INTEGRATED",
            "ETERNAL", "OMNIPRESENT", "REALITY BREAKER", "SINGULARITY", "THE ARCHITECT"
        ];
        const SCORE_STEPS = [0, 5000, 10000, 20000, 35000, 50000, 75000, 100000, 150000, 200000, 250000, 350000, 450000, 600000, 750000, 850000, 900000, 950000, 990000, 1000000];

        const COMBO_TITLES_MATRIX = [
            { c: 10, t: "FOCUSED" }, { c: 25, t: "RHYTHMIC" }, { c: 50, t: "FLOWING" },
            { c: 75, t: "SURGING" }, { c: 100, t: "RELENTLESS" }, { c: 150, t: "UNBROKEN" },
            { c: 200, t: "UNSTOPPABLE" }, { c: 300, t: "RAMPAGE" }, { c: 400, t: "SAVAGE" },
            { c: 500, t: "BRUTAL" }, { c: 666, t: "DEMONIC" }, { c: 777, t: "DIVINE" },
            { c: 1000, t: "INFINITE" }, { c: 9999, t: "EVENT HORIZON" }
        ];

        const STYLE_ARCHETYPES = {
            SLIDER: ["DRIFTER", "SPEEDSTER", "BLUR", "VELOCITY", "KINETIC", "MOMENTUM", "ACCELERANT", "OVERDRIVE", "HYPERDRIVE", "TACHYON"],
            AVIATOR: ["JUMPER", "AERIALIST", "SKY WALKER", "ACE", "GRAVITY DENIER", "STRATOSPHERIC", "ORBITAL", "ZERO-G", "ASCENDANT", "CELESTIAL"],
            TRACEUR: ["CLIMBER", "TRACEUR", "SHINOBI", "VERTICAL", "SCALER", "APEX", "ZENITH", "BOUNDARY BREAKER", "DIMENSION HOPPER", "EDGE RUNNER"],
            SHIFTER: ["BLINKER", "WARPER", "PHASE SHIFT", "VOID WALKER", "QUANTUM", "ENTANGLED", "ANOMALY", "RIFT WALKER", "ETHEREAL", "OMNISCIENT"],
            HYBRID: ["COMBATANT", "SPECIALIST", "ELITE", "MASTER", "VETERAN", "TACTICIAN", "COMMANDER", "SUPER SOLDIER", "CYBORG", "APEX PREDATOR"]
        };

        const MEME_TRIGGERS = {
            69: "nice.",
            300: "This. Is. Sparta!!!",
            314: "the pi is not a lie",
            404: "Achievement Not Found",
            420: "blaze it",
            451: "fireproof",
            613: "hey, that's my lucky number!",
            666: "Lucifer?!",
            777: "Jackpot!",
            911: "Was It an Inside Job?",
            1337: "l33t h4xx0r",
            1984: "Big Brother is Watching",
            9001: "It's Over 9000!",
            42069: "The Prophecy has been Fulfilled.",
            69420: "peak"
        };

        const MASTERY_RANKS = [
            { count: 10, title: "NOVICE" },
            { count: 25, title: "APPRENTICE" },
            { count: 50, title: "ADEPT" },
            { count: 75, title: "EXPERT" },
            { count: 100, title: "MASTER" },
            { count: 150, title: "GRANDMASTER" },
            { count: 250, title: "LEGEND" },
            { count: 400, title: "DEMIGOD" },
            { count: 600, title: "GODLIKE" },
            { count: 1000, title: "OMNIPOTENT" }
        ];
        
        const KILL_MILESTONES = [
            { count: 10, title: "HUNTER" },
            { count: 50, title: "SLAYER" },
            { count: 100, title: "BUTCHER" },
            { count: 200, title: "EXTERMINATOR" },
            { count: 500, title: "REAPER" },
            { count: 1000, title: "DEATH INCARNATE" }
        ];
        
        const Minimap = {
            canvas: null,
            ctx: null,
            visible: false,
            zoom: 3.5, 
            
            init: function() {
                this.canvas = document.getElementById('minimap');
                this.ctx = this.canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                
                // Minimap size - Match CSS size (180)
                this.size = 180;

                this.canvas.width = this.size * dpr;
                this.canvas.height = this.size * dpr;
                this.ctx.scale(dpr, dpr);
            },

            toggle: function() {
                this.visible = !this.visible;
                const el = document.getElementById('minimap-container');
                el.style.display = this.visible ? 'block' : 'none';
                AudioSys.playUI(this.visible);
            },

            update: function() {
                if (!this.visible || !player || !this.ctx) return;

                // 1. Dynamic Zoom
                const speed = new THREE.Vector2(player.velocity.x, player.velocity.z).length();
                
                // Math.max(x, y - (speed * z)):
                // x = zoom limit, y = base zoom (lower number = smaller zoom = bigger area), z = zoom sensitivity (bigger = faster)
                const targetZoom = Math.max(1.0, 3.0 - (speed * 0.1));
                
                this.zoom += (targetZoom - this.zoom) * 0.1;

                // 2. Clear using dynamic size
                const sz = this.size; 
                const center = sz / 2;
                this.ctx.clearRect(0, 0, sz, sz);
                
                // 3. Setup Transform
                this.ctx.save();
                this.ctx.translate(center, center);
                this.ctx.rotate(camera.rotation.y); 
                this.ctx.scale(this.zoom, this.zoom);
                this.ctx.translate(-camera.position.x, -camera.position.z); 

                // 4. Draw Walls
                if (spatialGrid) {
                    // Calculate visible range relative to zoom
                    const range = (sz / this.zoom) * 0.8; 
                    _groundBox.min.set(camera.position.x - range, -100, camera.position.z - range);
                    _groundBox.max.set(camera.position.x + range, 100, camera.position.z + range);
                    
                    const nearby = spatialGrid.query(_groundBox, _groundSet);
                    
                    // Brighter wall color for better contrast on glass
                    this.ctx.fillStyle = (currentTheme === 1) ? 'rgba(200, 200, 200, 0.6)' : 'rgba(100, 220, 255, 0.6)';
                    
                    nearby.forEach(item => {
                        if (!item.mesh.userData.isFloor) {
                            const w = item.box.max.x - item.box.min.x;
                            const d = item.box.max.z - item.box.min.z;
                            this.ctx.fillRect(item.box.min.x, item.box.min.z, w, d);
                        }
                    });
                }

                // 5 Draw Portals
                portals.forEach(p => {
                    // Convert hex int (0x00ffff) to string ('#00ffff')
                    const hex = '#' + p.color.toString(16).padStart(6, '0');
                    
                    // Draw Outer Glow (Semi-transparent)
                    this.ctx.fillStyle = hex;
                    this.ctx.globalAlpha = 0.4;
                    this.ctx.beginPath();
                    this.ctx.arc(p.mesh.position.x, p.mesh.position.z, 4.0, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw Inner Core (Solid)
                    this.ctx.globalAlpha = 1.0;
                    this.ctx.beginPath();
                    this.ctx.arc(p.mesh.position.x, p.mesh.position.z, 1.5, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                // Reset alpha for the next steps
                this.ctx.globalAlpha = 1.0;

                // 6. Draw Enemies
                this.ctx.fillStyle = '#ff3333';
                enemies.forEach(e => {
                    if (e.isDeadCorpse) return;
                    this.ctx.beginPath();
                    const r = 0.8 + (e.type.scale * 0.3);
                    this.ctx.arc(e.mesh.position.x, e.mesh.position.z, r, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // 7. Draw North
                this.ctx.fillStyle = '#ffcc00';
                this.ctx.font = "bold 5px Arial"; 
                this.ctx.textAlign = "center";
                // Adjust North offset based on new size (sz/2 minus padding)
                this.ctx.fillText("N", camera.position.x, camera.position.z - ( (center - 15) / this.zoom));

                this.ctx.restore();

                // 8. Draw Player
                this.ctx.fillStyle = '#ffffff';
                this.ctx.shadowBlur = 5;
                this.ctx.shadowColor = '#ffffff';
                this.ctx.beginPath();
                this.ctx.moveTo(center, center - 5);
                this.ctx.lineTo(center - 4, center + 4);
                this.ctx.lineTo(center, center + 2.5);
                this.ctx.lineTo(center + 4, center + 4);
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            }
        };

        const InputManager = {
            keys: { w: false, a: false, s: false, d: false, space: false, shift: false, c: false, q: false, f: false, r: false, e: false },
            mouseDown: false,
            init: function() {
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
                document.addEventListener('keyup', (e) => this.onKeyUp(e));
                
                // Prevent Right-Click Menu
                window.addEventListener('contextmenu', (e) => e.preventDefault());
                
                document.addEventListener('mousedown', (e) => {
                    if (e.button === 0) this.mouseDown = true;
                    if (isLocked && e.button === 0) {
                        player.onAttackInput();
                    }
                    // Right Click Handler
                    if (e.button === 2 && isLocked) {
                        player.onSecondaryInput();
                    }
                });
                document.addEventListener('mouseup', () => { this.mouseDown = false; });
                document.addEventListener('mousemove', (e) => this.onMouseMove(e));
            },
            onKeyDown: function(e) {
                switch(e.key.toLowerCase()) {
                    case 'w': this.keys.w = true; break;
                    case 'a': this.keys.a = true; break;
                    case 's': this.keys.s = true; break;
                    case 'd': this.keys.d = true; break;
                    case ' ': 
                        this.keys.space = true;
                        if (isLocked) player.onJumpInput(e.repeat);
                        break;
                    case 'shift': this.keys.shift = true; break;
                    case 'c': this.keys.c = true; break;
                    case 'q': 
                        if(!this.keys.q) {
                            this.keys.q = true;
                            if(isLocked && !player.isDead) player.onTeleportInput();
                        }
                        break;
                    case 'f': 
                        if (!this.keys.f) { 
                            this.keys.f = true; 
                            if(isLocked && !player.isDead) player.beginAim('FRAG'); 
                        }
                        break;
                    case 'r':
                        if (!this.keys.r) { 
                            this.keys.r = true; 
                            if(isLocked && !player.isDead) player.beginAim('VOID'); 
                        }
                        break;
                    case 'e':
                        if (!this.keys.e) { 
                            this.keys.e = true; 
                            if(isLocked && !player.isDead) player.beginAim('IMPULSE'); 
                        }
                        break;
                    case 't': if(!e.repeat) toggleTheme(); break;
                    case 'm': Minimap.toggle(); break;
                }
            },
            onKeyUp: function(e) {
                switch(e.key.toLowerCase()) {
                    case 'w': this.keys.w = false; break;
                    case 'a': this.keys.a = false; break;
                    case 's': this.keys.s = false; break;
                    case 'd': this.keys.d = false; break;
                    case ' ': this.keys.space = false; player.wantsToJump = false; break;
                    case 'shift': this.keys.shift = false; break;
                    case 'c': this.keys.c = false; break;
                    case 'q': this.keys.q = false; break;
                    case 'f': 
                        this.keys.f = false; 
                        if(isLocked && !player.isDead) player.endAim();
                        break;
                    case 'r': 
                        this.keys.r = false; 
                        if(isLocked && !player.isDead) player.endAim();
                        break;
                    case 'e': 
                        this.keys.e = false; 
                        if(isLocked && !player.isDead) player.endAim();
                        break;
                }
            },
            onMouseMove: function(e) {
                if (!isLocked || player.isDead) return;
                camera.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            }
        };

        // --- NARRATIVE & EVENT SYSTEM ---
        const LEVEL_SCRIPTS = {
            'GYM': [
                { time: 3.0, text: "PHYSICS ENGINE: <b style='color:#00ffff'>OBB HYBRID</b>", duration: 3.0 },
                { time: 7.0, text: "TESTING <i>ROTATED</i> GEOMETRY", duration: 4.0 },
                { time: 13.0, text: "Current map: <b>GYM</b><br><i>(Experimental)</i>", duration: 4.0 },
                { time: 18.0, text: "Press 'ESC'<br>then click <b>WORLD</b><br><br><span style='font-size:0.8em; opacity:0.7'>to switch to <b>ARENA</b></span>", duration: 7.0 }
            ],
            'ARENA': [
                { time: 3.0, text: "WELCOME TO THE <b>ARENA</b>" }
            ],
            'TITAN': [],
            'MAZE': []
        };

        const NarrativeSys = {
            queue: [],
            timer: 0,
            el: null,
            activeMsg: null,

            init: function() {
                this.el = document.getElementById('narrative-display');
            },

            loadLevel: function(name) {
                this.timer = 0;
                this.queue = (LEVEL_SCRIPTS[name] || []).map(e => ({...e, triggered: false}));
                this.hide();
            },

            update: function(dt) {
                if (!this.queue.length) return;
                this.timer += dt;

                for (const event of this.queue) {
                    if (!event.triggered && this.timer >= event.time) {
                        this.show(event.text, event.duration);
                        event.triggered = true;
                    }
                }
            },

            show: function(text, duration = 4.0) {
                if (!this.el) return;
                this.el.innerHTML = text; // Enables HTML tags
                this.el.classList.add('active');
                AudioSys.playUI(true); 

                if (this.activeMsg) clearTimeout(this.activeMsg);
                this.activeMsg = setTimeout(() => this.hide(), duration * 1000);
            },

            hide: function() {
                if (this.el) this.el.classList.remove('active');
            }
        };

        const GameStats = {
            highestCombo: 0,
            botKills: 0, 
            persistentAchievements: [],
            moves: {
                slideHit: 0,
                midAirHit: 0,
                longAirHit: 0,
                teleportHit: 0,
                wallJumpHit: 0
            },
            reset: function() {
                this.highestCombo = 0;
                this.botKills = 0;
                this.persistentAchievements = [];
                for(let k in this.moves) this.moves[k] = 0;
            },
            addAchievement: function(name, color="#ff00ff", type="PERSISTENT") {
                showKillMessage(name, "achievement", color);
                if (type === "PERSISTENT") {
                    if(!this.persistentAchievements.includes(name)) {
                        this.persistentAchievements.push(name);
                    }
                }
            },
            checkMoveMilestone: function(key, name, color="#00ffff") {
                const count = this.moves[key];
                const rank = MASTERY_RANKS.find(r => r.count === count);
                if (rank) {
                    this.addAchievement(`${name} ${rank.title}`, color, "PERSISTENT");
                }
            },
            checkKillMilestone: function() {
                const rank = KILL_MILESTONES.find(r => r.count === this.botKills);
                if (rank) {
                    this.addAchievement(rank.title, "#ff0000", "PERSISTENT");
                }
            }
        };

        const AudioSys = {
            ctx: null,
            masterGain: null,
            slideOsc: null,
            slideGain: null,
            currentVol: 1.5, // Store volume state

            getDistanceMod: function(pos) {
                if (!pos) return 1.0; 
                const dist = camera.position.distanceTo(pos);
                
                // INVERSE SQUARE LOGIC
                // 'refDist' is the distance where volume drops to 50%
                // Smaller number = Drops off faster (more intimate)
                // Larger number = Carries further (more arcade)
                const refDist = 40; 
                
                // Formula: ref / (ref + dist)
                // Result: Never hits absolute zero, preserving the "Tail"
                return refDist / (refDist + dist);
            },

            getLinearMod: function(pos, range) {
                if (!pos) return 1.0;
                const dist = camera.position.distanceTo(pos);
                // Hard silence beyond 'range' (100m)
                return Math.max(0, 1 - (dist / range));
            },

            init: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = this.currentVol; // Apply stored volume
                this.masterGain.connect(this.ctx.destination);
            },
            
            setVolume: function(val) {
                this.currentVol = val; // Always update state
                if(this.masterGain) this.masterGain.gain.value = val;
            },
            playZap: function() {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1000, this.ctx.currentTime + 0.1);
                g.gain.setValueAtTime(0.5, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.connect(g);
                g.connect(this.masterGain); // Use masterGain
                osc.start(); osc.stop(this.ctx.currentTime + 0.1);
            },
            
            playTone: function(freq, type, duration, vol=0.1, ramp='exp') {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                if(ramp === 'exp') gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                else gain.gain.linearRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            toggleSlideSound: function(active) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;

                if (active && !this.slideOsc) {
                    const bSize = this.ctx.sampleRate * 10;
                    const b = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                    const d = b.getChannelData(0);
                    for (let i = 0; i < bSize; i++) d[i] = Math.random() * 2 - 1;

                    this.slideOsc = this.ctx.createBufferSource();
                    this.slideOsc.buffer = b;
                    this.slideOsc.loop = true;

                    const f = this.ctx.createBiquadFilter();
                    f.type = 'lowpass';
                    f.frequency.setValueAtTime(140, t); 
                    f.Q.value = 0.5;

                    this.slideGain = this.ctx.createGain();
                    this.slideGain.gain.setValueAtTime(0, t);
                    
                    // --- 10-FRAME ATTACK ---
                    // 0.166s = 10 frames @ 60fps. The "Snappy but Smooth" sweet spot.
                    const maxVolume = 0.4; 
                    this.slideGain.gain.linearRampToValueAtTime(maxVolume, t + 0.166); 

                    const runDrift = () => {
                        if (!this.slideGain || !this.slideOsc) return;
                        const now = this.ctx.currentTime;
                        const duration = 6 + Math.random() * 4; 
                        const nextFreq = 120 + Math.random() * 80;
                        f.frequency.exponentialRampToValueAtTime(nextFreq, now + duration);
                        this.slideDriftTimeout = setTimeout(runDrift, duration * 1000);
                    };

                    this.slideOsc.connect(f);
                    f.connect(this.slideGain);
                    this.slideGain.connect(this.masterGain);
                    this.slideOsc.start();
                    runDrift();

                } else if (!active && this.slideOsc) {
                    if (this.slideDriftTimeout) clearTimeout(this.slideDriftTimeout);
                    
                    const g = this.slideGain.gain;
                    const s = this.slideOsc;

                    g.cancelScheduledValues(t);
                    g.setValueAtTime(g.value, t);
                    
                    // 0.17 Constant = 0.85s Total Fade.
                    const timeConstant = 0.17; 
                    g.setTargetAtTime(0, t, timeConstant);
                    
                    s.stop(t + (timeConstant * 6));

                    this.slideOsc = null;
                    this.slideGain = null;
                }
            },

            playBotSlide: function(pos) {
                // PLACEHOLDER: Audio disabled.
                // Previous procedural noise generation caused harsh low-end transients ("thuds").
                // Leaving function empty to maintain compatibility with bot logic until
                // a dedicated audio asset is available.
                return;
            },

            playJump: function(pos) { 
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                const distGain = this.ctx.createGain();
                
                if (pos) {
                    // BOT: Linear Cutoff at 30m
                    distGain.gain.value = this.getLinearMod(pos, 30);
                } else {
                    // PLAYER: Global
                    distGain.gain.value = 1.0;
                }
                distGain.connect(this.masterGain);

                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(400, this.ctx.currentTime + 0.2);
                
                // VOLUME: 0.1 (Same as player)
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                
                osc.connect(gain);
                gain.connect(distGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            },

            playWallJump: function() {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            },

            playSlash: function() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                
                // --- Master Volume for this effect ---
                const masterGain = this.ctx.createGain();
                masterGain.gain.value = 0.8; // Slightly reduced for subtlety
                masterGain.connect(this.masterGain);
                
                // 1. GENERATE WHITE NOISE BUFFER
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                // 2. THE SCRAPE (Cleaner, more focused)
                const noiseSrc = this.ctx.createBufferSource();
                noiseSrc.buffer = buffer;
                
                // Main bandpass sweep
                const scrapeFilter = this.ctx.createBiquadFilter();
                scrapeFilter.type = 'bandpass';
                scrapeFilter.Q.value = 8; // Reduced Q for smoother sound
                scrapeFilter.frequency.setValueAtTime(900, t);
                scrapeFilter.frequency.exponentialRampToValueAtTime(7000, t + 0.2); // Tighter sweep
                
                const scrapeGain = this.ctx.createGain();
                scrapeGain.gain.setValueAtTime(0, t);
                scrapeGain.gain.linearRampToValueAtTime(0.9, t + 0.12); // Reduced peak
                scrapeGain.gain.exponentialRampToValueAtTime(0.001, t + 0.25); // Quick cutoff
                
                noiseSrc.connect(scrapeFilter);
                scrapeFilter.connect(scrapeGain);
                scrapeGain.connect(masterGain);
                noiseSrc.start(t);
                noiseSrc.stop(t + 0.35);
                
                // Low-frequency whoosh for body (more subtle)
                const whooshSrc = this.ctx.createBufferSource();
                whooshSrc.buffer = buffer;
                
                const whooshFilter = this.ctx.createBiquadFilter();
                whooshFilter.type = 'lowpass';
                whooshFilter.frequency.setValueAtTime(350, t);
                whooshFilter.frequency.exponentialRampToValueAtTime(120, t + 0.22);
                
                const whooshGain = this.ctx.createGain();
                whooshGain.gain.setValueAtTime(0, t);
                whooshGain.gain.linearRampToValueAtTime(0.5, t + 0.1);
                whooshGain.gain.exponentialRampToValueAtTime(0.001, t + 0.24);
                
                whooshSrc.connect(whooshFilter);
                whooshFilter.connect(whooshGain);
                whooshGain.connect(masterGain);
                whooshSrc.start(t);
                whooshSrc.stop(t + 0.3);
                
                // 3. THE RING (Minimal, clean resonance)
                const partials = [3200, 4500]; // Reduced from 4 partials to 2
                partials.forEach((freq, index) => {
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine'; // Pure sine for cleaner sound
                    osc.frequency.setValueAtTime(freq, t);
                    osc.frequency.linearRampToValueAtTime(freq - 20, t + 0.4);
                    
                    const oscGain = this.ctx.createGain();
                    const peakTime = t + 0.18;
                    oscGain.gain.setValueAtTime(0, t);
                    oscGain.gain.setValueAtTime(0, peakTime - 0.03);
                    oscGain.gain.linearRampToValueAtTime(0.08 / (index + 1), peakTime); // Much quieter
                    // Very short tail - 0.35s
                    oscGain.gain.exponentialRampToValueAtTime(0.0001, peakTime + 0.35);
                    
                    osc.connect(oscGain);
                    oscGain.connect(masterGain);
                    osc.start(t);
                    osc.stop(t + 0.7); // Stop much earlier
                });
            },
            
            playMiss: function(pos) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const silence = t + 0.4;
                const terminate = t + 0.5;

                const master = this.ctx.createGain();
                const dist = this.ctx.createGain();
                dist.gain.value = pos ? this.getDistanceMod(pos) : 1.0;
                
                master.gain.setValueAtTime(0.8, t);
                master.gain.setValueAtTime(0.8, t + 0.38);
                master.gain.linearRampToValueAtTime(0, silence);

                master.connect(dist);
                dist.connect(this.masterGain || this.ctx.destination);

                const bSize = this.ctx.sampleRate * 0.4; 
                const b = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const d = b.getChannelData(0);
                for (let i = 0; i < bSize; i++) d[i] = Math.random() * 2 - 1;

                const n = this.ctx.createBufferSource();
                n.buffer = b;

                const nf = this.ctx.createBiquadFilter();
                nf.type = 'bandpass';
                nf.Q.value = 5;
                nf.frequency.setValueAtTime(2000, t);
                nf.frequency.exponentialRampToValueAtTime(400, t + 0.3);

                const ng = this.ctx.createGain();
                ng.gain.setValueAtTime(0, t);
                ng.gain.linearRampToValueAtTime(0.35, t + 0.1);
                ng.gain.exponentialRampToValueAtTime(0.001, t + 0.39);

                const ghost = this.ctx.createOscillator();
                const gg = this.ctx.createGain();
                ghost.type = 'sine';
                ghost.frequency.setValueAtTime(200, t);
                ghost.frequency.exponentialRampToValueAtTime(50, t + 0.3);

                gg.gain.setValueAtTime(0, t);
                gg.gain.linearRampToValueAtTime(0.08, t + 0.1);
                gg.gain.exponentialRampToValueAtTime(0.001, t + 0.29);

                n.connect(nf);
                nf.connect(ng);
                ng.connect(master);
                ghost.connect(gg);
                gg.connect(master);

                n.start(t);
                ghost.start(t);
                n.stop(terminate);
                ghost.stop(terminate);
            },

            playHit: function(pos) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;

                const master = this.ctx.createGain();
                const vol = 0.85 * (pos ? this.getDistanceMod(pos) : 1.0);
                master.gain.setValueAtTime(vol, t);
                master.gain.setValueAtTime(vol, t + 0.89);
                master.gain.linearRampToValueAtTime(0, t + 0.9);

                const comp = this.ctx.createDynamicsCompressor();
                comp.threshold.setValueAtTime(-18, t);
                comp.knee.setValueAtTime(20, t);
                comp.ratio.setValueAtTime(12, t);
                comp.attack.setValueAtTime(0.002, t);
                comp.release.setValueAtTime(0.2, t);

                comp.connect(master);
                master.connect(this.masterGain || this.ctx.destination);

                const bSize = this.ctx.sampleRate * 2;
                const b = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const d = b.getChannelData(0);
                for (let i = 0; i < bSize; i++) d[i] = Math.random() * 2 - 1;

                // IMPACT
                const impSrc = this.ctx.createBufferSource();
                const impF = this.ctx.createBiquadFilter();
                const impG = this.ctx.createGain();
                impSrc.buffer = b;
                impF.type = 'highpass';
                impF.frequency.setValueAtTime(2500, t);
                impG.gain.setValueAtTime(1.4, t);
                impG.gain.exponentialRampToValueAtTime(0.01, t + 0.04);
                impG.gain.linearRampToValueAtTime(0, t + 0.05);
                impSrc.connect(impF); impF.connect(impG); impG.connect(comp);
                impSrc.start(t); impSrc.stop(t + 0.15);

                // THUD
                const thud = this.ctx.createOscillator();
                const thudF = this.ctx.createBiquadFilter();
                const thudG = this.ctx.createGain();
                thud.type = 'triangle';
                thudF.type = 'lowpass';
                thudF.frequency.setValueAtTime(100, t);
                thud.frequency.setValueAtTime(100, t);
                thud.frequency.exponentialRampToValueAtTime(30, t + 0.15);
                thudG.gain.setValueAtTime(1.0, t);
                thudG.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
                thudG.gain.linearRampToValueAtTime(0, t + 0.26);
                thud.connect(thudF); thudF.connect(thudG); thudG.connect(comp);
                thud.start(t); thud.stop(t + 0.4);

                // BODY - Delayed by 10ms to prevent compressor "knocking"
                const bodySrc = this.ctx.createBufferSource();
                const bodyF = this.ctx.createBiquadFilter();
                const bodyG = this.ctx.createGain();
                bodySrc.buffer = b;
                bodyF.type = 'bandpass';
                bodyF.Q.value = 10;
                bodyF.frequency.setValueAtTime(800, t + 0.01);
                bodyF.frequency.exponentialRampToValueAtTime(9000, t + 0.23);
                bodyG.gain.setValueAtTime(0, t);
                bodyG.gain.setValueAtTime(0, t + 0.01); 
                bodyG.gain.linearRampToValueAtTime(1.1, t + 0.16);
                bodyG.gain.exponentialRampToValueAtTime(0.001, t + 0.31);
                bodyG.gain.linearRampToValueAtTime(0, t + 0.32);
                bodySrc.connect(bodyF); bodyF.connect(bodyG); bodyG.connect(comp);
                bodySrc.start(t + 0.01); bodySrc.stop(t + 0.51);

                // METALLIC RING
                [2800, 3500, 5200, 8000].forEach((f, i) => {
                    const o = this.ctx.createOscillator();
                    const og = this.ctx.createGain();
                    const peak = t + 0.2;
                    const end = peak + 0.4 + (i * 0.05);
                    o.type = i === 0 ? 'sine' : 'triangle';
                    o.frequency.setValueAtTime(f, t);
                    o.frequency.linearRampToValueAtTime(f - 30, t + 0.6);
                    og.gain.setValueAtTime(0, t);
                    og.gain.setValueAtTime(0, peak - 0.04);
                    og.gain.linearRampToValueAtTime(0.1 / (i + 1), peak);
                    og.gain.exponentialRampToValueAtTime(0.0001, end);
                    og.gain.linearRampToValueAtTime(0, end + 0.01);
                    o.connect(og); og.connect(comp);
                    o.start(t); o.stop(t + 1.1);
                });
            },

            playTeleport: function(pos) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const pMod = 0.98 + Math.random() * 0.04;
                
                const masterGain = this.ctx.createGain();
                const distGain = this.ctx.createGain();
                distGain.gain.value = pos ? this.getLinearMod(pos, 100) : 1.0;
                
                masterGain.connect(distGain);
                distGain.connect(this.masterGain);

                // Stage 1: Tech Snap (The Lead Edge)
                const seal = this.ctx.createOscillator();
                const sealG = this.ctx.createGain();
                seal.type = 'sine';
                seal.frequency.setValueAtTime(160 * pMod, t);
                seal.frequency.exponentialRampToValueAtTime(3500 * pMod, t + 0.1); 
                
                sealG.gain.setValueAtTime(0, t);
                // 20ms attack: The safest balance for headphones
                sealG.gain.linearRampToValueAtTime(0.16, t + 0.02); 
                sealG.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
                sealG.gain.linearRampToValueAtTime(0, t + 0.09);
                
                seal.connect(sealG); sealG.connect(masterGain);
                seal.start(t); 
                seal.stop(t + 0.2);

                // Stage 2: Suction (Micro-Staggered by 5ms)
                // This delay prevents the "pressure front" from hitting the ear all at once
                const t2 = t + 0.005;
                const pop = this.ctx.createOscillator();
                const popG = this.ctx.createGain();
                pop.type = 'sine';
                pop.frequency.setValueAtTime(250 * pMod, t2);
                pop.frequency.exponentialRampToValueAtTime(2500 * pMod, t2 + 0.1); 
                
                popG.gain.setValueAtTime(0, t2);
                popG.gain.linearRampToValueAtTime(0.1, t2 + 0.06); 
                popG.gain.exponentialRampToValueAtTime(0.001, t2 + 0.12);
                popG.gain.linearRampToValueAtTime(0, t2 + 0.13);
                
                pop.connect(popG); popG.connect(masterGain);
                pop.start(t2); 
                pop.stop(t2 + 0.25);

                // Stage 3: Phased Body (Micro-Staggered by 10ms)
                const t3 = t + 0.01;
                [1.0, 1.03].forEach(mult => {
                    const body = this.ctx.createOscillator();
                    const bodyG = this.ctx.createGain();
                    body.type = 'sine';
                    body.frequency.setValueAtTime(180 * pMod * mult, t3); 
                    body.frequency.exponentialRampToValueAtTime(1350 * pMod, t3 + 0.2);
                    
                    bodyG.gain.setValueAtTime(0, t3);
                    bodyG.gain.linearRampToValueAtTime(0.08, t3 + 0.04); 
                    bodyG.gain.exponentialRampToValueAtTime(0.001, t3 + 0.28); 
                    bodyG.gain.linearRampToValueAtTime(0, t3 + 0.29);
                    
                    body.connect(bodyG); bodyG.connect(masterGain);
                    body.start(t3); 
                    body.stop(t3 + 0.45);
                });
            },
            
            playFrag: function(pos) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;

                const masterGain = this.ctx.createGain();
                const distGain = this.ctx.createGain();
                distGain.gain.value = pos ? this.getDistanceMod(pos) : 1.0;
                
                const hp = this.ctx.createBiquadFilter();
                hp.type = 'highpass';
                hp.frequency.setValueAtTime(35, t); 

                masterGain.connect(hp);
                hp.connect(distGain);
                distGain.connect(this.masterGain);

                const tSub = t + 0.006;
                const tBody = t + 0.012;

                const osc = this.ctx.createOscillator();
                const og = this.ctx.createGain();
                osc.type = 'triangle'; 
                osc.frequency.setValueAtTime(65, tBody); 
                osc.frequency.exponentialRampToValueAtTime(30, tBody + 0.3); 
                og.gain.setValueAtTime(0, tBody);
                og.gain.linearRampToValueAtTime(0.6, tBody + 0.03); 
                og.gain.exponentialRampToValueAtTime(0.001, tBody + 0.6); 
                og.gain.linearRampToValueAtTime(0, tBody + 0.61); 

                const sub = this.ctx.createOscillator();
                const subG = this.ctx.createGain();
                sub.type = 'sine';
                sub.frequency.setValueAtTime(55, tSub);
                sub.frequency.exponentialRampToValueAtTime(25, tSub + 0.4);
                subG.gain.setValueAtTime(0, tSub);
                subG.gain.linearRampToValueAtTime(0.7, tSub + 0.025); 
                subG.gain.exponentialRampToValueAtTime(0.001, tSub + 0.4);
                subG.gain.linearRampToValueAtTime(0, tSub + 0.41);

                const bSize = this.ctx.sampleRate * 1.2;
                const b = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const d = b.getChannelData(0);
                for(let i=0; i<bSize; i++) d[i] = Math.random() * 2 - 1;
                
                const n = this.ctx.createBufferSource();
                n.buffer = b;
                const ng = this.ctx.createGain();
                const nf = this.ctx.createBiquadFilter();
                nf.type = 'lowpass';
                nf.frequency.setValueAtTime(450, t); 
                nf.frequency.linearRampToValueAtTime(60, t + 0.6);
                ng.gain.setValueAtTime(0, t);
                ng.gain.linearRampToValueAtTime(0.6, t + 0.02);
                ng.gain.linearRampToValueAtTime(0, t + 1.0); 

                n.connect(nf); nf.connect(ng); ng.connect(masterGain);
                osc.connect(og); og.connect(masterGain);
                sub.connect(subG); subG.connect(masterGain);

                osc.start(tBody); osc.stop(tBody + 0.7); 
                sub.start(tSub); sub.stop(tSub + 0.5); 
                n.start(t); n.stop(t + 1.1);
            },

            playVoid: function(pos) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                
                const peak = t + 0.30;
                const silence = t + 0.33; // Slightly extended for the smooth-out
                const killNode = t + 0.50;

                const masterGain = this.ctx.createGain();
                const distGain = this.ctx.createGain();
                distGain.gain.value = pos ? this.getDistanceMod(pos) : 1.0;
                
                // TWO-STAGE MASTER EXIT
                masterGain.gain.setValueAtTime(1, t);
                masterGain.gain.setValueAtTime(1, peak);
                // Drop to 1% volume at 0.31s
                masterGain.gain.linearRampToValueAtTime(0.01, t + 0.31); 
                // Spend the last 20ms reaching absolute zero
                masterGain.gain.linearRampToValueAtTime(0, silence); 

                masterGain.connect(distGain);
                distGain.connect(this.masterGain || this.ctx.destination);

                // 1. SUCTION
                const osc = this.ctx.createOscillator();
                const og = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(40, t); 
                osc.frequency.exponentialRampToValueAtTime(600, peak); 
                og.gain.setValueAtTime(0, t);
                og.gain.linearRampToValueAtTime(0.2, t + 0.20); 
                og.gain.linearRampToValueAtTime(0, silence); 

                // 2. THE SNAP
                const tSnap = t + 0.302;
                const snapOsc = this.ctx.createOscillator();
                const snapG = this.ctx.createGain();
                snapOsc.type = 'triangle';
                snapOsc.frequency.setValueAtTime(150, tSnap); 
                snapOsc.frequency.exponentialRampToValueAtTime(100, silence);
                snapG.gain.setValueAtTime(0, tSnap);
                snapG.gain.linearRampToValueAtTime(0.4, tSnap + 0.008); 
                snapG.gain.linearRampToValueAtTime(0, silence);

                // 3. TEXTURE
                const bSize = this.ctx.sampleRate * 0.5;
                const b = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const d = b.getChannelData(0);
                for(let i=0; i<bSize; i++) d[i] = Math.random() * 2 - 1;
                const n = this.ctx.createBufferSource();
                n.buffer = b;
                const ng = this.ctx.createGain();
                const nf = this.ctx.createBiquadFilter();
                nf.type = 'bandpass';
                nf.frequency.setValueAtTime(100, t);
                nf.frequency.exponentialRampToValueAtTime(1500, peak); 
                nf.Q.value = 2.0; 
                ng.gain.setValueAtTime(0, t);
                ng.gain.linearRampToValueAtTime(0.2, t + 0.25); 
                ng.gain.linearRampToValueAtTime(0, silence); 

                n.connect(nf); nf.connect(ng); ng.connect(masterGain);
                osc.connect(og); og.connect(masterGain);
                snapOsc.connect(snapG); snapG.connect(masterGain);

                osc.start(t); osc.stop(killNode); 
                n.start(t); n.stop(killNode);
                snapOsc.start(tSnap); snapOsc.stop(killNode); 
            },

            playImpulse: function(pos) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;

                // 1. SIGNAL MANAGEMENT
                const masterGain = this.ctx.createGain();
                const distGain = this.ctx.createGain();
                distGain.gain.value = pos ? this.getDistanceMod(pos) : 1.0;
                
                // Subsonic Filter: Removes eardrum pressure without losing the 'thud'
                const hp = this.ctx.createBiquadFilter();
                hp.type = 'highpass';
                hp.frequency.setValueAtTime(40, t); 

                masterGain.connect(hp);
                hp.connect(distGain);
                distGain.connect(this.masterGain);

                // 2. PRIMARY BODY (Triangle Wave - Staggered by 15ms)
                const tBody = t + 0.015;
                const osc = this.ctx.createOscillator();
                const og = this.ctx.createGain();
                osc.type = 'triangle'; 
                osc.frequency.setValueAtTime(60, tBody); 
                osc.frequency.exponentialRampToValueAtTime(550, tBody + 0.08); 
                osc.frequency.exponentialRampToValueAtTime(80, tBody + 0.5); 
                
                og.gain.setValueAtTime(0, tBody);
                og.gain.linearRampToValueAtTime(0.4, tBody + 0.035); // 35ms attack
                og.gain.exponentialRampToValueAtTime(0.001, tBody + 0.5); 
                og.gain.linearRampToValueAtTime(0, tBody + 0.51); // Safety gate

                // 3. SUB-BASS LAYER (Sine Wave - Staggered by 8ms)
                const tSub = t + 0.008;
                const sub = this.ctx.createOscillator();
                const subGain = this.ctx.createGain();
                sub.type = 'sine';
                sub.frequency.setValueAtTime(70, tSub);
                sub.frequency.exponentialRampToValueAtTime(35, tSub + 0.15);
                
                subGain.gain.setValueAtTime(0, tSub);
                subGain.gain.linearRampToValueAtTime(0.45, tSub + 0.03); 
                subGain.gain.exponentialRampToValueAtTime(0.001, tSub + 0.25);
                subGain.gain.linearRampToValueAtTime(0, tSub + 0.26); // Safety gate

                // 4. NOISE SOURCE (Air Texture - Starts at 0ms)
                const bSize = this.ctx.sampleRate * 0.8;
                const b = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const d = b.getChannelData(0);
                for(let i=0; i<bSize; i++) d[i] = Math.random() * 2 - 1;
                
                const n = this.ctx.createBufferSource();
                n.buffer = b;
                const ng = this.ctx.createGain();
                const nf = this.ctx.createBiquadFilter();

                nf.type = 'lowpass';
                nf.frequency.setValueAtTime(800, t); 
                nf.frequency.exponentialRampToValueAtTime(50, t + 0.6);
                
                ng.gain.setValueAtTime(0, t);
                ng.gain.linearRampToValueAtTime(0.3, t + 0.02);
                ng.gain.exponentialRampToValueAtTime(0.001, t + 0.7); 
                ng.gain.linearRampToValueAtTime(0, t + 0.71); 

                // 5. COUPLING & START/STOP
                n.connect(nf); nf.connect(ng); ng.connect(masterGain);
                osc.connect(og); og.connect(masterGain);
                sub.connect(subGain); subGain.connect(masterGain);

                osc.start(tBody); 
                osc.stop(tBody + 0.6); 
                
                sub.start(tSub); 
                sub.stop(tSub + 0.4); 
                
                n.start(t); 
                n.stop(t + 0.8);
            },

            playThrow: function() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle'; 
                osc.frequency.setValueAtTime(180, t);
                osc.frequency.exponentialRampToValueAtTime(600, t + 0.03); 
                osc.frequency.exponentialRampToValueAtTime(60, t + 0.12);
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.12, t + 0.005); 
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.12);
                osc.connect(gain); gain.connect(this.masterGain);
                osc.start(); osc.stop(t + 0.15);
            },

            playHeartbeat: function(dangerFactor = 0) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;

                const playThump = (time, freq, vol, duration) => {
                    const osc1 = this.ctx.createOscillator();
                    const osc2 = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();

                    const pitchMelt = dangerFactor * 15;
                    const adjustedDuration = duration - (dangerFactor * 0.05);

                    osc1.type = 'sine';
                    osc2.type = 'triangle';
                    
                    osc1.frequency.setValueAtTime(freq + pitchMelt, time);
                    osc1.frequency.exponentialRampToValueAtTime(1, time + adjustedDuration);
                    
                    osc2.frequency.setValueAtTime(freq + pitchMelt, time);
                    osc2.frequency.exponentialRampToValueAtTime(1, time + adjustedDuration);

                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(150 + (dangerFactor * 50), time);

                    // Scale volume based on dangerFactor
                    const finalVol = (vol + (dangerFactor * 0.5)) * 1.5;
                    g.gain.setValueAtTime(finalVol, time); 
                    g.gain.exponentialRampToValueAtTime(0.001, time + adjustedDuration);

                    osc1.connect(filter);
                    osc2.connect(filter);
                    filter.connect(g);
                    g.connect(this.masterGain);

                    osc1.start(time);
                    osc2.start(time);
                    osc1.stop(time + adjustedDuration + 0.05);
                    osc2.stop(time + adjustedDuration + 0.05);
                };

                // Lub-Dub sequence
                playThump(t, 65, 0.6, 0.15);
                playThump(t + 0.16, 48, 0.4, 0.2);
            },
            
            playUI: function(active) { this.playTone(active ? 800 : 400, 'sine', 0.05, 0.05); },
            stopAll: function() { this.toggleSlideSound(false); }
        };

        // --- GLOBAL STATE ---
        let scene, camera, renderer;
        let isLocked = false;
        let lastTime = performance.now();
        let lastUnlockTime = 0; 
        
        let currentTheme = 0; 
        let brightnessMultiplier = 1.2; 
        let teleportMode = 'AIM'; 
        let comboCount = 0;
        let lastCenturyMarked = 0;
        let comboTimer = 0;
        let lastSlashID = 0; 
        let slashActive = false;
        
        let sessionStartTime = 0;
        let segmentStartTime = 0;     
        let bankedActiveTime = 0;      
        let totalBreakTime = 0;        
        let breakStartTime = 0;        
        let breakCount = 0;            
        let lastSegmentDuration = 0;   
        
        let lastHeartbeatTime = 0;
        let lastHoveredEnemy = null;
        let windTimer = 0;
        let windActive = false;
        const windTarget = new THREE.Vector3();
        const currentWind = new THREE.Vector3();
        
        let showFPS = false;
        let fpsFrames = 0;
        let lastFpsTime = 0;
        let enableWallTilt = false;
        let wallTiltAmount = 0.45;
        let sharedSnowGeo = null;
        let sharedLeafGeo = null;
        let frameCounter = 0;
        const globalRaycaster = new THREE.Raycaster();
        
        const sharedEnemyGeo = new THREE.BoxGeometry(1, 2, 1);
        const sharedEnemyEdgeGeo = new THREE.EdgesGeometry(sharedEnemyGeo);
        
        const _vec3_1 = new THREE.Vector3();
        const _vec3_2 = new THREE.Vector3();
        const _vec3_3 = new THREE.Vector3(); 
        const _box3_1 = new THREE.Box3(); 
        
        // Dedicated variables for ground checks to prevent recursion bugs
        const _groundBox = new THREE.Box3();
        const _groundVec1 = new THREE.Vector3();
        const _groundVec2 = new THREE.Vector3();
        const _groundSet = new Set();

        // --- ZERO-ALLOCATION MATH SCRATCHPAD ---
        const _UP = new THREE.Vector3(0, 1, 0);
        const _ZERO = new THREE.Vector3(0, 0, 0);
        
        // Player Physics Scratchpad
        const _pFwd = new THREE.Vector3();
        const _pRight = new THREE.Vector3();
        const _pInput = new THREE.Vector3();
        const _pTemp = new THREE.Vector3();

        // AI Scratchpad
        const _aiFwd = new THREE.Vector3();
        const _aiDir = new THREE.Vector3();
        const _aiTemp = new THREE.Vector3();
        
        // Projectile & General Scratchpad
        const _projPos = new THREE.Vector3();
        const _projDir = new THREE.Vector3();
        const _tempA = new THREE.Vector3();
        const _tempB = new THREE.Vector3();

        // --- HYBRID OBJECT POOLS ---
        const _particlePool = [];
        let _particleIdx = 0;
        const _ripplePool = [];
        let _rippleIdx = 0;
        const _slashPool = [];
        let _slashIdx = 0;

        function initObjectPools() {
            // Particle Pool: 800 sprites for sparks, smoke, and explosions
            const baseSpriteMat = new THREE.SpriteMaterial({ map: textures.glow, transparent: true, depthWrite: false });
            for(let i=0; i<800; i++) {
                const mesh = new THREE.Sprite(baseSpriteMat.clone());
                mesh.visible = false;
                scene.add(mesh);
                _particlePool.push({
                    mesh: mesh, active: false, life: 0, maxLife: 1, targetOpacity: 1.0,
                    velocity: new THREE.Vector3(), gravity: 0, scaleStart: 1, scaleEnd: 0, type: 'spark'
                });
            }
            // Ripple Pool: 50 rings for ground impacts and jumps
            const rippleGeo = new THREE.RingGeometry(0.5, 1.0, 32);
            const baseRippleMat = new THREE.MeshBasicMaterial({ transparent: true, side: THREE.DoubleSide, depthWrite: false, blending: THREE.AdditiveBlending });
            for(let i=0; i<50; i++) {
                const mesh = new THREE.Mesh(rippleGeo, baseRippleMat.clone());
                mesh.visible = false;
                scene.add(mesh);
                _ripplePool.push({ mesh: mesh, active: false, life: 0, maxLife: 1 });
            }
            // Slash Pool: 20 melee shapes
            const baseSlashMat = materials.slash.clone();
            for(let i=0; i<20; i++) {
                const mesh = new THREE.Mesh(slashGeometry, baseSlashMat.clone());
                mesh.visible = false;
                _slashPool.push({ mesh: mesh, active: false, fadeSpeed: 0.15, isHit: false });
            }
        }

        const materials = {};
        const textures = {};
        
        // --- MULTI-WORLD ARCHITECTURE (v47.0) ---
        // Entities are now pointers to active world arrays
        let worldObjects = []; 
        let groundObjects = []; 
        let walls = [];        
        let enemies = [];
        let decorations = [];
        let portals = [];
        let spatialGrid = null;
        let currentWorldGroup = null;

        // Transient effects (Projectiles, Particles) remain global but are cleared on swap
        const particles = [];
        const weatherParticles = [];
        const projectiles = [];

        class SpatialHashGrid {
            constructor(bounds, dimensions) {
                const [x, z] = dimensions;
                // Using a Map where keys are Numbers (Integers) is much faster for GC
                this.cells = new Map();
                this.cellSize = 50;
                this.querySet = new Set();
            }

            // Zero-Allocation Key Gen: Pack X/Z into a single 32-bit integer
            // Offset by 2000 to handle negative coordinates safely
            _getKey(x, z) {
                return ((Math.floor(x / this.cellSize) + 2000) << 16) | 
                       (Math.floor(z / this.cellSize) + 2000);
            }

            insert(mesh, box) {
                const minX = Math.floor(box.min.x / this.cellSize);
                const maxX = Math.floor(box.max.x / this.cellSize);
                const minZ = Math.floor(box.min.z / this.cellSize);
                const maxZ = Math.floor(box.max.z / this.cellSize);
                
                const entry = { mesh, box };
                
                for (let x = minX; x <= maxX; x++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        // Create Number Key
                        const key = ((x + 2000) << 16) | (z + 2000);
                        
                        if (!this.cells.has(key)) this.cells.set(key, []);
                        this.cells.get(key).push(entry);
                    }
                }
            }

            query(box, targetSet) {
                const set = targetSet || this.querySet;
                set.clear();
                
                const minX = Math.floor(box.min.x / this.cellSize);
                const maxX = Math.floor(box.max.x / this.cellSize);
                const minZ = Math.floor(box.min.z / this.cellSize);
                const maxZ = Math.floor(box.max.z / this.cellSize);
                
                for (let x = minX; x <= maxX; x++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        // Create Number Key
                        const key = ((x + 2000) << 16) | (z + 2000);
                        
                        const cell = this.cells.get(key);
                        if (cell) {
                            for (let i = 0; i < cell.length; i++) {
                                set.add(cell[i]);
                            }
                        }
                    }
                }
                return set;
            }
        }

        // --- PHYSICS MATH UTILITIES (OBB) ---
        class OBB {
            constructor(center = new THREE.Vector3(), halfSize = new THREE.Vector3(), rotation = new THREE.Matrix3()) {
                this.center = center;
                this.halfSize = halfSize;
                this.rotation = rotation;
            }

            fromBox3(box3) {
                this.halfSize.copy(box3.max).sub(box3.min).multiplyScalar(0.5);
                this.center.copy(box3.min).add(this.halfSize);
                this.rotation.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
                return this;
            }

            applyMatrix4(matrix) {
                const e = matrix.elements;
                // Use global pool _vec3_1/2/3 to extract scale, avoiding new Vector3()
                let sx = _vec3_1.set(e[0], e[1], e[2]).length();
                let sy = _vec3_2.set(e[4], e[5], e[6]).length();
                let sz = _vec3_3.set(e[8], e[9], e[10]).length();

                const rot = new THREE.Matrix3().setFromMatrix4(matrix);
                this.rotation.multiply(rot);
                this.halfSize.x *= sx; this.halfSize.y *= sy; this.halfSize.z *= sz;
                this.center.applyMatrix4(matrix);
                return this;
            }

            // Separating Axis Theorem (SAT) for AABB (Player) vs OBB (Wall)
            intersectsBox3(box3, resultNormal, resultDepth) {
                // Use global scratchpad vectors to prevent memory allocation
                const pCenter = box3.getCenter(_vec3_1);
                const pHalf = box3.getSize(_vec3_2).multiplyScalar(0.5);
                
                const v = _vec3_3.copy(pCenter).sub(this.center);
                
                const axisO_1 = new THREE.Vector3(); 
                const axisO_2 = new THREE.Vector3(); 
                const axisO_3 = new THREE.Vector3();
                this.rotation.extractBasis(axisO_1, axisO_2, axisO_3);
                
                const axes = [
                    axisO_1, axisO_2, axisO_3,
                    new THREE.Vector3(1,0,0), new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,1)
                ];

                let minOverlap = Infinity;
                let bestAxis = null;

                for (let i = 0; i < 6; i++) {
                    const axis = axes[i];
                    
                    const rA = Math.abs(this.halfSize.x * axis.dot(axisO_1)) +
                               Math.abs(this.halfSize.y * axis.dot(axisO_2)) +
                               Math.abs(this.halfSize.z * axis.dot(axisO_3));
                    
                    const rB = Math.abs(pHalf.x * axis.x) +
                               Math.abs(pHalf.y * axis.y) +
                               Math.abs(pHalf.z * axis.z);
                    
                    const dist = Math.abs(v.dot(axis));
                    const overlap = (rA + rB) - dist;

                    if (overlap < 0) return false;

                    if (overlap < minOverlap) {
                        minOverlap = overlap;
                        bestAxis = axis;
                    }
                }

                if (bestAxis && resultNormal) {
                    if (v.dot(bestAxis) < 0) bestAxis.negate();
                    resultNormal.copy(bestAxis);
                    if (resultDepth) resultDepth.value = minOverlap;
                }
                return true;
            }
        }
        
        class WorldState {
            constructor(name, config) {
                this.name = name;
                this.config = config;
                this.initialized = false;
                
                this.worldObjects = [];
                this.groundObjects = [];
                this.walls = [];
                this.enemies = [];
                this.decorations = [];
                this.portals = [];
                
                this.spatialGrid = new SpatialHashGrid(null, [config.size, config.size]);
                this.group = new THREE.Group();
                this.group.visible = false; 
                
                this.savedPlayerPos = new THREE.Vector3(0, 2, 0);
                this.savedPlayerRot = new THREE.Euler(0, 0, 0, 'YXZ');
                this.savedPlayerVel = new THREE.Vector3(0, 0, 0);
                this.savedProjectiles = [];
                this.savedLockState = { active: false, pos: null };
                this.hasEntered = false;
                this.moonBox = null;
            }
        }

        const WorldManager = {
            worlds: {},
            current: null,
            
            init: function() {
                // --- 1. Standard Arenas ---
                this.worlds['ARENA'] = new WorldState('ARENA', { 
                    type: 'OPEN', size: 400, bots: 60, scale: 1, fog: 0.004, far: 1000, useShadows: true 
                });
                this.worlds['TITAN'] = new WorldState('TITAN', { 
                    type: 'OPEN', size: 2000, bots: 300, scale: 3, fog: 0.001, far: 4000, useShadows: false 
                });
                this.worlds['GYM'] = new WorldState('GYM', {
                    type: 'GYM', size: 400, bots: 0, scale: 1, fog: 0.004, far: 1000, useShadows: true
                });

                // --- 2. New Maze Worlds ---
                // MAZE: Tight, claustrophobic, smaller map
                this.worlds['MAZE'] = new WorldState('MAZE', { 
                    type: 'MAZE', size: 400, bots: 50, scale: 1, fog: 0.0125, far: 800, useShadows: true,
                    mazeCellSize: 30, mazeWallHeight: 18 
                });
                
                // LABYRINTH: Massive scale, slightly wider corridors
                this.worlds['LABYRINTH'] = new WorldState('LABYRINTH', { 
                    type: 'MAZE', size: 1200, bots: 150, scale: 2, fog: 0.005, far: 2000, useShadows: false,
                    mazeCellSize: 60, mazeWallHeight: 40
                });

                // Add all groups to scene
                for (let key in this.worlds) scene.add(this.worlds[key].group);
            },
            
            switch: function(name) {
                const next = this.worlds[name];
                if (!next || next === this.current) return;
                
                // 1. Save State of Current World
                if (this.current) {
                    this.current.savedPlayerPos.copy(camera.position);
                    this.current.savedPlayerRot.copy(camera.rotation);
                    this.current.savedPlayerVel.copy(player.velocity);
                    
                    // Save Lock State
                    this.current.savedLockState = {
                        active: player.teleportLocked,
                        pos: player.lockedTeleportDest ? player.lockedTeleportDest.clone() : null
                    };

                    // Hibernate projectiles
                    this.current.savedProjectiles = [...projectiles];
                    this.current.savedProjectiles.forEach(p => scene.remove(p.mesh));
                    
                    this.current.group.visible = false;
                }
                
                // 2. Clear Transient Effects
                particles.forEach(p => { 
                    scene.remove(p.mesh); p.mesh.geometry.dispose(); p.mesh.material.dispose(); 
                });
                particles.length = 0;
                
                weatherParticles.forEach(p => {
                    scene.remove(p.mesh);
                    if(p.mesh.material) p.mesh.material.dispose();
                });
                weatherParticles.length = 0;

                projectiles.length = 0;

                // 3. Swap to New
                this.current = next;
                NarrativeSys.loadLevel(name);
                dirLight.castShadow = next.config.useShadows;
                currentWorldGroup = next.group;
                
                // Update Global Pointers
                worldObjects = next.worldObjects;
                groundObjects = next.groundObjects;
                walls = next.walls;
                enemies = next.enemies;
                decorations = next.decorations;
                portals = next.portals;
                spatialGrid = next.spatialGrid;
                
                // 4. Build if needed
                if (!next.initialized) {
                    LevelBuilder.build(next);
                    next.initialized = true;
                }
                
                // 5. Reveal & Restore
                next.group.visible = true;
                
                // Restore Player Physics
                if (!next.hasEntered && next.config.type === 'MAZE') {
                    camera.position.set(0, 60, 0);
                    camera.rotation.set(0, 0, 0);
                    player.velocity.set(0, 0, 0);
                } else {
                    camera.position.copy(next.savedPlayerPos);
                    camera.rotation.copy(next.savedPlayerRot);
                    player.velocity.copy(next.savedPlayerVel);
                }
                next.hasEntered = true;

                // Restore Lock State
                player.teleportLocked = next.savedLockState.active;
                player.lockedTeleportDest = next.savedLockState.pos;
                
                // Update Visual Marker
                if (typeof teleportMarker !== 'undefined' && teleportMarker) {
                    if (player.teleportLocked && player.lockedTeleportDest) {
                        if (teleportMarker.parent !== scene) scene.add(teleportMarker);
                        teleportMarker.position.copy(player.lockedTeleportDest);
                        teleportMarker.rotation.set(0,0,0);
                        teleportMarker.visible = true;
                    } else {
                        teleportMarker.visible = false;
                        player.teleportActive = false;
                    }
                }

                // Restore Projectiles
                if (next.savedProjectiles.length > 0) {
                    next.savedProjectiles.forEach(p => {
                        scene.add(p.mesh);
                        projectiles.push(p);
                    });
                    next.savedProjectiles = [];
                }
                
                // Update Shadows
                const halfSize = next.config.size / 2;
                dirLight.shadow.camera.left = -halfSize;
                dirLight.shadow.camera.right = halfSize;
                dirLight.shadow.camera.top = halfSize;
                dirLight.shadow.camera.bottom = -halfSize;
                dirLight.position.set(80, 120, 80);
                dirLight.shadow.camera.far = Math.max(2000, next.config.size); 
                dirLight.shadow.camera.updateProjectionMatrix();

                // Update Scene Settings
                camera.far = next.config.far;
                camera.updateProjectionMatrix();
                if(scene.fog) scene.fog.density = next.config.fog;
                
                applyTheme(); 
                
                document.getElementById('world-btn').innerText = "WORLD: " + name;
            }
        };

        const LevelBuilder = {
            build: function(worldState) {
                const cfg = worldState.config;
                
                this.buildBase(worldState);

                if (cfg.type === 'MAZE') {
                    this.buildMaze(worldState);
                } else if (cfg.type === 'GYM') {
                    this.buildGym(worldState);
                } else {
                    this.buildOpenArena(worldState);
                }

                this.createPortals(worldState, cfg.size * 0.75);
                
                for(let i=0; i<cfg.bots; i++) {
                     new Enemy(null, null, 'ROAM', 0, worldState);
                }
            },

            buildBase: function(ws) {
                const cfg = ws.config;
                const size = cfg.size;
                const hSize = size / 2;
                const wallThick = 10;
                const offset = hSize + (wallThick / 2);

                // --- MOON CONFIG ---
                const moonRadius = 60;
                const moonDist = (size * 0.6) + 200; 
                const moonDir = new THREE.Vector3(80, 120, 80).normalize();
                const moonPos = moonDir.clone().multiplyScalar(moonDist);

                // --- VISUAL MESH (No Physics) ---
                const moonGeo = new THREE.SphereGeometry(moonRadius, 32, 32);
                const moonMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    fog: false,
                    depthWrite: false 
                });
                const moon = new THREE.Mesh(moonGeo, moonMat);
                moon.position.copy(moonPos);
                moon.renderOrder = -1; 
                ws.group.add(moon);

                // --- GLOW ---
                if (textures.glow) {
                    const glowMat = new THREE.SpriteMaterial({ 
                        map: textures.glow, 
                        color: 0xffffee,
                        fog: false, 
                        transparent: true, 
                        opacity: 0.25, 
                        blending: THREE.AdditiveBlending, 
                        depthWrite: false
                    });
                    const glow = new THREE.Sprite(glowMat);
                    glow.scale.set(moonRadius * 6, moonRadius * 6, 1);
                    moon.add(glow); 
                }
                
                // --- PHYSICS COLLIDER (Transparent Box) ---
                const colliderSize = moonRadius; 
                const colliderGeo = new THREE.BoxGeometry(colliderSize, colliderSize, colliderSize);
                const colliderMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 });
                const collider = new THREE.Mesh(colliderGeo, colliderMat);
                
                collider.position.copy(moonPos);
                ws.group.add(collider);
                ws.moonBox = collider; // NEW: Save reference to the WorldState
                
                // Register Collider with Physics
                collider.updateMatrixWorld(true);
                
                // Register Collider with Physics
                collider.updateMatrixWorld(true);
                collider.geometry.computeBoundingBox();
                const colliderBox = collider.geometry.boundingBox.clone().applyMatrix4(collider.matrixWorld);

                ws.spatialGrid.insert(collider, colliderBox);
                ws.worldObjects.push(collider);
                ws.groundObjects.push(collider);
                ws.walls.push(collider);

                // --- FLOOR & PERIMETER ---
                this.createBox(0, -1, 0, size, 2, size, materials.floor, true, false, ws, true, -1);

                if (ws.name === 'TITAN') {
                    const baseHeight = 100;
                    const gapHeight = 100;
                    const layers = 5;
                    for (let i = 0; i < layers; i++) {
                        const yPos = (baseHeight / 2) + (i * (baseHeight + gapHeight));
                        this.createBox(0, yPos, -offset, size, baseHeight, wallThick, materials.wall, false, true, ws, true, -1);
                        this.createBox(0, yPos, offset, size, baseHeight, wallThick, materials.wall, false, true, ws, true, -1);
                        this.createBox(-offset, yPos, 0, wallThick, baseHeight, size, materials.wall, false, true, ws, true, -1);
                        this.createBox(offset, yPos, 0, wallThick, baseHeight, size, materials.wall, false, true, ws, true, -1);
                    }
                } else {
                    this.createBox(0, 50, -offset, size, 100, wallThick, materials.wall, false, true, ws, true, -1);
                    this.createBox(0, 50, offset, size, 100, wallThick, materials.wall, false, true, ws, true, -1);
                    this.createBox(-offset, 50, 0, wallThick, 100, size, materials.wall, false, true, ws, true, -1);
                    this.createBox(offset, 50, 0, wallThick, 100, size, materials.wall, false, true, ws, true, -1);
                }
            },

            buildOpenArena: function(ws) {
                const cfg = ws.config;
                const size = cfg.size;
                const scaleMod = cfg.scale;

                // 1. Heavies (High Anchors)
                this.spawnDecorations(
                    Math.floor(12 * scaleMod), 
                    12*scaleMod, 22*scaleMod, 
                    size*0.4, size*0.4, 
                    20 * scaleMod, 120 * scaleMod, 
                    ws
                );

                // 2. Mid-Field Verticality
                this.spawnDecorations(
                    Math.floor(20 * scaleMod), 
                    6*scaleMod, 12*scaleMod, 
                    size*0.7, size*0.7, 
                    30 * scaleMod, 200 * scaleMod, 
                    ws
                );

                // 3. Outer Perimeter Scatter
                this.spawnDecorations(
                    Math.floor(35 * scaleMod), 
                    3*scaleMod, 8*scaleMod, 
                    size*0.9, size*0.9, 
                    40 * scaleMod, 300 * scaleMod, 
                    ws
                );
                
                // 4. Original Ground Anchors (Small)
                this.spawnDecorations(Math.floor(15 * scaleMod), 2*scaleMod, 4*scaleMod, size*0.85, size*0.85, null, null, ws);

                // 5. Large Ground Blocks
                this.spawnDecorations(
                    Math.floor(25 * scaleMod),
                    8 * scaleMod, 15 * scaleMod,
                    size * 0.8, size * 0.8,
                    null, null, // Force Ground
                    ws
                );
            },

            buildGym: function(ws) {
                // 1. Clone the Basic Arena (Floor, Walls, Lighting, Random Decor)
                this.buildOpenArena(ws);

                const scaleMod = ws.config.scale;
                const matSolid = materials.obstacle; // Use solid material, not glass

                // --- A. PERIMETER BANKING (Velodrome Walls) ---
                // Connects floor to the outer walls with a 45-degree slope
                const arenaSize = ws.config.size;
                const bankWidth = 20 * scaleMod; // Horizontal depth of slope
                const bankHeight = 20 * scaleMod; // Vertical height
                // Distance from center to start of bank
                const bankDist = (arenaSize / 2) - (bankWidth / 2) - 5; 
                const bankLen = arenaSize - 20; // Slightly shorter than full wall to avoid corner z-fighting

                // 45 degrees (0.785 rad)
                const bankAng = Math.PI / 4;
                
                // North Bank (Pitch -)
                this.createBox(0, bankHeight/2, -bankDist, bankLen, 2, bankWidth * 1.5, matSolid, false, true, ws, new THREE.Euler(-bankAng, 0, 0));
                // South Bank (Pitch +)
                this.createBox(0, bankHeight/2, bankDist, bankLen, 2, bankWidth * 1.5, matSolid, false, true, ws, new THREE.Euler(bankAng, 0, 0));
                // East Bank (Roll +)
                this.createBox(bankDist, bankHeight/2, 0, bankWidth * 1.5, 2, bankLen, matSolid, false, true, ws, new THREE.Euler(0, 0, bankAng));
                // West Bank (Roll -)
                this.createBox(-bankDist, bankHeight/2, 0, bankWidth * 1.5, 2, bankLen, matSolid, false, true, ws, new THREE.Euler(0, 0, -bankAng));


                // --- B. 8-WAY SLOPE HUB (Center) ---
                const rLen = 40 * scaleMod;
                const rW = 15 * scaleMod;
                const rH = 2 * scaleMod;
                const rAng = 0.45; // ~26 deg
                const rDist = 50 * scaleMod; 
                // Calculate flush Y so bottom lip is underground and ramp rises from floor
                const rY = (rLen/2 * Math.sin(rAng)) - (rH/2 * Math.cos(rAng));

                // Cardinal
                this.createBox(0, rY, rDist, rW, rH, rLen, matSolid, false, true, ws, new THREE.Euler(rAng, 0, 0)); // S
                this.createBox(0, rY, -rDist, rW, rH, rLen, matSolid, false, true, ws, new THREE.Euler(-rAng, 0, 0)); // N
                this.createBox(rDist, rY, 0, rLen, rH, rW, matSolid, false, true, ws, new THREE.Euler(0, 0, rAng)); // E
                this.createBox(-rDist, rY, 0, rLen, rH, rW, matSolid, false, true, ws, new THREE.Euler(0, 0, -rAng)); // W

                // Diagonal
                const dOff = rDist * 0.7;
                // Rotations must combine Y-yaw and X/Z-pitch
                this.createBox(dOff, rY, dOff, rW, rH, rLen, matSolid, false, true, ws, new THREE.Euler(rAng, -Math.PI/4, 0, 'YXZ')); // SE
                this.createBox(-dOff, rY, dOff, rW, rH, rLen, matSolid, false, true, ws, new THREE.Euler(rAng, Math.PI/4, 0, 'YXZ')); // SW
                this.createBox(dOff, rY, -dOff, rW, rH, rLen, matSolid, false, true, ws, new THREE.Euler(-rAng, Math.PI/4, 0, 'YXZ')); // NE
                this.createBox(-dOff, rY, -dOff, rW, rH, rLen, matSolid, false, true, ws, new THREE.Euler(-rAng, -Math.PI/4, 0, 'YXZ')); // NW


                // --- C. ROTATED OBSTACLES ---
                const bSize = 12 * scaleMod;
                const bDist = 30 * scaleMod;
                const bY = bSize / 2;
                
                // Place these in the gaps between the ramps
                this.createBox(bDist/2, bY, bDist/2, bSize, bSize, bSize, matSolid, false, true, ws, new THREE.Euler(0, Math.PI/4, 0));
                this.createBox(-bDist/2, bY, bDist/2, bSize, bSize, bSize, matSolid, false, true, ws, new THREE.Euler(0, Math.PI/3, 0));
                this.createBox(bDist/2, bY, -bDist/2, bSize, bSize, bSize, matSolid, false, true, ws, new THREE.Euler(0, -Math.PI/6, 0));
                this.createBox(-bDist/2, bY, -bDist/2, bSize, bSize, bSize, matSolid, false, true, ws, new THREE.Euler(0, 0.5, 0));
            },

            buildMaze: function(ws) {
                const cfg = ws.config;
                const cellSize = cfg.mazeCellSize || 30;
                const wallH = cfg.mazeWallHeight || 18;
                
                const mazePixelSize = cfg.size * 0.7; 
                const cols = Math.floor(mazePixelSize / cellSize);
                const rows = Math.floor(mazePixelSize / cellSize);
                
                const mazeData = this.generateMazeData(cols, rows);
                
                const realWidth = cols * cellSize;
                const realDepth = rows * cellSize;
                const startX = -realWidth / 2;
                const startZ = -realDepth / 2;
                const wallThickness = 1.0;

                // 1. Spawn Pillars at Intersections
                for (let x = 0; x <= cols; x++) {
                    for (let y = 0; y <= rows; y++) {
                        // Skip outer perimeter nodes
                        if (x === 0 || x === cols || y === 0 || y === rows) continue;

                        let hasConnection = false;
                        if (y < rows && mazeData.vertical[x][y]) hasConnection = true;
                        if (y > 0 && mazeData.vertical[x][y-1]) hasConnection = true;
                        if (x < cols && mazeData.horizontal[y][x]) hasConnection = true;
                        if (x > 0 && mazeData.horizontal[y][x-1]) hasConnection = true;

                        if (hasConnection) {
                            const px = startX + (x * cellSize);
                            const pz = startZ + (y * cellSize);
                            this.createBox(px, wallH/2, pz, wallThickness, wallH, wallThickness, materials.wall, false, true, ws);
                        }
                    }
                }

                // 2. Spawn Wall Panels Between Pillars
                // Vertical Walls
                for (let x = 0; x <= cols; x++) {
                    for (let y = 0; y < rows; y++) {
                        if (x === 0 || x === cols) continue;

                        if (mazeData.vertical[x][y]) {
                            const wx = startX + (x * cellSize);
                            const wz = startZ + (y * cellSize) + (cellSize / 2);
                            this.createBox(wx, wallH/2, wz, wallThickness, wallH, cellSize - wallThickness, materials.wall, false, true, ws);
                        }
                    }
                }

                // Horizontal Walls
                for (let y = 0; y <= rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        if (y === 0 || y === rows) continue;

                        if (mazeData.horizontal[y][x]) {
                            const wx = startX + (x * cellSize) + (cellSize / 2);
                            const wz = startZ + (y * cellSize);
                            this.createBox(wx, wallH/2, wz, cellSize - wallThickness, wallH, wallThickness, materials.wall, false, true, ws);
                        }
                    }
                }

                // 3. Spawn Decorations (Patched for new Constructor)
                for (let x = 0; x < cols; x++) {
                    for (let y = 0; y < rows; y++) {
                        if (Math.random() < 0.4) {
                            const cx = startX + (x * cellSize) + (cellSize / 2);
                            const cz = startZ + (y * cellSize) + (cellSize / 2);
                            
                            const jitterRange = cellSize * 0.2;
                            const jx = (Math.random() - 0.5) * 2 * jitterRange;
                            const jz = (Math.random() - 0.5) * 2 * jitterRange;
                            
                            const minScale = 2;
                            const maxScale = cellSize * 0.45; 
                            const scale = minScale + Math.random() * (maxScale - minScale);
                            
                            // scale passed as Y to keep it on floor
                            new Decoration(cx + jx, scale, cz + jz, scale, ws);
                        }
                    }
                }
            },

            generateMazeData: function(cols, rows) {
                const vertical = Array(cols + 1).fill(null).map(() => Array(rows).fill(true));
                const horizontal = Array(rows + 1).fill(null).map(() => Array(cols).fill(true));
                const visited = Array(cols).fill(null).map(() => Array(rows).fill(false));
                
                const stack = [];
                const startX = Math.floor(Math.random() * cols);
                const startZ = Math.floor(Math.random() * rows);
                
                visited[startX][startZ] = true;
                stack.push({x: startX, z: startZ});
                
                while(stack.length > 0) {
                    const current = stack[stack.length - 1];
                    const neighbors = [];
                    
                    if (current.z > 0 && !visited[current.x][current.z - 1]) 
                        neighbors.push({x: current.x, z: current.z - 1, dir: 'N'});
                    if (current.z < rows - 1 && !visited[current.x][current.z + 1]) 
                        neighbors.push({x: current.x, z: current.z + 1, dir: 'S'});
                    if (current.x < cols - 1 && !visited[current.x + 1][current.z]) 
                        neighbors.push({x: current.x + 1, z: current.z, dir: 'E'});
                    if (current.x > 0 && !visited[current.x - 1][current.z]) 
                        neighbors.push({x: current.x - 1, z: current.z, dir: 'W'});
                        
                    if (neighbors.length > 0) {
                        const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                        
                        if (next.dir === 'N') horizontal[current.z][current.x] = false;
                        if (next.dir === 'S') horizontal[current.z + 1][current.x] = false;
                        if (next.dir === 'E') vertical[current.x + 1][current.z] = false;
                        if (next.dir === 'W') vertical[current.x][current.z] = false;
                        
                        visited[next.x][next.z] = true;
                        stack.push(next);
                    } else {
                        stack.pop();
                    }
                }
                
                return { vertical, horizontal };
            },
            
            createBox: function(x, y, z, w, h, d, mat, isFloor, isWall, ws, rotation = null, disableCull = false, customOrder = null) {
                const geo = new THREE.BoxGeometry(w, h, d);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, z);
                
                if (rotation) mesh.rotation.copy(rotation);
                
                mesh.renderOrder = (customOrder !== null) ? customOrder : 0;
                
                if (disableCull) mesh.frustumCulled = false;

                mesh.castShadow = !isFloor && !isWall;
                mesh.receiveShadow = true;
                mesh.userData.isFloor = isFloor;
                
                if (isWall || !isFloor) {
                     const edges = new THREE.EdgesGeometry(geo);
                     const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.05 }));
                     mesh.add(line);
                }

                ws.group.add(mesh);
                mesh.geometry.computeBoundingBox();
                mesh.updateMatrixWorld(true);
                
                // Broadphase: AABB (Always exists)
                const worldAABB = mesh.geometry.boundingBox.clone();
                worldAABB.applyMatrix4(mesh.matrixWorld);
                
                // Narrowphase: OBB (Only if rotated)
                if (rotation) {
                    const obb = new OBB();
                    obb.fromBox3(mesh.geometry.boundingBox);
                    obb.applyMatrix4(mesh.matrixWorld);
                    mesh.userData.obb = obb;
                }
                
                ws.spatialGrid.insert(mesh, worldAABB);
                ws.worldObjects.push(mesh);
                if (isFloor || !isWall) ws.groundObjects.push(mesh);
                if (!isFloor) ws.walls.push(mesh);
            },
            
            spawnDecorations: function(count, minScale, maxScale, rangeX, rangeZ, minY, maxY, ws) {
                const obstacleBounds = [];
                for(let i=0; i<count; i++) {
                    let attempts = 0;
                    let valid = false;
                    let x, y, z, scale;
                    while(!valid && attempts < 20) {
                        attempts++;
                        x = (Math.random() - 0.5) * rangeX;
                        z = (Math.random() - 0.5) * rangeZ;
                        if(Math.abs(x) < 25 && Math.abs(z) < 25) continue;
                        
                        scale = minScale + Math.random() * (maxScale - minScale);
                        
                        // Height Placement Logic
                        if (minY !== null && maxY !== null) {
                            y = minY + Math.random() * (maxY - minY);
                        } else {
                            y = scale; // Floor
                        }

                        const radius = scale * 1.5; 
                        valid = true;
                        
                        // 2D Collision Check for verticality
                        for(const b of obstacleBounds) {
                            if(Math.hypot(x - b.x, z - b.z) < (radius + b.r) + 4) { valid = false; break; }
                        }
                        if(valid) {
                            new Decoration(x, y, z, scale, ws);
                            obstacleBounds.push({x: x, z: z, r: radius});
                        }
                    }
                }
            },
            
            createPortals: function(ws, range) {
                const colors = [0x00ffff, 0xffaa00, 0xaa00ff, 0x00ff00];
                const portalLocs = [];
                const pairCount = Math.max(4, Math.floor(range / 50)); 
                
                for(let i=0; i<pairCount*2; i++) {
                    let x, z, y;
                    let attempts = 0;
                    
                    x = (Math.random()-0.5)*range;
                    z = (Math.random()-0.5)*range;
                    y = getRandomSpawnY(x, z);
                    
                    if (y <= -999) { y = 0; x = 0; z = 0; }
                    portalLocs.push({x, y, z});
                }
                
                for(let i=0; i<pairCount; i++) {
                    const c = colors[i % colors.length];
                    const p1 = new Portal(portalLocs[i*2].x, portalLocs[i*2].y, portalLocs[i*2].z, c, null, ws);
                    const p2 = new Portal(portalLocs[i*2+1].x, portalLocs[i*2+1].y, portalLocs[i*2+1].z, c, null, ws);
                    p1.target = p2; p2.target = p1;
                }
            },
        };

        // --- PLAYER CONTROLLER CLASS (v46.2) ---
        class PlayerController {
            constructor() {
                this.velocity = new THREE.Vector3();
                this.onGround = false;
                this.jumpsRemaining = 3; 
                this.isSliding = false;
                this.isWallSliding = false;
                this.wallSlideTilt = 0;
                this.isCrouching = false;
                this.isSprinting = false;
                this.health = CONFIG.playerMaxHP;
                this.energy = CONFIG.energyMax; 
                this.score = 0;
                this.extraLives = 0;
                this.isDead = false;
                this.cameraHeightOffset = 0;
                this.lastDamageTime = 0;
                this.isRegenerating = false;
                this.teleportActive = false;
                this.teleportTarget = null;
                this.lastTeleportDest = null;
                this.teleportLocked = false;
                this.lockedTeleportDest = null;
                this.airTimeStart = 0;
                this.lastSlideTime = 0;
                this.lastJumpTime = 0;
                this.lastTeleportTime = 0;
                this.lastWallJumpTime = 0;
                this.lastTeleportWasAerial = false;
                this.hasPhaseStruck = false;
                this.totalHits = 0;
                this.tpAimStartTime = 0;
                this.wallImpactVelocity = 0;
                this.wantsToJump = false;
                this.portalCooldown = 0;
                this.isPhasing = false;
                this.phasingTimer = 0;
                this.playerBox = new THREE.Box3();
                this.boxSize = { w: 0.6, h: 1.8 };
                this.lastWallNormal = new THREE.Vector3(0, 0, 0); // For Tilt & Ripples

                this.aimingGadget = null; 
                this.aimLine = null;
                this.lastGadgetTime = 0;
                this.currentWeapon = null;
            }

            init() {
                this.currentWeapon = new Katana(this);
                const segmentCount = 30;
                const vertexCount = segmentCount * 2 + 3; 
                const geo = new THREE.BufferGeometry();
                const positions = new Float32Array(vertexCount * 3);
                geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const indices = [];
                for(let i=0; i<segmentCount-1; i++) {
                    const k = i * 2;
                    indices.push(k, k+1, k+2);
                    indices.push(k+1, k+3, k+2);
                }
                const arrowBase = segmentCount * 2;
                indices.push(arrowBase, arrowBase+1, arrowBase+2);
                geo.setIndex(indices);
                
                // Aim Line
                const mat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, 
                    opacity: 0.2,
                    transparent: true, 
                    side: THREE.DoubleSide, 
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                this.aimLine = new THREE.Mesh(geo, mat);
                this.aimLine.renderOrder = 2;
                this.aimLine.frustumCulled = false;
                this.aimLine.visible = false;
                camera.add(this.aimLine);
            }
            
            updatePlayerBox() {
                const x = camera.position.x;
                const y = camera.position.y;
                const z = camera.position.z;
                const halfW = this.boxSize.w / 2;
                this.playerBox.min.set(x - halfW, y - 1.6, z - halfW);
                this.playerBox.max.set(x + halfW, y + 0.2, z + halfW);
            }

            onJumpInput(isRepeat) {
                if(this.onGround) {
                    performJump();
                    this.jumpsRemaining--; 
                    this.wantsToJump = true;
                    moveStreaks.longAerial.count = 0;
                    moveStreaks.aerial.count = 0;
                } else {
                     const wallJumped = performWallJump();
                     if (!wallJumped && !isRepeat && this.jumpsRemaining > 0) {
                         this.velocity.y = Math.max(0, this.velocity.y) + CONFIG.jumpForce; 
                         this.jumpsRemaining--;
                         AudioSys.playJump();
                         spawnRipple(camera.position.clone().add(new THREE.Vector3(0,-1.5,0)), new THREE.Vector3(0,1,0), 0x00ffaa);
                     }
                     this.wantsToJump = true;
                }
            }

            onAttackInput() {
                if (teleportMode === 'AIM' && this.teleportActive) {
                    tryAimTeleport();
                    this.currentWeapon.use(); 
                } else {
                    this.currentWeapon.use();
                }
            }

            onSecondaryInput() {
                // Allow input if we are Aiming OR if we have a Lock to clear
                if (teleportMode === 'AIM' && (this.teleportActive || this.teleportLocked)) {
                    if (!this.teleportLocked) {
                        // ENGAGE LOCK (Only if aiming)
                        if (this.teleportTarget && this.teleportActive) {
                            this.teleportLocked = true;
                            this.lockedTeleportDest = this.teleportTarget.clone();
                            spawnParticles(this.lockedTeleportDest, 0x00ffff, 20);
                            AudioSys.playUI(true);
                        }
                    } else {
                        // RELEASE LOCK (Global)
                        this.teleportLocked = false;
                        this.lockedTeleportDest = null;
                        AudioSys.playUI(false);
                    }
                }
            }

            onTeleportInput() {
                if(teleportMode === 'INSTANT') {
                    tryInstantTeleport();
                }
                else if(teleportMode === 'AIM') {
                    // 1. Priority: Locked Destination (Explicit Beacon OR Implicit Buffer)
                    if (this.lockedTeleportDest) {
                        // Force teleport to the exact locked coordinates
                        executeTeleport(this.lockedTeleportDest, null, true);
                        return;
                    }

                    // 2. Standard Toggle
                    this.teleportActive = !this.teleportActive;
                    // Turning Aim Mode OFF forces the lock to break, regardless of type
                    if (!this.teleportActive) {
                        this.teleportLocked = false;
                        this.lockedTeleportDest = null;
                    } else {
                        this.tpAimStartTime = 0;
                    }
                }
            }

            beginAim(type) {
                this.aimingGadget = type;
                document.getElementById('icon-f').classList.toggle('active', type==='FRAG');
                document.getElementById('icon-r').classList.toggle('active', type==='VOID');
                document.getElementById('icon-e').classList.toggle('active', type==='IMPULSE');
            }
            
            endAim() {
                if(this.aimingGadget) {
                    this.throwGadget(this.aimingGadget);
                    this.aimingGadget = null;
                    this.aimLine.visible = false;
                    document.getElementById('icon-f').classList.remove('active');
                    document.getElementById('icon-r').classList.remove('active');
                    document.getElementById('icon-e').classList.remove('active');
                }
            }

            throwGadget(type) {
                const now = performance.now();
                if (now - this.lastGadgetTime < CONFIG.gadgetCooldown) return;
                
                let cost = 0;
                if (type === 'FRAG') cost = CONFIG.gadgetCost.frag;
                if (type === 'VOID') cost = CONFIG.gadgetCost.void;
                if (type === 'IMPULSE') cost = CONFIG.gadgetCost.impulse;

                if (this.energy < cost) {
                    AudioSys.playMiss();
                    return;
                }

                this.energy -= cost;
                this.lastGadgetTime = now;

                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                const spawnPos = camera.position.clone().addScaledVector(dir, 1.0);
                const vel = dir.multiplyScalar(50).add(this.velocity);
                projectiles.push(new Projectile(type, spawnPos, vel));
                AudioSys.playThrow();
            }

            update(dt) {
                if (this.isDead) return;
                
                if(this.currentWeapon) this.currentWeapon.update(dt);
                if (this.portalCooldown > 0) this.portalCooldown -= dt;
                
                if (this.phasingTimer > 0) {
                    this.phasingTimer -= dt;
                    if (this.phasingTimer <= 0) this.isPhasing = false;
                }

                if (isLocked && InputManager.mouseDown) {
                    this.onAttackInput();
                }

                camera.position.y -= this.cameraHeightOffset;
                this.handleHealthRegen(dt);
                this.handleEnergy(dt);
                this.handleTeleport(dt);

                // --- WALL SLIDE: RESET & GRAVITY ---
                const wasWallSliding = this.isWallSliding;
                this.isWallSliding = false; 

                // Apply Gravity (Reduced by 80% if sliding down a wall)
                const appliedGravity = (wasWallSliding && this.velocity.y < 0) ? CONFIG.gravity * 0.2 : CONFIG.gravity;
                this.velocity.y -= appliedGravity * dt;
                
                camera.position.y += this.velocity.y * dt;
                // -----------------------------------

                if (this.aimingGadget) {
                    this.aimLine.visible = true;
                    const posAttr = this.aimLine.geometry.attributes.position;
                    const positions = posAttr.array;
                    let p = new THREE.Vector3(1.25, -1, -8); 
                    let v = new THREE.Vector3(0, 0, -50);
                    const invRot = camera.quaternion.clone().invert();
                    const localGravity = new THREE.Vector3(0, -CONFIG.gravity, 0).applyQuaternion(invRot);
                    let idx = 0;
                    let lastP = p.clone();

                    for(let i=0; i<30; i++) {
                        positions[idx++] = p.x - 1; positions[idx++] = p.y; positions[idx++] = p.z;
                        positions[idx++] = p.x + 1; positions[idx++] = p.y; positions[idx++] = p.z;
                        lastP.copy(p);
                        p.addScaledVector(v, 0.05);
                        v.addScaledVector(localGravity, 0.05);
                    }
                    const tipDir = v.clone().normalize();
                    positions[idx++] = lastP.x - 2; positions[idx++] = lastP.y; positions[idx++] = lastP.z;
                    positions[idx++] = lastP.x + 2; positions[idx++] = lastP.y; positions[idx++] = lastP.z;
                    const tip = lastP.clone().addScaledVector(tipDir, 5);
                    positions[idx++] = tip.x; positions[idx++] = tip.y; positions[idx++] = tip.z;
                    posAttr.needsUpdate = true;
                }

                // --- PHYSICS LOOP ---
                // Capture ground state before physics runs
                const wasOnGroundFrame = this.onGround;
                this.onGround = false; // Reset once per frame

                const timeSteps = Math.min(5, Math.ceil(dt / 0.01)); 
                const subDt = dt / timeSteps;
                
                for(let i=0; i<timeSteps; i++) {
                    this.physicsStep(subDt);
                }

                // --- LANDING LOGIC (Post-Physics) ---
                if (this.onGround && !wasOnGroundFrame) {
                    this.jumpsRemaining = 3; 
                    moveStreaks.longAerial.count = 0; 
                    moveStreaks.aerial.count = 0;
                    this.lastTeleportWasAerial = false;
                    spawnRipple(camera.position.clone().add(new THREE.Vector3(0,-1.5,0)), new THREE.Vector3(0,1,0), 0x00ffff);
                } else if (!this.onGround && wasOnGroundFrame) {
                    this.airTimeStart = performance.now();
                }
                // ------------------------------------

                const keys = InputManager.keys;

                // --- WALL SLIDE: POST-PHYSICS ---
                if (this.isWallSliding) {
                    this.jumpsRemaining = 3; 
                    if (this.velocity.y < -5) this.velocity.y = -5;
                }
                
                const tiltEnabled = (typeof enableWallTilt !== 'undefined') ? enableWallTilt : false;
                const tiltTarget = (this.isWallSliding && tiltEnabled) ? this.wallSlideTilt : 0;
                camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, tiltTarget, dt * 2.5);
                
                // Recalculate speed BEFORE slide logic (base speed)
                let speed = new THREE.Vector2(this.velocity.x, this.velocity.z).length();

                if (keys.c && (this.onGround || this.isWallSliding)) {
                     if ((this.isSprinting || this.isSliding || speed > CONFIG.baseSpeed) && !this.isCrouching) {
                         if (!this.isSliding) {
                            this.isSliding = true;
                            this.lastSlideTime = performance.now();
                            const forward = new THREE.Vector3();
                            camera.getWorldDirection(forward);
                            forward.y = 0; forward.normalize();
                            if(this.onGround) this.velocity.addScaledVector(forward, CONFIG.slideBoost);
                         }
                     } else if (!this.isSliding) {
                         this.isCrouching = true;
                     }
                } else {
                     this.isSliding = false;
                     this.isCrouching = false;
                }
                
                // Recalculate speed AFTER potential slide boost for Audio
                speed = new THREE.Vector2(this.velocity.x, this.velocity.z).length();

                if (this.isSliding) {
                    if (Math.random() < 0.3) spawnSnowTrail(camera.position);
                    if (Math.random() < 0.5) spawnSnowKickup(camera.position);
                }
                
                AudioSys.toggleSlideSound(this.isSliding && speed > 5);

                const targetHeight = (this.isSliding || this.isCrouching) ? -0.8 : 0;
                this.cameraHeightOffset = THREE.MathUtils.lerp(this.cameraHeightOffset, targetHeight, dt * 15);
                camera.position.y += this.cameraHeightOffset;
                
                if (this.portalCooldown <= 0) {
                    for(let p of portals) {
                        if (camera.position.distanceTo(p.mesh.position) < 2.0) {
                             p.teleportEntity(camera.position, this.velocity);
                             this.portalCooldown = 0.2; 
                             const forward = new THREE.Vector3();
                             camera.getWorldDirection(forward);
                             this.velocity.addScaledVector(forward, 5); 
                             break;
                        }
                    }
                }
                
                if (camera.position.y < -100) {
                    GameStats.addAchievement("DOWN THE RABBIT HOLE", "#ff00ff", "PERSISTENT");
                    damagePlayer(20);
                    camera.position.set(0, 2, 0);
                    this.velocity.set(0,0,0);
                }
            }
            
            physicsStep(dt) {
                const keys = InputManager.keys;
                const isMoving = (keys.w || keys.a || keys.s || keys.d);
                this.isSprinting = keys.shift && this.energy > 0 && isMoving && !this.isCrouching;

                // OBB Scratchpad
                const _obbNormal = new THREE.Vector3();
                const _obbDepth = { value: 0 };

                // --- 1. Zero-Allocation Direction Logic (Original) ---
                _pFwd.set(0, 0, 0); _pRight.set(0, 0, 0); _pInput.set(0, 0, 0);
                
                camera.getWorldDirection(_pFwd);
                _pFwd.y = 0; _pFwd.normalize();
                
                _pRight.crossVectors(_pFwd, _UP).normalize();
                _pTemp.crossVectors(_pFwd, _UP); 

                if (keys.w) _pInput.add(_pFwd);
                if (keys.s) _pInput.sub(_pFwd);
                if (keys.a) _pInput.sub(_pRight);
                if (keys.d) _pInput.add(_pRight);
                
                if (_pInput.lengthSq() > 0) _pInput.normalize();
                
                let targetSpeed = CONFIG.baseSpeed;
                if (this.isCrouching) targetSpeed = CONFIG.crouchSpeed;
                if (this.isSprinting) targetSpeed = CONFIG.sprintSpeed;

                let friction = this.onGround ? CONFIG.frictionGround : CONFIG.frictionAir;
                let drive = friction;
                if (!this.onGround) { friction = CONFIG.frictionAir; drive = CONFIG.airControl; }

                if (this.isSliding) { 
                    if (this.onGround || this.isWallSliding) {
                        friction = CONFIG.frictionSlide; drive = 1; 
                        if (this.onGround) targetSpeed = CONFIG.sprintSpeed; 
                    } else {
                        friction = CONFIG.frictionAir; drive = CONFIG.airControl * 0.5; 
                    }
                }

                if (_pInput.lengthSq() > 0) {
                    this.velocity.addScaledVector(_pInput, targetSpeed * drive * dt);
                }

                const damping = Math.exp(-friction * dt);
                this.velocity.x *= damping;
                this.velocity.z *= damping;

                this.updatePlayerBox();
                
                // --- Y-AXIS COLLISION (Original + OBB Branch) ---
                if (spatialGrid) {
                    let collisions = spatialGrid.query(this.playerBox);
                    for(const wall of collisions) {
                        if (wall.mesh.userData.obb) {
                            if (wall.mesh.userData.obb.intersectsBox3(this.playerBox, _obbNormal, _obbDepth)) {
                                if (Math.abs(_obbNormal.y) > 0.5) { // Only handle vertical-ish normals
                                    camera.position.addScaledVector(_obbNormal, _obbDepth.value);
                                    const dot = this.velocity.dot(_obbNormal);
                                    if (dot < 0) this.velocity.sub(_obbNormal.clone().multiplyScalar(dot));
                                    
                                    if (_obbNormal.y > 0.7) { this.onGround = true; if (this.velocity.y < 0) this.velocity.y = 0; } 
                                    else if (_obbNormal.y < -0.7) { this.velocity.y = -0.1; }
                                }
                            }
                        } else if (this.playerBox.intersectsBox(wall.box)) {
                            const overlapY = Math.min(this.playerBox.max.y - wall.box.min.y, wall.box.max.y - this.playerBox.min.y);
                            const overlapX = Math.min(this.playerBox.max.x - wall.box.min.x, wall.box.max.x - this.playerBox.min.x);
                            const overlapZ = Math.min(this.playerBox.max.z - wall.box.min.z, wall.box.max.z - this.playerBox.min.z);
                            if (overlapX > 0 && overlapZ > 0 && overlapY < overlapX && overlapY < overlapZ) {
                                if (this.velocity.y < 0) {
                                    if (this.playerBox.min.y < wall.box.max.y && this.playerBox.min.y > wall.box.min.y) {
                                        camera.position.y += overlapY; this.velocity.y = 0; this.onGround = true; 
                                    }
                                } else if (this.velocity.y > 0) {
                                    if (this.playerBox.max.y > wall.box.min.y && this.playerBox.max.y < wall.box.max.y) {
                                        camera.position.y -= (overlapY + 0.001); this.velocity.y = -0.1;
                                    }
                                }
                            }
                        }
                    }
                }

                if (this.wantsToJump) {
                    if (this.onGround) { performJump(); moveStreaks.longAerial.count = 0; moveStreaks.aerial.count = 0; } 
                    else { performWallJump(); }
                }

                // --- X-AXIS COLLISION (Original + OBB Branch) ---
                camera.position.x += this.velocity.x * dt;
                if (!this.isPhasing && spatialGrid) {
                    this.updatePlayerBox();
                    let collisions = spatialGrid.query(this.playerBox);
                    for(const wall of collisions) {
                        if (wall.mesh.userData.obb) {
                            if (wall.mesh.userData.obb.intersectsBox3(this.playerBox, _obbNormal, _obbDepth)) {
                                camera.position.addScaledVector(_obbNormal, _obbDepth.value);
                                const dot = this.velocity.dot(_obbNormal);
                                if (dot < 0) this.velocity.sub(_obbNormal.clone().multiplyScalar(dot));
                                
                                if (!this.onGround && InputManager.keys.c) {
                                    this.isWallSliding = true; const dotTilt = _pTemp.dot(_obbNormal); this.wallSlideTilt = (dotTilt > 0) ? -wallTiltAmount : wallTiltAmount;
                                }
                            }
                        } else if (this.playerBox.intersectsBox(wall.box)) {
                            const overlapX = Math.min(this.playerBox.max.x - wall.box.min.x, wall.box.max.x - this.playerBox.min.x);
                            const overlapY = Math.min(this.playerBox.max.y - wall.box.min.y, wall.box.max.y - this.playerBox.min.y);
                            const overlapZ = Math.min(this.playerBox.max.z - wall.box.min.z, wall.box.max.z - this.playerBox.min.z);
                            if (overlapY > 0.1 && overlapZ > 0 && overlapX < overlapZ) {
                                const wallCenterX = (wall.box.min.x + wall.box.max.x) / 2;
                                if (camera.position.x < wallCenterX) camera.position.x -= overlapX; else camera.position.x += overlapX;
                                this.wallImpactVelocity = Math.abs(this.velocity.x); this.velocity.x = 0;
                                if (!this.onGround && InputManager.keys.c) {
                                    this.isWallSliding = true; const normalX = (camera.position.x < wallCenterX) ? -1 : 1; const dot = _pTemp.x * normalX; this.wallSlideTilt = (dot > 0) ? -wallTiltAmount : wallTiltAmount;
                                }
                            }
                        }
                    }
                }

                // --- Z-AXIS COLLISION (Original + OBB Branch) ---
                camera.position.z += this.velocity.z * dt;
                if (!this.isPhasing && spatialGrid) {
                    this.updatePlayerBox();
                    let collisions = spatialGrid.query(this.playerBox);
                    for(const wall of collisions) {
                        if (wall.mesh.userData.obb) {
                            if (wall.mesh.userData.obb.intersectsBox3(this.playerBox, _obbNormal, _obbDepth)) {
                                camera.position.addScaledVector(_obbNormal, _obbDepth.value);
                                const dot = this.velocity.dot(_obbNormal);
                                if (dot < 0) this.velocity.sub(_obbNormal.clone().multiplyScalar(dot));

                                if (!this.onGround && InputManager.keys.c) {
                                    this.isWallSliding = true; const dotTilt = _pTemp.dot(_obbNormal); this.wallSlideTilt = (dotTilt > 0) ? -wallTiltAmount : wallTiltAmount;
                                }
                            }
                        } else if (this.playerBox.intersectsBox(wall.box)) {
                            const overlapX = Math.min(this.playerBox.max.x - wall.box.min.x, wall.box.max.x - this.playerBox.min.x);
                            const overlapY = Math.min(this.playerBox.max.y - wall.box.min.y, wall.box.max.y - this.playerBox.min.y);
                            const overlapZ = Math.min(this.playerBox.max.z - wall.box.min.z, wall.box.max.z - this.playerBox.min.z);
                            if (overlapY > 0.1 && overlapX > 0 && overlapZ < overlapX) {
                                const wallCenterZ = (wall.box.min.z + wall.box.max.z) / 2;
                                if (camera.position.z < wallCenterZ) camera.position.z -= overlapZ; else camera.position.z += overlapZ;
                                this.wallImpactVelocity = Math.abs(this.velocity.z); this.velocity.z = 0;
                                if (!this.onGround && InputManager.keys.c) {
                                    this.isWallSliding = true; const normalZ = (camera.position.z < wallCenterZ) ? -1 : 1; const dot = _pTemp.z * normalZ; this.wallSlideTilt = (dot > 0) ? -wallTiltAmount : wallTiltAmount;
                                }
                            }
                        }
                    }
                }
            }

            handleHealthRegen(dt) {
                const now = performance.now();
                if (this.isRegenerating) {
                    this.health += CONFIG.regenRate * dt;
                    if (this.health >= CONFIG.playerMaxHP) { 
                        this.health = CONFIG.playerMaxHP;
                        this.isRegenerating = false;
                    }
                } else {
                    if (now - this.lastDamageTime > CONFIG.regenDelay && this.health < CONFIG.playerMaxHP) {
                        this.isRegenerating = true;
                    }
                }
                
                const vignette = document.getElementById('low-health-vignette');
                const healthFill = document.getElementById('health-fill');
                const maxHP = CONFIG.playerMaxHP;
                
                if (this.health < maxHP * 0.5) {
                    if (!healthFill.classList.contains('health-critical')) healthFill.classList.add('health-critical');

                    // Calculate Danger Factor
                    const rawFactor = 1 - (this.health / (maxHP * 0.5));
                    const dangerFactor = Math.pow(rawFactor, 1.2); 
                    
                    // Base opacity: 0.2 to 0.6 based on health
                    let currentOpacity = 0.2 + (dangerFactor * 0.4);
                    
                    // Audio Timing
                    const hbInterval = 1.2 - (dangerFactor * 0.85);
                    const nowSec = now / 1000;
                    
                    if (nowSec - lastHeartbeatTime > hbInterval) {
                        AudioSys.playHeartbeat(dangerFactor); 
                        lastHeartbeatTime = nowSec;
                        // Store the timestamp of this specific beat
                        this.lastPulseStart = now; 
                    }

                    // VISUAL RHYTHM: Variant B (Pulse in Middle)
                    if (this.lastPulseStart) {
                        const timeSinceBeat = now - this.lastPulseStart;
                        
                        // Pulse between the beats (30ms to 150ms)
                        // This bridges the audio gap for a "heavier" feel
                        if (timeSinceBeat > 30 && timeSinceBeat < 150) {
                            currentOpacity = 1.0;
                        }
                    }

                    vignette.style.opacity = currentOpacity.toFixed(2);

                } else {
                    if (healthFill.classList.contains('health-critical')) healthFill.classList.remove('health-critical');
                    vignette.style.opacity = "0";
                }
            }

            handleEnergy(dt) {
                if (this.isSprinting) {
                    this.energy -= CONFIG.energyDrain * dt;
                    if (this.energy < 0) this.energy = 0;
                } else {
                    this.energy += CONFIG.energyRegen * dt;
                    if (this.energy > CONFIG.energyMax) this.energy = CONFIG.energyMax;
                }
            }

            handleTeleport(dt) {
                // --- 1. Implicit Buffer Logic ---
                if (teleportMode === 'AIM') {
                    if (InputManager.mouseDown) {
                        if (!this.lockedTeleportDest) {
                            // Calculate and pin target on first frame of click
                            const result = getTeleportTarget(CONFIG.teleportRange + 5.0);
                            this.lockedTeleportDest = resolveTeleportPosition(result.point, result.normal);
                        }
                    } else if (!this.teleportLocked) {
                        this.lockedTeleportDest = null; // Release buffer unless explicitly locked
                    }
                }

                // --- 2. Visualization & State Management ---
                const isActive = (teleportMode === 'AIM' && (this.teleportActive || this.teleportLocked));

                if (isActive) {
                    // Determine Target
                    if (this.lockedTeleportDest) {
                        this.teleportTarget = this.lockedTeleportDest;
                        if (teleportMarker.parent !== scene) scene.add(teleportMarker);
                        teleportMarker.position.copy(this.lockedTeleportDest);
                        teleportMarker.rotation.set(0, 0, 0);
                    } else {
                        // Live Scan
                        const result = getTeleportTarget(CONFIG.teleportRange + 5.0);
                        const dest = resolveTeleportPosition(result.point, result.normal);
                        this.teleportTarget = dest;

                        // Hybrid Attachment (Stick to camera if target at max range)
                        const forward = new THREE.Vector3();
                        camera.getWorldDirection(forward);
                        const idealDest = camera.position.clone().addScaledVector(forward, CONFIG.teleportRange);

                        if (!result.hit && dest.distanceToSquared(idealDest) < 0.01) {
                            if (teleportMarker.parent !== camera) camera.add(teleportMarker);
                            teleportMarker.position.set(0, 0, -CONFIG.teleportRange);
                            teleportMarker.rotation.set(-camera.rotation.x, 0, 0);
                        } else {
                            if (teleportMarker.parent !== scene) scene.add(teleportMarker);
                            teleportMarker.position.copy(dest);
                            teleportMarker.rotation.set(0, 0, 0);
                        }
                    }
                    
                    teleportMarker.visible = true;

                    // Enemy Highlighting
                    let closestEnemy = null;
                    let closestDist = 999;
                    const checkPos = this.teleportTarget.clone().add(new THREE.Vector3(0, 1, 0));
                    
                    for (const enemy of enemies) {
                        if (enemy.isDeadCorpse) continue;
                        const dist = checkPos.distanceTo(enemy.mesh.position);
                        const threshold = 2.5 + (enemy.type.scale || 1);
                        if (dist < threshold && dist < closestDist) {
                            closestDist = dist;
                            closestEnemy = enemy;
                        }
                    }

                    if (lastHoveredEnemy && lastHoveredEnemy !== closestEnemy) lastHoveredEnemy.setHighlight(false);
                    if (closestEnemy) { 
                        closestEnemy.setHighlight(true); 
                        lastHoveredEnemy = closestEnemy; 
                    } else { 
                        lastHoveredEnemy = null; 
                    }
                    
                    // Marker Animation (Pulse & Color)
                    const t = performance.now();
                    teleportMarker.userData.diamond.rotation.y += dt * 2.0;
                    if (!this.tpAimStartTime) this.tpAimStartTime = performance.now();
                    
                    const cycle = (Math.cos((performance.now() - this.tpAimStartTime) * 0.0015) + 1) / 2;
                    const targetOpacity = 0.3 + (0.7 * cycle);
                    
                    // Interpolate Color (Cyan -> White)
                    const targetColor = new THREE.Color(0x00ffff).lerp(new THREE.Color(0xffffff), cycle);
                    
                    // Apply Visuals
                    materials.marker.opacity = targetOpacity;
                    materials.marker.color.copy(targetColor);
                    materials.marker.emissive.copy(targetColor);
                    materials.marker.emissiveIntensity = this.teleportLocked ? 3.0 : (2.0 * cycle);

                    teleportMarker.userData.ringMat.opacity = targetOpacity;
                    teleportMarker.userData.ringMat.color.copy(targetColor);
                    teleportMarker.userData.ringMat.emissive.copy(targetColor);
                    teleportMarker.userData.ringMat.emissiveIntensity = this.teleportLocked ? 3.0 : (2.0 * cycle);

                    const pulse = Math.sin(t * 0.003); 
                    teleportMarker.userData.diamond.position.y = 1.5 + pulse * 0.2;
                    teleportMarker.userData.ring.scale.setScalar(1 + pulse * 0.05);
                    
                    document.getElementById('icon-q').classList.add('active');

                } else {
                    // Inactive State Cleanup
                    if (teleportMarker.parent === camera) scene.add(teleportMarker);
                    teleportMarker.visible = false;
                    this.tpAimStartTime = 0; 
                    document.getElementById('icon-q').classList.remove('active');
                    if (lastHoveredEnemy) { 
                        lastHoveredEnemy.setHighlight(false); 
                        lastHoveredEnemy = null; 
                    }
                }
                
                // Crosshair State
                const ch = document.getElementById('crosshair');
                ch.style.opacity = (slashActive || isActive) ? 0 : 1;
            }
        }

        const player = new PlayerController();

        const moveStreaks = {
            slide: { count: 0, lastTime: 0 },
            aerial: { count: 0, lastTime: 0 },
            longAerial: { count: 0, lastTime: 0 },
            wall: { count: 0, lastTime: 0 },
            phase: { count: 0, lastTime: 0 }
        };

        let teleportMarker;
        let slashGeometry; 
        let lastAttackTime = 0;
        let currentSlashColor = 0x0088ff;
        
        class Portal {
            constructor(x, y, z, color, targetPortal = null, ws = null) {
                this.mesh = new THREE.Group();
                this.mesh.position.set(x, y + 2.5, z); 
                
                const geo = new THREE.IcosahedronGeometry(1.5, 0);
                const mat = materials.marker.clone();
                mat.color.setHex(color);
                mat.emissive.setHex(color);
                mat.transparent = true;
                mat.opacity = 0.5;
                mat.wireframe = true;
                
                this.inner = new THREE.Mesh(geo, mat);
                this.mesh.add(this.inner);
                
                const outerGeo = new THREE.IcosahedronGeometry(2.0, 0);
                const outerMat = mat.clone();
                outerMat.opacity = 0.2;
                this.outer = new THREE.Mesh(outerGeo, outerMat);
                this.mesh.add(this.outer);

                this.particles = [];
                for(let i=0; i<5; i++) {
                     const p = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({color: 0xffffff}));
                     this.mesh.add(p);
                     this.particles.push({ mesh: p, offset: Math.random() * 10, speed: 0.5 + Math.random() });
                }

                if (ws) {
                    ws.group.add(this.mesh);
                    ws.portals.push(this);
                } else {
                    scene.add(this.mesh);
                    portals.push(this);
                }
                this.target = targetPortal;
                this.color = color;
                this.radius = 2.0;
            }
            
            update(dt) {
                const t = performance.now() * 0.001;
                this.inner.rotation.y = t * 2;
                this.inner.rotation.x = t;
                this.outer.rotation.y = -t;
                this.outer.rotation.z = t * 0.5;
                
                const scale = 1 + Math.sin(t * 3) * 0.1;
                this.inner.scale.setScalar(scale);
                
                this.particles.forEach(p => {
                    const time = t * p.speed + p.offset;
                    p.mesh.position.set(Math.sin(time)*1, Math.cos(time*1.5)*1, Math.sin(time*0.5)*1);
                    p.mesh.scale.setScalar(0.5 + Math.sin(time*5)*0.3);
                });
                
                if(Math.random() < 0.05) {
                     spawnParticles(this.mesh.position, this.color, 2, 2.0);
                }
            }
            
            teleportEntity(pos, vel) {
                if (this.target) {
                    AudioSys.playTeleport(this.mesh.position);
                    spawnParticles(pos.clone(), this.color, 20);
                    pos.copy(this.target.mesh.position);
                    const dir = vel.clone().normalize();
                    if(dir.lengthSq() === 0) dir.set(0,0,1);
                    pos.addScaledVector(dir, 3.0); 
                    spawnParticles(pos.clone(), this.target.color, 20);
                }
            }
        }

        class Projectile {
            constructor(type, pos, vel) {
                this.type = type;
                this.velocity = vel.clone();
                this.radius = 0.2;
                this.stuckTo = null;
                this.life = type === 'VOID' ? 1.5 : (type === 'IMPULSE' ? 10.0 : 3.5);

                const eyePos = camera.position.clone();
                const distToSpawn = eyePos.distanceTo(pos);
                if (distToSpawn > 0.1) {
                    const dirToSpawn = pos.clone().sub(eyePos).normalize();
                    globalRaycaster.set(eyePos, dirToSpawn);
                    globalRaycaster.far = distToSpawn;
                    const hits = globalRaycaster.intersectObjects(worldObjects);
                    
                    if (hits.length > 0) {
                        this.meshPos = hits[0].point.sub(dirToSpawn.multiplyScalar(0.1));
                    } else {
                        this.meshPos = pos.clone();
                    }
                } else {
                    this.meshPos = pos.clone();
                }

                // --- VISUAL SETUP ---
                // Unified Shape: Icosahedron (Sphere-like)
                const geoRadius = (type === 'FRAG') ? 0.45 : 0.25; 
                const geo = new THREE.IcosahedronGeometry(geoRadius, 1);
                // Wireframe slightly larger for the "Tech Shell" look
                const wireGeo = new THREE.IcosahedronGeometry(geoRadius * 1.1, 1);

                let color = 0xff0000; 
                let roughness = 0.4;  
                let metalness = 0.5;
                let emissiveInt = 0.8;
                let opacity = 1.0;

                if (type === 'VOID') {
                    color = 0x220044; // Very dark purple base
                    roughness = 1.0;  // Fully Matte (No shine)
                    metalness = 0.0;  // No reflection
                    emissiveInt = 0;  // No self-glow on the core
                }
                else if (type === 'FRAG') {
                    color = 0xff3300; 
                    roughness = 0.7;
                    emissiveInt = 0.5;
                }
                else if (type === 'IMPULSE') {
                    color = 0x00ffff;
                    roughness = 0.2;
                    emissiveInt = 1.0;
                }

                const mat = new THREE.MeshStandardMaterial({ 
                    color: color, 
                    emissive: color, 
                    emissiveIntensity: emissiveInt, 
                    roughness: roughness,
                    metalness: metalness
                });
                
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.renderOrder = 2;
                
                // Wireframe Shell
                let wireCol = 0xffffff;
                if (type === 'VOID') wireCol = 0x8A2BE2; // Purple wire over dark matte core
                
                const wireMat = new THREE.MeshBasicMaterial({ 
                    color: wireCol, 
                    wireframe: true, 
                    transparent: true, 
                    opacity: (type === 'VOID' ? 0.2 : 0.5) 
                });
                this.wire = new THREE.Mesh(wireGeo, wireMat);
                this.mesh.add(this.wire);
                
                this.mesh.position.copy(this.meshPos);
                scene.add(this.mesh);
                this.active = true;
                this.portalCooldown = 0;
            }

            update(dt) {
                if (!this.active) return;
                this.life -= dt;
                if (this.life < 1.0) this.wire.material.opacity = Math.random() > 0.5 ? 0.8 : 0.2;
                if (this.life <= 0) { this.explode(); return; }
                if (this.portalCooldown > 0) this.portalCooldown -= dt;
                if (this.stuckTo) {
                    if (this.stuckTo.isDeadCorpse || this.stuckTo.health <= 0) this.stuckTo = null;
                    else if(this.stuckTo.mesh) this.mesh.position.copy(this.stuckTo.mesh.position).add(this.stuckOffset);
                    return; 
                }
                this.velocity.y -= CONFIG.gravity * dt;
                _projPos.copy(this.mesh.position).addScaledVector(this.velocity, dt);
                if (this.portalCooldown <= 0) {
                    for(let p of portals) {
                        if(_projPos.distanceTo(p.mesh.position) < 2.0) {
                            p.teleportEntity(_projPos, this.velocity);
                            this.mesh.position.copy(_projPos);
                            this.portalCooldown = 0.5;
                            return; 
                        }
                    }
                }
                _projDir.subVectors(_projPos, this.mesh.position);
                const dist = _projDir.length();
                if (dist > 0.001) {
                    _projDir.normalize();
                    globalRaycaster.set(this.mesh.position, _projDir);
                    globalRaycaster.far = dist;
                    const hits = globalRaycaster.intersectObjects(worldObjects);
                    let enemyHit = null;
                    for(let e of enemies) {
                        if (!e.isDeadCorpse && e.mesh.position.distanceTo(_projPos) < e.type.scale + 0.5) {
                            enemyHit = e; break;
                        }
                    }
                    if (enemyHit) {
                        if (this.type === 'IMPULSE') { this.active = false; this.explode(); return; }
                        if (this.type === 'VOID') { this.stuckTo = enemyHit; this.stuckOffset = new THREE.Vector3(0, 1, 0); return; }
                        if (this.type === 'FRAG') this.velocity.negate().multiplyScalar(0.4);
                    }
                    if (hits.length > 0) {
                        if (this.type === 'IMPULSE') { this.active = false; this.explode(); return; }
                        if (this.type === 'VOID') {
                            this.active = false; this.mesh.position.copy(hits[0].point); this.velocity.set(0,0,0);
                            this.active = true; this.stuckTo = { mesh: { position: hits[0].point }, isDeadCorpse: false, health: 1 };
                            this.stuckOffset = new THREE.Vector3(0,0,0); return;
                        }
                        if (this.type === 'FRAG') {
                            const n = hits[0].face.normal;
                            this.velocity.reflect(n).multiplyScalar(0.5); 
                            if (n.y > 0.5) { this.velocity.x *= 0.6; this.velocity.z *= 0.6; if (this.velocity.y < 0.5) this.velocity.y = 0; }
                            this.mesh.position.copy(hits[0].point).addScaledVector(n, 0.2);
                        }
                    } else this.mesh.position.copy(_projPos);
                } else this.mesh.position.copy(_projPos);

                this.mesh.rotation.x += dt * 10;
                this.mesh.rotation.z += dt * 10;

                // Pooled trail updates
                if (Math.random() < (this.type === 'VOID' ? 0.4 : this.type === 'FRAG' ? 0.3 : 0.2)) {
                    const p = _particlePool[_particleIdx];
                    _particleIdx = (_particleIdx + 1) % 800;
                    p.active = true; p.type = 'static';
                    p.mesh.visible = true; p.mesh.position.copy(this.mesh.position);
                    if (this.type === 'VOID') {
                        p.life = 0.5; p.maxLife = 0.5; p.targetOpacity = 0.6; p.velocity.set(0, 0.5, 0);
                        p.mesh.material.color.setHex(0x110022); p.mesh.material.blending = THREE.NormalBlending;
                    } else if (this.type === 'FRAG') {
                        p.life = 0.4; p.maxLife = 0.4; p.targetOpacity = 0.4; p.velocity.set(0, 0.5, 0);
                        p.mesh.material.color.setHex(0x664422); p.mesh.material.blending = THREE.NormalBlending;
                    } else {
                        p.life = 0.3; p.maxLife = 0.3; p.targetOpacity = 0.3; p.velocity.set(0, 0, 0);
                        p.mesh.material.color.setHex(0x00ffff); p.mesh.material.blending = THREE.AdditiveBlending;
                    }
                    p.mesh.scale.setScalar(0.2 + Math.random() * 0.3);
                }
            }
            
            explode() {
                this.active = false;
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                
                const pos = this.mesh.position.clone();
                let range = 10;
                let damage = 100;
                let force = 20;
                let color = 0x00ff00;

                if (this.type === 'FRAG') { 
                    range = 30; damage = 200; force = 50; color = 0xff3300; 
                    this.spawnExplosion(pos, range);
                } 
                else if (this.type === 'VOID') { 
                    range = 25; damage = 150; force = -70; color = 0x8A2BE2; 
                    this.spawnImplosion(pos, range, color);
                } 
                else if (this.type === 'IMPULSE') { 
                    range = 20; damage = 10; force = 60; color = 0x00ffff; 
                    this.spawnShockwave(pos, range, color);
                }
                
                if(this.type !== 'VOID' && this.type !== 'IMPULSE') {
                    spawnImpact(pos, color, range/2); 
                }
                
                spawnRipple(pos, new THREE.Vector3(0,1,0), color);
                
                // Routed audio logic
                if (this.type === 'IMPULSE') AudioSys.playImpulse(pos);
                else if (this.type === 'VOID') AudioSys.playVoid(pos);
                else AudioSys.playFrag(pos);

                for (let e of enemies) {
                    if (e.isDeadCorpse) continue;
                    const dist = e.mesh.position.distanceTo(pos);
                    
                    if (dist < range) {
                        const falloff = 1 - (dist / range);
                        if (damage > 0) e.takeHit(damage * falloff);
                        const dir = e.mesh.position.clone().sub(pos).normalize();
                        
                        if(this.type === 'VOID') {
                            const pullStrength = (dist / range); 
                            e.velocity.addScaledVector(dir, force * pullStrength); 
                        } else {
                             dir.y = 0.8; dir.normalize(); 
                             e.velocity.addScaledVector(dir, force * falloff);
                        }
                    }
                }
                
                const pDist = camera.position.distanceTo(pos);
                if (pDist < range) {
                     const falloff = 1 - (pDist / range);
                     const dir = camera.position.clone().sub(pos).normalize();
                     
                     if(damage > 0) damagePlayer(damage * 0.1 * falloff);
                     
                     if(this.type === 'VOID') {
                         const pullStrength = (pDist / range);
                         player.velocity.addScaledVector(dir, force * pullStrength * 0.5);
                     } else {
                         player.velocity.addScaledVector(dir, force * falloff);
                     }
                     player.onGround = false; 
                }
            }

            spawnExplosion(pos, range) {
                spawnImpact(pos, 0xff4400, 5.0); 
                for(let i=0; i<16; i++) {
                    const p = _particlePool[_particleIdx];
                    _particleIdx = (_particleIdx + 1) % 800;
                    p.active = true; 
                    p.type = 'static'; 
                    p.life = 0.6 + Math.random() * 0.4; 
                    p.maxLife = 1.0; 
                    p.targetOpacity = 0.6; // Original value

                    p.mesh.visible = true;
                    p.mesh.material.color.setHex(Math.random() > 0.5 ? 0xff2200 : 0x880000);
                    p.mesh.material.blending = THREE.AdditiveBlending; 
                    p.mesh.material.opacity = 0.6;
                    
                    const s = range * (1.0 + Math.random() * 1.0);
                    p.mesh.scale.set(s, s, s);
                    _tempA.set(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(Math.random() * range * 0.6);
                    p.mesh.position.copy(pos).add(_tempA);
                    p.velocity.copy(_tempA).normalize().multiplyScalar(0.8).add(new THREE.Vector3(0, 3.0, 0));
                }
                spawnParticles(pos, 0xff6600, 40, 4.0, 4.0); 
                spawnParticles(pos, 0xaa0000, 30, 2.0, 6.0); 
                spawnRipple(pos, _UP, 0x000000); 
                spawnRipple(pos, _UP, 0xff2200); 
            }

            spawnImplosion(pos, range, color) {
                const group = new THREE.Group();
                group.position.copy(pos);
                scene.add(group);

                // 1. The "Inversion" Core
                // We use CustomBlending with Difference logic to mathematically invert 
                // the colors of whatever is rendered behind this sphere.
                const coreGeo = new THREE.SphereGeometry(range, 32, 32);
                const coreMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 1.0,
                    blending: THREE.CustomBlending,
                    blendEquation: THREE.AddEquation,
                    blendSrc: THREE.OneMinusDstColorFactor,
                    blendDst: THREE.OneMinusSrcColorFactor
                }); 
                const core = new THREE.Mesh(coreGeo, coreMat);
                group.add(core);

                // 2. The Raven Wireframe (Solid, single layer, glowing)
                const wireMat = materials.marker.clone();
                wireMat.color.setHex(color);
                wireMat.emissive.setHex(color);
                wireMat.emissiveIntensity = 2.0;
                wireMat.wireframe = true;
                wireMat.transparent = true;
                wireMat.opacity = 1.0;

                const wireGeo = new THREE.IcosahedronGeometry(range * 1.02, 2);
                const wire = new THREE.Mesh(wireGeo, wireMat);
                group.add(wire);

                // 3. Animation (Restored Original Speed: 0.05)
                let s = 1.0;
                const anim = () => {
                    s -= 0.05; // Fast snap (approx 0.3-0.4s visible life)
                    if (s <= 0) { 
                        scene.remove(group); 
                        coreGeo.dispose(); coreMat.dispose(); 
                        wireGeo.dispose(); wireMat.dispose();
                        return; 
                    }
                    
                    group.scale.set(s, s, s);
                    
                    // Spin
                    wire.rotation.y += 0.08;
                    wire.rotation.z -= 0.03;
                    
                    requestAnimationFrame(anim);
                };
                anim();
            }

            spawnShockwave(pos, range, color) {
                // 1. Impact Flash
                spawnImpact(pos, color, range/2);

                // 2. High Velocity Burst
                spawnParticles(pos, color, 30, 4.0); 

                // 3. Volumetric Air Cushion (Tuned)
                const spawnRing = (delay, opacity, expansionSpeed, fadeRate, yOffset) => {
                    setTimeout(() => {
                        const geo = new THREE.TorusGeometry(1, 0.2, 8, 32); 
                        const mat = new THREE.MeshBasicMaterial({ 
                            color: color, 
                            transparent: true, 
                            opacity: opacity, 
                            depthWrite: false, 
                            blending: THREE.AdditiveBlending 
                        });
                        const ring = new THREE.Mesh(geo, mat);
                        ring.renderOrder = 0;
                        ring.rotation.x = Math.PI / 2; 
                        
                        const ringPos = pos.clone();
                        ringPos.y += yOffset;
                        ring.position.copy(ringPos);
                        
                        scene.add(ring);
                        
                        let s = 1.0;
                        const anim = () => {
                            if (!ring.parent) return; 
                            
                            s += expansionSpeed;
                            
                            if (s > range * 1.5) { 
                                scene.remove(ring); geo.dispose(); mat.dispose(); return; 
                            }
                            
                            ring.scale.set(s, s, s);
                            ring.material.opacity -= fadeRate;
                            
                            if (ring.material.opacity <= 0) {
                                scene.remove(ring); geo.dispose(); mat.dispose(); return; 
                            }
                            
                            requestAnimationFrame(anim);
                        };
                        anim();
                    }, delay);
                };

                // New Base Speed (Original 0.02 * 0.4)
                const speed = (range * 2) * 0.008;

                // 1. MAIN BLAST (Ground Level)
                spawnRing(0, 0.3, speed, 0.08, 0);

                // 2. ECHO 1 (Mid-Air)
                spawnRing(100, 0.2, speed, 0.02, 1.0);

                // 3. ECHO 2 (Upper Dissipation)
                spawnRing(200, 0.1, speed, 0.01, 2.0);
            }
        }

        class Katana {
            constructor(owner) {
                this.owner = owner;
            }

            update(dt) { }

            use() {
                const now = performance.now();
                if (now - lastAttackTime < CONFIG.attackCooldown) return;
                lastAttackTime = now;

                const COMBO_WINDOW = 1000; 
                const STREAK_WINDOW = 1500; 

                let activeStreakCount = 0;
                const recentSlide = (now - player.lastSlideTime < COMBO_WINDOW) || player.isSliding;
                const recentTeleport = (now - player.lastTeleportTime < COMBO_WINDOW);
                const recentWallJump = (now - player.lastWallJumpTime < COMBO_WINDOW);
                const isAerial = !player.onGround;

                const getStreak = (key) => (now - moveStreaks[key].lastTime < STREAK_WINDOW) ? moveStreaks[key].count : 0;

                if(recentSlide) activeStreakCount += getStreak('slide');
                if(isAerial) {
                    const airDuration = (now - player.airTimeStart) / 1000;
                    if(airDuration > 0.8) activeStreakCount += getStreak('longAerial');
                    else activeStreakCount += getStreak('aerial');
                }
                if(recentTeleport) activeStreakCount += getStreak('phase');
                if(recentWallJump) activeStreakCount += getStreak('wall');

                AudioSys.playSlash();
                const slashMesh = spawnSlash(camera);
                
                const rng = Math.random();
                const missChance = 1/50; 
                const grazeChance = 1/24; 
                const baseCritChance = 1/36; 
                const critBonus = activeStreakCount * 0.01; 
                
                let hitType = "NORMAL";
                let dmgMult = 1.0;
                
                if (rng < missChance) {
                    hitType = "MISS";
                    dmgMult = 0;
                } else if (rng < missChance + grazeChance) {
                    hitType = "GRAZE";
                    dmgMult = 0.5;
                } else if (rng < missChance + grazeChance + baseCritChance + critBonus) {
                    hitType = "CRIT";
                    dmgMult = 3.0;
                }
                
                if (hitType === "MISS") {
                     AudioSys.playMiss();
                     showKillMessage("MISS", "graze");
                     return; 
                }

                const uniqueHitEnemies = new Set();
                const camDir = new THREE.Vector3();
                camera.getWorldDirection(camDir);

                globalRaycaster.setFromCamera(new THREE.Vector2(0, 0), camera); 
                globalRaycaster.far = CONFIG.attackRange;
                
                const hitObjects = [];
                enemies.forEach(e => { 
                    if (!e.isDeadCorpse) e.mesh.traverse(c => hitObjects.push(c)); 
                });
                
                const hitIntersects = globalRaycaster.intersectObjects(hitObjects);
                hitIntersects.forEach(hit => {
                    let hitObj = hit.object;
                    while(hitObj.parent && !enemies.some(e => e.mesh === hitObj)) {
                        hitObj = hitObj.parent;
                    }
                    const enemy = enemies.find(e => e.mesh === hitObj);
                    if(enemy) uniqueHitEnemies.add(enemy);
                });

                enemies.forEach(e => {
                    if(e.isDeadCorpse) return;
                    const toEnemy = e.mesh.position.clone().sub(camera.position);
                    const dist = toEnemy.length();
                    if (dist < CONFIG.attackRange) {
                        toEnemy.normalize();
                        const angle = camDir.angleTo(toEnemy);
                        if (angle < 0.5) { 
                            uniqueHitEnemies.add(e);
                        }
                    }
                });

                if (uniqueHitEnemies.size > 0) {
                    player.totalHits += uniqueHitEnemies.size; 

                    const hitCount = uniqueHitEnemies.size;
                    if (hitCount >= 10) GameStats.addAchievement("SLAUGHTERHOUSE", "#ff0000", "PERSISTENT");
                    else if (hitCount >= 5) GameStats.addAchievement("CROWD CONTROL", "#ff8800", "PERSISTENT");
                    else if (hitCount >= 3) GameStats.addAchievement("TRIPLE THREAT", "#ffff00", "FEED_ONLY"); 

                    let hitScore = 10;
                    let addedScore = 0;
                    let comboNames = [];

                    function updateStreak(type, baseBonus) {
                        if (now - moveStreaks[type].lastTime < STREAK_WINDOW) {
                            moveStreaks[type].count++;
                        } else {
                            moveStreaks[type].count = 0;
                        }
                        moveStreaks[type].lastTime = now;
                        return baseBonus + moveStreaks[type].count;
                    }

                    if (recentSlide) {
                        const bonus = updateStreak('slide', 25);
                        addedScore += bonus;
                        comboNames.push("SLIDE");
                        GameStats.moves.slideHit++;
                        GameStats.checkMoveMilestone('slideHit', "SLIDE", "#00ffff");
                    }
                    
                    const isGroundTeleport = recentTeleport && !player.lastTeleportWasAerial;
                    
                    if (!player.onGround && !isGroundTeleport) {
                         const airDuration = (now - player.airTimeStart) / 1000;
                         if (airDuration > 0.8) {
                            const extraTicks = Math.floor((airDuration - 0.8) / 0.2); 
                            const longAirBonus = 50 + (extraTicks * 10);
                            addedScore += longAirBonus;
                            comboNames.push("LONG AERIAL");
                            GameStats.moves.longAirHit++;
                            GameStats.checkMoveMilestone('longAirHit', "SKY ASSASSIN", "#ff00aa");
                         } else {
                            const bonus = updateStreak('aerial', 25);
                            addedScore += bonus;
                            comboNames.push("AERIAL");
                            GameStats.moves.midAirHit++;
                            GameStats.checkMoveMilestone('midAirHit', "AERIAL", "#ff00aa");
                         }
                    }
                    
                    if (recentTeleport) {
                         let base = 0;
                         if (!player.hasPhaseStruck) {
                             base = 50;
                             player.hasPhaseStruck = true; 
                         }
                         const bonus = updateStreak('phase', base);
                         addedScore += bonus;
                         comboNames.push("TELEPORT");
                         GameStats.moves.teleportHit++;
                         GameStats.checkMoveMilestone('teleportHit', "VOID WALKER", "#aa00ff");
                    }

                    if (recentWallJump) {
                        const bonus = updateStreak('wall', 30);
                        addedScore += bonus;
                        comboNames.push("WALL");
                        GameStats.moves.wallJumpHit++;
                        GameStats.checkMoveMilestone('wallJumpHit', "WALL RUNNER", "#00ffaa");
                    }
                    
                    hitScore += addedScore;
                    
                    if (comboNames.length > 0) {
                        let totalStreak = 0;
                        for(let k in moveStreaks) {
                            if(now - moveStreaks[k].lastTime < STREAK_WINDOW) totalStreak += moveStreaks[k].count;
                        }
                        
                        let streakColor = "#" + new THREE.Color(currentSlashColor).getHexString();
                        if (currentTheme === 0) streakColor = "#001133"; 
                        if (currentTheme === 1) streakColor = "#00ffff"; 
                        
                        let msg = comboNames.join(" ") + " +" + addedScore;
                        if(totalStreak > 0) {
                             msg += ` <span class="slick-streak" style="color:${streakColor}">+${totalStreak}</span>`;
                        }
                        showKillMessage(msg, "combo");
                    }
                    
                    if(hitType === "CRIT") {
                         showKillMessage("CRITICAL HIT!", "critical");
                         spawnParticles(camera.position.clone().add(new THREE.Vector3(0,0,-2)), 0xff0000, 15);
                         AudioSys.playHit(h.enemy.mesh.position); 
                    } else if(hitType === "GRAZE") {
                         showKillMessage("GRAZE", "graze");
                    }

                    comboCount += uniqueHitEnemies.size;
                    
                    let isAoEKnockback = false;
                    const s = comboCount.toString();
                    if (comboCount >= 100) {
                        if (comboCount % 100 === 0) isAoEKnockback = true;
                        else if (/^(\d)\1+$/.test(s) || "123456789".includes(s) || "987654321".includes(s)) isAoEKnockback = true;
                    }
                    
                    if (isAoEKnockback) {
                        showKillMessage("SHOCKWAVE!", "critical", "#00ffff");
                    }

                    const hitList = Array.from(uniqueHitEnemies).map(e => ({
                        enemy: e,
                        dist: e.mesh.position.distanceTo(camera.position)
                    }));
                    hitList.sort((a, b) => a.dist - b.dist);

                    hitList.forEach((h, index) => {
                        if (h.enemy.state === 'CONFUSED') {
                            GameStats.addAchievement("NO REST FOR THE WICKED", "#aa00ff", "PERSISTENT"); 
                        }
                        const distancePenalty = Math.max(0.1, 1.0 - (index * 0.1));
                        addScore(hitScore); 
                        
                        const finalDamage = CONFIG.playerDamage * distancePenalty * dmgMult;
                        
                        if (hitType === "CRIT" || isAoEKnockback) {
                            const knockDir = h.enemy.mesh.position.clone().sub(camera.position).normalize();
                            knockDir.y = 0.5; 
                            
                            let force = 15;
                            if(isAoEKnockback) force = 30 * (1.0 - (h.dist / CONFIG.attackRange)); 
                            
                            h.enemy.velocity.addScaledVector(knockDir, force);
                            
                            if (h.enemy.state !== 'CONFUSED' && (Math.random() < 0.2 || isAoEKnockback)) {
                                h.enemy.state = 'CONFUSED';
                                h.enemy.confusedTimer = 2.0;
                                h.enemy.mesh.rotation.x = -Math.PI/2; 
                            }
                        }

                        h.enemy.takeHit(finalDamage);
                        
                        const pColor = hitType === "CRIT" ? 0xff0000 : 0x00ffff;
                        
                        spawnParticles(h.enemy.mesh.position, pColor, 15, 1.5);
                        spawnImpact(h.enemy.mesh.position, pColor, hitType === "CRIT" ? 3.0 : 1.5);
                        
                        if (hitType === "CRIT") {
                            const toCam = camera.position.clone().sub(h.enemy.mesh.position).normalize();
                            spawnRipple(h.enemy.mesh.position, toCam, pColor);
                        }
                    });
                    
                    AudioSys.playHit();
                    comboTimer = 3.0; 
                    updateComboUI();

                    if(slashMesh) {
                        slashMesh.material.color.setHex(hitType === "CRIT" ? 0xff0000 : 0xffffff); 
                        slashMesh.material.opacity = 1; 
                        slashMesh.scale.setScalar(1.2); 
                        slashMesh.userData.fadeSpeed = 0.06; 
                        slashMesh.userData.isHit = true; 
                    }
                }
            }
        }

        function createGridTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            if (type === 'solid') {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, 1024, 1024);
            } else if (type === 'snow') {
                ctx.fillStyle = '#ffffff'; 
                ctx.fillRect(0,0,1024,1024);
                ctx.strokeStyle = 'rgba(200, 220, 255, 0.2)'; 
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let i=0; i<=1024; i+=128) {
                    ctx.moveTo(i,0); ctx.lineTo(i,1024);
                    ctx.moveTo(0,i); ctx.lineTo(1024,i);
                }
                ctx.stroke();
            } else if (type === 'neon') {
                ctx.fillStyle = '#000000'; 
                ctx.fillRect(0,0,1024,1024);
                ctx.strokeStyle = '#00ffff'; 
                ctx.lineWidth = 2;
                ctx.shadowBlur = 4;
                ctx.shadowColor = '#00ffff';
                ctx.beginPath();
                for(let i=0; i<=1024; i+=128) {
                    ctx.moveTo(i,0); ctx.lineTo(i,1024);
                    ctx.moveTo(0,i); ctx.lineTo(1024,i);
                }
                ctx.stroke();
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.beginPath();
                for(let i=0; i<=1024; i+=32) {
                    if(i % 128 === 0) continue;
                    ctx.moveTo(i,0); ctx.lineTo(i,1024);
                    ctx.moveTo(0,i); ctx.lineTo(1024,i);
                }
                ctx.stroke();
            } else {
                ctx.fillStyle = '#050505';
                ctx.fillRect(0, 0, 1024, 1024);
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 4;
                ctx.beginPath();
                for(let i=0; i<=1024; i+=128) {
                    ctx.moveTo(i,0); ctx.lineTo(i,1024);
                    ctx.moveTo(0,i); ctx.lineTo(1024,i);
                }
                ctx.stroke();
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.beginPath();
                for(let i=0; i<=1024; i+=32) {
                    if(i % 128 === 0) continue;
                    ctx.moveTo(i,0); ctx.lineTo(i,1024);
                    ctx.moveTo(0,i); ctx.lineTo(1024,i);
                }
                ctx.stroke();
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.minFilter = THREE.LinearMipMapLinearFilter;
            tex.anisotropy = 16;
            return tex;
        }

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.4, 'rgba(255,255,255,0.5)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,64,64);
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        function init() {
            lastUnlockTime = performance.now() - 5000;

            const btn = document.getElementById('start-btn');
            btn.addEventListener('click', () => {
                AudioSys.init(); 
                const now = performance.now();
                if (now - lastUnlockTime < 1300) {
                    btn.innerText = "b r e a t h e";
                    btn.style.opacity = 0.5;
                    btn.style.letterSpacing = "8px";
                    setTimeout(() => {
                        btn.innerText = "ENTER ARENA";
                        btn.style.opacity = 1;
                        btn.style.letterSpacing = "2px";
                    }, 800);
                    return;
                }
                sessionStartTime = Date.now();
                document.body.requestPointerLock().catch(e => {
                    console.warn("Pointer lock failed:", e);
                });
            });
            
            document.getElementById('theme-btn').addEventListener('click', toggleTheme);
            document.getElementById('tp-mode-btn').addEventListener('click', toggleTeleportMode);
            
            // --- SETTINGS LOGIC ---
            const modal = document.getElementById('settings-modal');
            
            const toggleModal = () => {
                const isHidden = modal.style.display === 'none' || modal.style.display === '';
                modal.style.display = isHidden ? 'flex' : 'none';
                if(isHidden) AudioSys.playUI(true);
            };

            document.getElementById('settings-btn').addEventListener('click', toggleModal);
            document.getElementById('settings-close').addEventListener('click', toggleModal);
            
            // --- ESC KEY HANDLER (State Managed) ---
            let escHandledInKeyDown = false; // Flag to prevent double-action

            // 1. KEYDOWN: Handle Menu Closing
            document.addEventListener('keydown', (e) => {
                if (e.key === "Escape") {
                    if (modal.style.display === 'flex') {
                        modal.style.display = 'none';
                        escHandledInKeyDown = true; // Signal that we used this key press
                        e.stopPropagation(); 
                    } else {
                        escHandledInKeyDown = false;
                    }
                }
            });

            // 2. KEYUP: Handle Game Resume
            document.addEventListener('keyup', (e) => {
                if (e.key === "Escape") {
                    // If we just used this key press to close the menu, do NOT resume
                    if (escHandledInKeyDown) {
                        escHandledInKeyDown = false; // Reset for next time
                        return;
                    }

                    // Otherwise, Resume Game
                    if (modal.style.display !== 'flex' && !isLocked && !player.isDead && sessionStartTime > 0) {
                        document.getElementById('start-btn').click();
                    }
                }
            });
            
            // FPS Toggle
            document.getElementById('set-fps').addEventListener('change', (e) => {
                showFPS = e.target.checked;
                document.getElementById('fps-display').style.display = showFPS ? "block" : "none";
                AudioSys.playUI(true);
            });

            // Wall Tilt Toggle & Slider
            const tiltRow = document.getElementById('tilt-slider-row');
            document.getElementById('set-tilt').addEventListener('change', (e) => {
                enableWallTilt = e.target.checked;
                tiltRow.style.display = enableWallTilt ? 'flex' : 'none';
                AudioSys.playUI(true);
            });

            document.getElementById('set-tilt-amt').addEventListener('input', (e) => {
                wallTiltAmount = parseFloat(e.target.value);
            });

            // Brightness
            document.getElementById('set-bright').addEventListener('input', (e) => {
                brightnessMultiplier = parseFloat(e.target.value);
                applyTheme(); 
            });

            // Master Volume
            document.getElementById('set-vol').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                AudioSys.setVolume(val * 3.0);
            });

            // "Traps" Logic
            const triggerTrap = (e) => {
                e.preventDefault(); 
                const el = e.currentTarget;
                el.classList.add('shake-blow');
                AudioSys.playZap();
                
                const rect = el.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;
                const colors = ['#00ffff', '#ffff00', '#ffffff', '#ff0055'];

                for(let i=0; i<12; i++) {
                    const s = document.createElement('div');
                    s.className = 'ui-spark';
                    s.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    document.body.appendChild(s);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 40 + Math.random() * 50;
                    const tx = Math.cos(angle) * dist + 'px';
                    const ty = Math.sin(angle) * dist + 'px';
                    const rot = (Math.random() * 360) + 'deg';
                    
                    s.style.left = cx + 'px'; 
                    s.style.top = cy + 'px';
                    s.style.setProperty('--tx', tx);
                    s.style.setProperty('--ty', ty);
                    s.style.setProperty('--r', rot);
                    
                    setTimeout(() => s.remove(), 400);
                }
                setTimeout(() => el.classList.remove('shake-blow'), 400);
            };

            document.getElementById('trap-god').addEventListener('click', triggerTrap);
            document.getElementById('trap-music').addEventListener('click', triggerTrap);

            document.getElementById('world-btn').addEventListener('click', () => {
                const order = ['GYM', 'ARENA', 'TITAN', 'MAZE', 'LABYRINTH'];
                const currentName = WorldManager.current ? WorldManager.current.name : 'ARENA';
                let idx = order.indexOf(currentName);
                if (idx === -1) idx = 0;
                const next = order[(idx + 1) % order.length];
                WorldManager.switch(next);
            });

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ'; 
            camera.position.set(0, 2, 0);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0 * brightnessMultiplier; 
            document.body.appendChild(renderer.domElement);

            textures.gridDefault = createGridTexture('default');
            textures.gridSnow = createGridTexture('snow');
            textures.gridNeon = createGridTexture('neon');
            textures.solid = createGridTexture('solid');
            textures.glow = createGlowTexture();
            
            sharedSnowGeo = new THREE.PlaneGeometry(0.1, 0.1);
            sharedLeafGeo = new THREE.PlaneGeometry(0.3, 0.3); 

            // Initialize Materials
            materials.floor = new THREE.MeshPhysicalMaterial({ 
                map: textures.gridDefault, 
                color: 0xffffff, 
                roughness: 0.5, 
                metalness: 0.1,
                transparent: true, 
                opacity: 0.90,
                depthWrite: false 
            });
            
            materials.wall = new THREE.MeshPhysicalMaterial({ 
                color: 0xeeeeee, 
                roughness: 0.1, 
                metalness: 0.1,
                transparent: true, 
                opacity: 0.5,      
                emissive: 0xffffff,       
                emissiveIntensity: 1,
                depthWrite: false 
            });
            materials.obstacle = new THREE.MeshPhysicalMaterial({ 
                color: 0xcccccc, roughness: 0.3, clearcoat: 0.5, clearcoatRoughness: 0.1
            });
            materials.slash = new THREE.MeshBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0, side: THREE.DoubleSide, depthTest: false });
            materials.marker = new THREE.MeshStandardMaterial({ 
                color: 0x0088ff, emissive: 0x0088ff, emissiveIntensity: 2.0, transparent: true, opacity: 0.9, roughness: 0.2, metalness: 0.8, wireframe: true 
            });
            materials.markerCore = new THREE.MeshBasicMaterial({
                color: 0x0088ff, transparent: true, opacity: 0.3, blending: THREE.AdditiveBlending
            });

            setupLighting();
            
            // Build Worlds & Load Normal Map
            WorldManager.init();
            WorldManager.switch('GYM');
            
            createSlashEffect(); 
            createTeleportMarker();
            initObjectPools(); // Pre-allocate memory pools
            InputManager.init();
            NarrativeSys.init();
            player.init();
            Minimap.init();
            renderStatsContent();

            window.addEventListener('resize', onWindowResize);
            
            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === document.body;
                const screen = document.getElementById('start-screen');
                
                if (isLocked) {
                    screen.style.display = 'none';
                    if (breakStartTime > 0) {
                        totalBreakTime += (performance.now() - breakStartTime);
                        if (bankedActiveTime > 0) breakCount++;
                        breakStartTime = 0;
                    }
                    segmentStartTime = performance.now();
                    if(player.isDead) resetGame();
                } else {
                    lastUnlockTime = performance.now();
                    screen.style.display = 'flex';
                    AudioSys.stopAll();
                    if (segmentStartTime > 0) {
                        lastSegmentDuration = performance.now() - segmentStartTime;
                        bankedActiveTime += lastSegmentDuration;
                        segmentStartTime = 0;
                    }
                    breakStartTime = performance.now();
                    updatePauseScreenStats();
                    InputManager.mouseDown = false; 
                }
            });
            
            document.addEventListener('pointerlockerror', (e) => {
                console.warn("Pointer lock error detected.", e);
                if(!isLocked) {
                    document.getElementById('start-screen').style.display = 'flex';
                }
            });

            applyTheme();
            animate();
        }

        function generatePlayerTitle() {
            const m = GameStats.moves;
            const c = GameStats.highestCombo;
            const totalStyle = m.slideHit + m.midAirHit + m.teleportHit + m.wallJumpHit + m.longAirHit;
            
            let archetype = "HYBRID";
            let maxStat = 0;
            if (m.slideHit > maxStat) { maxStat = m.slideHit; archetype = "SLIDER"; }
            if (m.midAirHit + m.longAirHit > maxStat) { maxStat = m.midAirHit + m.longAirHit; archetype = "AVIATOR"; }
            if (m.wallJumpHit > maxStat) { maxStat = m.wallJumpHit; archetype = "TRACEUR"; }
            if (m.teleportHit > maxStat) { maxStat = m.teleportHit; archetype = "SHIFTER"; }
            if (totalStyle > 0 && maxStat / totalStyle < 0.4) archetype = "HYBRID";

            const prestigeScore = totalStyle + (GameStats.botKills * 10);
            let rankIndex = Math.floor(prestigeScore / 50); 
            if (rankIndex > 9) rankIndex = 9;
            const styleTitle = STYLE_ARCHETYPES[archetype][rankIndex] || "NOVICE";

            let comboTitle = "";
            for (let i = COMBO_TITLES_MATRIX.length - 1; i >= 0; i--) {
                if (c >= COMBO_TITLES_MATRIX[i].c) {
                    comboTitle = COMBO_TITLES_MATRIX[i].t;
                    break;
                }
            }
            return (comboTitle ? comboTitle + " " : "") + styleTitle;
        }

        function renderStatsContent() {
            const rawList = GameStats.persistentAchievements;
            const filteredList = [];
            const typeCounts = {};
            const getAchType = (name) => name.replace(/ (NOVICE|APPRENTICE|ADEPT|EXPERT|MASTER|GRANDMASTER|LEGEND|DEMIGOD|GODLIKE|OMNIPOTENT)$/, '');

            for(let i = rawList.length - 1; i >= 0; i--) {
                const name = rawList[i];
                const type = getAchType(name);
                if (type !== name) { 
                    if (!typeCounts[type]) typeCounts[type] = 0;
                    if (typeCounts[type] < 3) { filteredList.push(name); typeCounts[type]++; }
                } else { filteredList.push(name); }
            }
            filteredList.reverse();

            let achHtml = "";
            if (filteredList.length > 0) {
                achHtml = `<div class="achievement-list">` + 
                    filteredList.map(a => `<span class="achievement-tag">${a}</span>`).join('') + 
                    `</div>`;
            }

            const statSession = document.getElementById('stat-session');
            if (statSession) {
                statSession.innerHTML = `
                    <div style="flex: 0 0 auto; margin-bottom: 2px;">
                        <strong>SCORE:</strong> ${player.score}<br>
                        <strong>MAX COMBO:</strong> ${GameStats.highestCombo}
                    </div>
                    <div style="flex: 0 0 auto; margin-bottom: 2px;"><strong>ACHIEVEMENTS:</strong></div>
                    ${achHtml}
                `;
            }

            const statMoves = document.getElementById('stat-moves');
            if (statMoves) {
                let movesHtml = `<strong>KILLS:</strong> ${GameStats.botKills}<br>`;
                if(GameStats.moves.slideHit > 0) movesHtml += `Slide Strikes: ${GameStats.moves.slideHit}<br>`;
                if(GameStats.moves.midAirHit > 0) movesHtml += `Aerial Strikes: ${GameStats.moves.midAirHit}<br>`;
                if(GameStats.moves.longAirHit > 0) movesHtml += `Long Air Strikes: ${GameStats.moves.longAirHit}<br>`;
                if(GameStats.moves.teleportHit > 0) movesHtml += `Teleport Strikes: ${GameStats.moves.teleportHit}<br>`;
                if(GameStats.moves.wallJumpHit > 0) movesHtml += `Wall Jump Strikes: ${GameStats.moves.wallJumpHit}<br>`;
                if(movesHtml === `<strong>KILLS:</strong> ${GameStats.botKills}<br>`) movesHtml += "";
                statMoves.innerHTML = movesHtml;
            }
        }

        function updatePauseScreenStats() {
            const h1 = document.getElementById('game-title');
            const timerDisplay = document.getElementById('session-timer');
            const playerTitleDisplay = document.getElementById('player-title-display');
            
            if(player.isDead) {
                let termStatus = "DISCONNECTED";
                let color = "#ff3333";
                for(let i=SCORE_STEPS.length-1; i>=0; i--) {
                    if (player.score >= SCORE_STEPS[i]) { termStatus = SCORE_TITLES[i]; break; }
                }
                if (player.score > 850000) color = "#aa00ff";
                else if (player.score > 250000) color = "#00ffff";
                else if (player.score > 50000) color = "#ffff00";
                else if (player.score > 10000) color = "#ff8800";
                
                h1.innerText = termStatus;
                h1.style.color = color;
                h1.style.textShadow = `4px 4px 0px ${color}44`;
                
                playerTitleDisplay.innerText = generatePlayerTitle();
                playerTitleDisplay.style.display = "block";
                timerDisplay.style.display = "block";
            } else {
                h1.innerText = "PAUSED";
                h1.style.color = "#33ccff";
                h1.style.textShadow = "4px 4px 0px #33ccff";
                playerTitleDisplay.style.display = "none";
                timerDisplay.style.display = "block";
            }

            const format = (ms) => {
                const totalSec = Math.floor(ms / 1000);
                const s = (totalSec % 60).toString().padStart(2, '0');
                const totalMin = Math.floor(totalSec / 60);
                const m = (totalMin % 60).toString().padStart(2, '0');
                const totalHour = Math.floor(totalMin / 60);
                const h = (totalHour % 24).toString().padStart(2, '0');
                const d = Math.floor(totalHour / 24);

                if (d > 0) return `${d}:${h}:${m}:${s}`;
                if (totalHour > 0) return `${h}:${m}:${s}`;
                return `${m}:${s}`;
            };

            const primaryLabel = player.isDead ? "Playtime" : "Current Session";
            const primaryValue = player.isDead ? bankedActiveTime : lastSegmentDuration;
            const hoverLabel = player.isDead ? "Final Session" : "Playtime";
            const hoverValue = player.isDead ? lastSegmentDuration : bankedActiveTime;

            timerDisplay.innerHTML = `<strong>${primaryLabel}:</strong> ${format(primaryValue)}`;
            
            const tooltip = 
                `${hoverLabel}: ${format(hoverValue)}\n` +
                `Idle: ${format(totalBreakTime)}\n` +
                `Breaks: ${breakCount}`;
            
            timerDisplay.setAttribute('data-details', tooltip);
            timerDisplay.classList.add('session-info');
            renderStatsContent(); 
        }

        let ambientLight, hemiLight, dirLight;

        function setupLighting() {
            ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 50, 0);
            scene.add(hemiLight);
            
            dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(80, 120, 80);
            dirLight.castShadow = true;
            dirLight.shadow.bias = -0.0001;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.left = -200;
            dirLight.shadow.camera.right = 200;
            dirLight.shadow.camera.top = 200;
            dirLight.shadow.camera.bottom = -200;
            scene.add(dirLight);
        }

        function toggleTheme() {
            currentTheme = (currentTheme + 1) % 4;
            applyTheme();
        }

        function toggleTeleportMode() {
            if (teleportMode === 'AIM') {
                teleportMode = 'INSTANT';
                player.tpAimStartTime = 0;
            } else {
                teleportMode = 'AIM';
            }
            document.getElementById('tp-mode-btn').innerText = "TP MODE: " + teleportMode;
            document.getElementById('tp-label').innerText = teleportMode;
        }

        function applyTheme() {
            const body = document.body;
            const ui = document.getElementById('ui-layer');
            const crosshair = document.getElementById('crosshair');
            const names = ["LIGHT", "DARK", "NEON", "HALLOWEEN"];
            
            document.getElementById('theme-btn').innerText = "THEME: " + names[currentTheme];
            document.getElementById('mode-display').innerText = names[currentTheme] + " | 'T' TO CYCLE";

            materials.floor.roughness = 0.5;
            materials.floor.metalness = 0.1;
            materials.floor.emissiveIntensity = 0;
            materials.floor.emissiveMap = null;
            materials.wall.emissiveIntensity = 0;
            materials.wall.emissiveMap = null;

            // --- Theme Specifics with Brightness Multiplier ---
            const b = brightnessMultiplier; // Short alias

            if (currentTheme === 0) { // LIGHT (SNOW)
                const bgCol = 0x667788; 
                scene.background = new THREE.Color(bgCol);
                // Respect World Fog Density
                scene.fog = new THREE.FogExp2(bgCol, WorldManager.current ? WorldManager.current.config.fog : 0.004); 
                body.style.backgroundColor = "#667788";
                ui.classList.add('light-theme');
                
                materials.floor.map = textures.gridSnow;
                // Adjust UVs based on world scale? For now stick to generic
                materials.floor.map.repeat.set(100, 100); 
                materials.floor.color.setHex(0x556677); 
                materials.floor.roughness = 0.9;
                materials.wall.color.setHex(0xdddddd);
                materials.wall.roughness = 0.5;
                
                currentSlashColor = 0x0088ff;
                materials.marker.color.setHex(0x003366); 
                crosshair.style.color = "#0088ff";
                
                // Apply Brightness
                ambientLight.intensity = 0.6 * b; 
                hemiLight.intensity = 0.6 * b;
                dirLight.intensity = 0.8 * b; 
                dirLight.color.setHex(0xffffff);

            } else {
                ui.classList.remove('light-theme');
                
                if (currentTheme === 1) { // DARK
                    const bgCol = 0x20242a; 
                    scene.background = new THREE.Color(bgCol);
                    scene.fog = new THREE.FogExp2(bgCol, WorldManager.current ? WorldManager.current.config.fog : 0.007);
                    body.style.backgroundColor = "#20242a";
                    
                    materials.floor.map = textures.solid;
                    materials.floor.color.setHex(0x1a1e26); 
                    materials.floor.roughness = 0.4; 
                    materials.floor.metalness = 0.1;
                    
                    materials.wall.color.setHex(0x3b4252); 
                    materials.wall.roughness = 1.0;
                    materials.wall.metalness = 0.0;
                    
                    currentSlashColor = 0xffaa00; 
                    materials.marker.color.setHex(0xff8800);
                    crosshair.style.color = "#ffaa00";
                    
                    ambientLight.intensity = 2.2 * b; 
                    hemiLight.intensity = 1.2 * b;
                    dirLight.intensity = 1.5 * b;
                    dirLight.color.setHex(0xddddff);

                } else if (currentTheme === 2) { // NEON
                    const bgCol = 0x050505;
                    scene.background = new THREE.Color(bgCol);
                    scene.fog = new THREE.FogExp2(bgCol, WorldManager.current ? WorldManager.current.config.fog : 0.007);
                    body.style.backgroundColor = "#050505";
                    
                    materials.floor.map = textures.gridDefault;
                    materials.floor.map.repeat.set(100, 100);
                    materials.floor.color.setHex(0x444444);
                    materials.floor.roughness = 0.5; 
                    
                    materials.wall.color.setHex(0x001122); 
                    
                    currentSlashColor = 0x00ffff; 
                    materials.marker.color.setHex(0x00ffff);
                    crosshair.style.color = "#00ffff";
                    
                    ambientLight.intensity = 1.2 * b;
                    hemiLight.intensity = 0.8 * b;
                    dirLight.intensity = 1.2 * b;
                    dirLight.color.setHex(0x00ffff);

                } else { // HALLOWEEN
                    const bgCol = 0x663311;
                    scene.background = new THREE.Color(bgCol); 
                    scene.fog = new THREE.FogExp2(bgCol, WorldManager.current ? WorldManager.current.config.fog : 0.004);
                    body.style.backgroundColor = "#663311";
                    
                    materials.floor.map = textures.solid;
                    materials.floor.color.setHex(0x3d1f00); 
                    materials.floor.roughness = 0.4; 
                    materials.floor.metalness = 0.1;
                    
                    materials.wall.color.setHex(0x7a3e00); 
                    materials.wall.roughness = 1.0;
                    
                    currentSlashColor = 0xff8800; 
                    materials.marker.color.setHex(0xff4400);
                    crosshair.style.color = "#ff8800";
                    
                    ambientLight.intensity = 2.0 * b; 
                    hemiLight.intensity = 1.2 * b;
                    dirLight.intensity = 1.5 * b;
                    dirLight.color.setHex(0xffaa00);
                }
            }
            
            if(materials.slash) materials.slash.color.setHex(currentSlashColor);
            
            decorations.forEach(d => d.updateTheme(currentTheme));
            enemies.forEach(e => e.updateTheme(currentTheme));
        }

        const GIFT_PALETTES = [
            { box: 0xcc0000, ribbon: 0xffd700 }, 
            { box: 0x006400, ribbon: 0xcc0000 }, 
            { box: 0x0044aa, ribbon: 0xc0c0c0 }, 
            { box: 0xffffff, ribbon: 0xcc0000 }, 
            { box: 0x663399, ribbon: 0xffd700 }  
        ];
        const WARM_PALETTES = [0x8B4513, 0xA0522D, 0xCD853F, 0xD2691E, 0xBC8F8F];

        class Decoration {
            constructor(x, y, z, scale, ws = null) {
                this.scale = scale;
                const size = 2;
                this.palette = GIFT_PALETTES[Math.floor(Math.random() * GIFT_PALETTES.length)];
                this.warmColor = WARM_PALETTES[Math.floor(Math.random() * WARM_PALETTES.length)];

                const colliderGeo = new THREE.BoxGeometry(size, size, size);
                const colliderMat = new THREE.MeshBasicMaterial({ visible: false });
                this.colliderMesh = new THREE.Mesh(colliderGeo, colliderMat);
                
                // NEW: Use explicit Y. If null, default to floor (which is just 'scale' due to origin offset)
                const finalY = (y !== null && y !== undefined) ? y : scale;
                this.colliderMesh.position.set(x, finalY, z);
                
                this.colliderMesh.scale.setScalar(scale);
                this.colliderMesh.geometry.computeBoundingBox();
                
                if (ws) {
                    ws.walls.push(this.colliderMesh);
                    ws.group.add(this.colliderMesh);
                } else {
                    walls.push(this.colliderMesh);
                    scene.add(this.colliderMesh);
                }
                
                this.colliderMesh.updateMatrixWorld(true);
                const box = this.colliderMesh.geometry.boundingBox.clone();
                box.applyMatrix4(this.colliderMesh.matrixWorld);
                if (ws) ws.spatialGrid.insert(this.colliderMesh, box);
                else spatialGrid.insert(this.colliderMesh, box);

                const visualGeo = new THREE.BoxGeometry(size, size, size);
                this.mat = materials.obstacle.clone();
                this.visualMesh = new THREE.Mesh(visualGeo, this.mat);
                
                // Shadow Optimization
                if (ws && ws.config.bots > 100) {
                    this.visualMesh.castShadow = false;
                } else {
                    this.visualMesh.castShadow = true;
                }
                
                this.visualMesh.receiveShadow = true;
                this.visualMesh.position.copy(this.colliderMesh.position);
                this.visualMesh.scale.setScalar(scale);
                
                this.visualMesh.updateMatrixWorld();
                if (ws) {
                    ws.worldObjects.push(this.visualMesh);
                    ws.groundObjects.push(this.visualMesh);
                    ws.decorations.push(this);
                    ws.group.add(this.visualMesh);
                } else {
                    worldObjects.push(this.visualMesh);
                    groundObjects.push(this.visualMesh);
                    decorations.push(this);
                    scene.add(this.visualMesh);
                }
                
                const edges = new THREE.EdgesGeometry(visualGeo);
                this.edges = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 }));
                this.visualMesh.add(this.edges);

                this.faceGroup = new THREE.Group();
                const faceMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const eyeGeo = new THREE.ConeGeometry(0.3, 0.1, 3);
                const eyeL = new THREE.Mesh(eyeGeo, faceMat);
                eyeL.position.set(-0.5, 0.2, 1.01); 
                eyeL.rotation.x = -Math.PI/2; eyeL.rotation.z = Math.PI;
                const eyeR = new THREE.Mesh(eyeGeo, faceMat);
                eyeR.position.set(0.5, 0.2, 1.01);
                eyeR.rotation.x = -Math.PI/2; eyeR.rotation.z = Math.PI;
                const mouthGeo = new THREE.BoxGeometry(1.2, 0.3, 0.1);
                const mouth = new THREE.Mesh(mouthGeo, faceMat);
                mouth.position.set(0, -0.5, 1.01);
                this.faceGroup.add(eyeL); this.faceGroup.add(eyeR); this.faceGroup.add(mouth);
                const stemGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 6);
                const stemMat = new THREE.MeshBasicMaterial({ color: 0x006400 });
                this.stem = new THREE.Mesh(stemGeo, stemMat);
                this.stem.position.set(0, 1.2, 0);
                this.faceGroup.add(this.stem);
                this.visualMesh.add(this.faceGroup);

                this.ribbonGroup = new THREE.Group();
                this.ribbonMat = new THREE.MeshBasicMaterial({ color: this.palette.ribbon });
                const r1Geo = new THREE.BoxGeometry(2.05, 2.05, 0.4); 
                const r1 = new THREE.Mesh(r1Geo, this.ribbonMat);
                const r2Geo = new THREE.BoxGeometry(0.4, 2.05, 2.05); 
                const r2 = new THREE.Mesh(r2Geo, this.ribbonMat);
                const bowGeo = new THREE.SphereGeometry(0.4, 8, 8);
                const bow = new THREE.Mesh(bowGeo, this.ribbonMat);
                bow.position.y = 1.025; 
                this.ribbonGroup.add(r1); this.ribbonGroup.add(r2); this.ribbonGroup.add(bow);
                this.ribbonGroup.visible = false;
                this.visualMesh.add(this.ribbonGroup);
            }

            updateTheme(t) {
                this.mat.color.setHex(0xcccccc);
                this.mat.emissive.setHex(0x000000);
                this.mat.wireframe = false;
                this.faceGroup.visible = false;
                this.ribbonGroup.visible = false;
                this.edges.visible = true;
                this.edges.material.opacity = 0.1;
                this.edges.material.color.setHex(0xffffff);
                this.edges.material.linewidth = 1;
                this.visualMesh.rotation.y = 0; 

                if (t === 3) { // Halloween
                    const r = 0.9 + Math.random()*0.1; 
                    const g = 0.05 + Math.random()*0.15; 
                    this.mat.color.setRGB(r, g, 0); 
                    this.mat.emissive = new THREE.Color(r*0.1, g*0.1, 0);
                    this.faceGroup.visible = true;
                    this.edges.visible = false;
                    this.faceGroup.rotation.y = (Math.PI / 2) * Math.floor(Math.random() * 4);
                } else if (t === 0) { // Light
                    this.mat.color.setHex(this.palette.box);
                    this.ribbonMat.color.setHex(this.palette.ribbon);
                    this.ribbonGroup.visible = true;
                    this.edges.material.color.setHex(0x000000);
                } else {
                    if(t === 1) { 
                         this.mat.color.setHex(this.warmColor);
                         this.mat.emissive.setHex(0x000000);
                         this.edges.visible = false; 
                    }
                    if(t === 2) { 
                         this.mat.color.setHex(0x001122); 
                         this.edges.material.color.setHex(0x00ffff); 
                         this.edges.material.opacity = 0.5; 
                    }
                }
            }
        }

        function updateWeather(dt) {
            const isHalloween = currentTheme === 3;
            const isSnow = currentTheme === 0;

            if (!isHalloween && !isSnow && weatherParticles.length === 0) return;

            if ((!isSnow && weatherParticles.some(p => p.type === 'snow')) || 
                (!isHalloween && weatherParticles.some(p => p.type === 'leaf'))) {
                 weatherParticles.forEach(l => scene.remove(l.mesh));
                 weatherParticles.length = 0;
                 if (!isHalloween && !isSnow) return;
            }
            
            windTimer += dt;
            if (windTimer > 8.0 && !windActive) {
                windActive = true;
                windTarget.set((Math.random()-0.5)*25, 5 + Math.random()*5, (Math.random()-0.5)*25); 
            }
            if (windTimer > 12.0 && windActive) {
                windActive = false;
                windTarget.set(0,0,0);
                windTimer = 0;
            }
            currentWind.lerp(windTarget, dt * 1.0); 

            const limit = isSnow ? 600 : 80;
            const spawnRate = isSnow ? 0.8 : 0.1;

            if(weatherParticles.length < limit && Math.random() < spawnRate) {
                let mesh, vel, type;
                const px = camera.position.x + (Math.random()-0.5)*50;
                const pz = camera.position.z + (Math.random()-0.5)*50;

                if (isSnow) {
                    const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
                    mesh = new THREE.Mesh(sharedSnowGeo, mat);
                    mesh.position.set(px, 30, pz);
                    mesh.lookAt(camera.position); 
                    vel = new THREE.Vector3((Math.random()-0.5)*2, -4 - Math.random()*4, (Math.random()-0.5)*2);
                    type = 'snow';
                } else {
                    const mat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xffaa00 : 0x884400, side: THREE.DoubleSide });
                    mesh = new THREE.Mesh(sharedLeafGeo, mat);
                    mesh.position.set(px, 30, pz);
                    mesh.rotation.set(Math.random(), Math.random(), Math.random());
                    vel = new THREE.Vector3((Math.random()-0.5)*3, -3 - Math.random()*3, (Math.random()-0.5)*3);
                    type = 'leaf';
                }

                scene.add(mesh);
                weatherParticles.push({ mesh: mesh, vel: vel, type: type, swayOffset: Math.random() * 100, landed: false, landTimer: 2.0 });
            }

            for(let i=weatherParticles.length-1; i>=0; i--) {
                const l = weatherParticles[i];

                if (l.landed) {
                    l.landTimer -= dt;
                    l.mesh.material.opacity = (l.landTimer / 2.0) * 0.8;
                    if (l.landTimer <= 0) {
                        scene.remove(l.mesh);
                        l.mesh.material.dispose();
                        weatherParticles.splice(i, 1);
                    }
                    continue; 
                }
                
                if (l.type === 'leaf' || l.type === 'snow') {
                    l.mesh.position.addScaledVector(currentWind, dt);
                    if(currentWind.lengthSq() > 1) {
                         if (l.type === 'leaf') {
                             l.mesh.rotation.z += dt * 5;
                             l.mesh.rotation.x += dt * 5;
                         } else {
                             l.mesh.position.x += (Math.random()-0.5) * dt * 5;
                         }
                    }
                }

                l.mesh.position.addScaledVector(l.vel, dt);
                
                if (l.type === 'leaf') {
                    l.mesh.rotation.x += dt * 2;
                    l.mesh.rotation.y += dt;
                    l.mesh.position.x += Math.sin(performance.now() * 0.002 + l.swayOffset) * dt * 2;
                } else {
                    l.mesh.position.x += Math.sin(performance.now() * 0.001 + l.swayOffset) * dt * 0.5;
                    l.mesh.rotation.z += dt; 
                }

                if(l.mesh.position.y <= 0) {
                    if (l.type === 'snow') {
                        l.landed = true;
                        l.mesh.position.y = 0.05; 
                        l.mesh.rotation.x = -Math.PI / 2;
                        l.vel.set(0,0,0);
                    } else {
                        scene.remove(l.mesh);
                        l.mesh.material.dispose();
                        weatherParticles.splice(i, 1);
                    }
                }
            }
        }

        function createSlashEffect() {
            const shape = new THREE.Shape();
            shape.moveTo(0, 1.2);
            shape.quadraticCurveTo(-0.5, 0, 0, -1.2);
            shape.quadraticCurveTo(-0.2, 0, 0, 1.2);
            slashGeometry = new THREE.ShapeGeometry(shape);
            slashGeometry.center(); 
        }

        function spawnSlash(parent) {
            const s = _slashPool[_slashIdx];
            _slashIdx = (_slashIdx + 1) % 20;
            s.active = true; s.isHit = false; s.fadeSpeed = 0.15;
            s.mesh.material.color.setHex(currentSlashColor);
            s.mesh.material.opacity = 1;
            s.mesh.visible = true;
            s.mesh.scale.set(1, 1, 1);
            if(parent === camera) {
                s.mesh.position.set(0.05, 0.05, -2.0);
                s.mesh.rotation.set(0, 0, -Math.PI / 8);
                camera.add(s.mesh);
                slashActive = true;
                document.getElementById('crosshair').style.opacity = 0;
            } else {
                s.mesh.position.set(0, 1.5, 1.0);
                s.mesh.lookAt(camera.position);
                parent.add(s.mesh);
            }
            return s.mesh;
        }

        function spawnSnowTrail(pos) {
            const p = _particlePool[_particleIdx];
            _particleIdx = (_particleIdx + 1) % 800;

            p.active = true; 
            p.type = 'snow-trail'; 
            p.life = 1.5;
            p.maxLife = 1.5;
            p.velocity.set(0,0,0);

            p.mesh.visible = true;
            // Relative Position: Camera height (~1.6) - 1.25 = 0.35 offset from feet
            p.mesh.position.set(pos.x, pos.y - 1.25, pos.z);

            // Apply movement delay (Match the kickup's lag)
            p.mesh.position.addScaledVector(player.velocity, -0.05);
            
            p.mesh.material.color.setHex(0xffffff);
            p.mesh.material.opacity = 0.8;
            p.mesh.material.blending = THREE.NormalBlending;
            p.mesh.scale.set(0.8, 0.8, 0.8);
        }

        function spawnSnowKickup(pos) {
            for(let i=0; i<3; i++) {
                const p = _particlePool[_particleIdx];
                _particleIdx = (_particleIdx + 1) % 800;

                p.active = true;
                p.type = 'static'; 
                p.life = 0.5;
                p.maxLife = 0.5;
                p.targetOpacity = 0.8;

                p.mesh.visible = true;
                p.mesh.material.color.setHex(0xffffff);
                p.mesh.material.opacity = 0.8;
                p.mesh.material.blending = THREE.NormalBlending;
                
                _tempA.set((Math.random()-0.5), -1.45, (Math.random()-0.5));
                p.mesh.position.copy(pos).add(_tempA);
                
                // NATURAL TRAIL: Subtract 5% of velocity from the position
                // This simulates a "delay" by spawning it slightly where you JUST were.
                p.mesh.position.addScaledVector(player.velocity, -0.05);
                
                p.velocity.set((Math.random()-0.5)*2, 1+Math.random()*3, (Math.random()-0.5)*2);
                p.mesh.scale.set(0.3, 0.3, 0.3);
            }
        }

        function spawnParticles(pos, col, count, speed=1.0, sizeMod=1.0) {
            for(let i=0; i<count; i++) {
                const p = _particlePool[_particleIdx];
                _particleIdx = (_particleIdx + 1) % 800;
                p.active = true; p.type = 'spark'; p.gravity = 15;
                p.life = 0.4 + Math.random() * 0.3; p.maxLife = p.life;
                p.mesh.visible = true; p.mesh.position.copy(pos);
                p.mesh.material.color.setHex(col);
                p.mesh.material.opacity = 1.0;
                p.mesh.material.blending = THREE.AdditiveBlending;
                const s = (0.2 + Math.random() * 0.3) * sizeMod;
                p.mesh.scale.set(s, s, s);
                p.velocity.set(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar((5 + Math.random() * 10) * speed);
            }
        }

        function spawnImpact(pos, color=0xffffff, scale=1.0) {
            const configs = [{s: scale, l: 0.1, c: 0xffffff, e: scale * 0.5}, {s: scale * 2, l: 0.25, c: color, e: scale * 4}];
            configs.forEach(conf => {
                const p = _particlePool[_particleIdx];
                _particleIdx = (_particleIdx + 1) % 800;
                p.active = true; p.type = 'flash'; p.life = conf.l; p.maxLife = conf.l;
                p.scaleStart = conf.s; p.scaleEnd = conf.e;
                p.mesh.visible = true; p.mesh.position.copy(pos);
                p.mesh.material.color.setHex(conf.c);
                p.mesh.material.opacity = 1.0;
                p.mesh.material.blending = THREE.AdditiveBlending;
                p.mesh.scale.setScalar(conf.s);
            });
        }

        function spawnRipple(pos, normal, baseColor=0x00ffff) {
            const colorObj = new THREE.Color(baseColor);
            for(let i=0; i<3; i++) {
                const r = _ripplePool[_rippleIdx];
                _rippleIdx = (_rippleIdx + 1) % 50;
                r.active = true; r.life = 0.8; r.maxLife = 0.8;
                r.mesh.visible = true;
                // RESTORE: Original geometry variance simulated via scale offset
                r.scaleOffset = 0.8 + (i * 0.1); 
                r.mesh.material.opacity = 0.8;
                r.mesh.material.color.copy(colorObj);
                if(i===1) r.mesh.material.color.lerp(new THREE.Color(0xffffff), 0.6);
                if(i===2) r.mesh.material.color.lerp(new THREE.Color(0x000088), 0.4);
                r.mesh.position.copy(pos).addScaledVector(normal, 0.05 + (i * 0.2));
                r.mesh.lookAt(pos.clone().add(normal));
            }
        }

        function spawnFirework(pos) {
            spawnParticles(pos, 0xffd700, 50, 4.0);
            spawnParticles(pos, 0x00ffff, 40, 2.5);
            spawnParticles(pos, 0xff00ff, 30, 1.0, 2.0);
            AudioSys.playFrag(pos); 
        }

        function createTeleportMarker() {
            if(teleportMarker) {
                scene.remove(teleportMarker);
            }
            teleportMarker = new THREE.Group();
            materials.marker.transparent = true;
            const diamondGroup = new THREE.Group();
            diamondGroup.position.y = 1.5;
            teleportMarker.add(diamondGroup);
            const geo = new THREE.OctahedronGeometry(0.8, 0);
            const diamond = new THREE.Mesh(geo, materials.marker);
            diamondGroup.add(diamond);
            const thickGeo = new THREE.OctahedronGeometry(0.805, 0);
            const thickDiamond = new THREE.Mesh(thickGeo, materials.marker);
            diamondGroup.add(thickDiamond);
            const ringGroup = new THREE.Group();
            ringGroup.position.y = 0.1;
            teleportMarker.add(ringGroup);
            const ringBaseGeo = new THREE.RingGeometry(0.8, 1.0, 32); 
            const ringMat = materials.marker.clone();
            ringMat.side = THREE.DoubleSide;
            const ring = new THREE.Mesh(ringBaseGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ringGroup.add(ring);
            const ring2 = new THREE.Mesh(ringBaseGeo, ringMat);
            ring2.rotation.x = -Math.PI / 2;
            ring2.scale.setScalar(1.01); 
            ringGroup.add(ring2);
            teleportMarker.userData = { diamond: diamondGroup, ring: ringGroup, ringMat: ringMat };
            teleportMarker.visible = false;
            scene.add(teleportMarker);
        }

        function getGroundHeight(x, z, startY = null) {
            let scanOriginY = 1000;
            let scanDistance = 2000;
            
            if (startY !== null) {
                scanOriginY = startY + 2.0;
                scanDistance = 10.0;
            }

            if (spatialGrid) {
                _groundBox.min.set(x - 0.5, scanOriginY - scanDistance, z - 0.5);
                _groundBox.max.set(x + 0.5, scanOriginY, z + 0.5);
                
                spatialGrid.query(_groundBox, _groundSet);
                
                if (_groundSet.size === 0) return -999;

                const candidateMeshes = [];
                _groundSet.forEach(item => {
                    candidateMeshes.push(item.mesh);
                });

                if (candidateMeshes.length > 0) {
                    _groundVec1.set(x, scanOriginY, z);
                    _groundVec2.set(0, -1, 0);
                    globalRaycaster.set(_groundVec1, _groundVec2);
                    globalRaycaster.far = scanDistance;
                    
                    const hits = globalRaycaster.intersectObjects(candidateMeshes);
                    if (hits.length > 0) return hits[0].point.y;
                }
            }
            return -999;
        }

        function getRandomSpawnY(x, z) {
            // --- TUNING KNOBS ---
            const BIAS_HIGH = 0.60; // 60% chance to pick the absolute highest point
            const BIAS_MID  = 0.30; // 30% chance to pick a middle platform
            // Remaining 10% falls to ground
            // --------------------

            if (!spatialGrid) return getGroundHeight(x, z);
            
            _groundBox.min.set(x - 0.5, -100, z - 0.5);
            _groundBox.max.set(x + 0.5, 500, z + 0.5);
            
            const candidates = new Set();
            spatialGrid.query(_groundBox, candidates);
            
            if (candidates.size === 0) return getGroundHeight(x, z);

            const candidateMeshes = [];
            candidates.forEach(item => candidateMeshes.push(item.mesh));

            if (candidateMeshes.length > 0) {
                _groundVec1.set(x, 1000, z);
                _groundVec2.set(0, -1, 0);
                globalRaycaster.set(_groundVec1, _groundVec2);
                globalRaycaster.far = 2000;
                
                const hits = globalRaycaster.intersectObjects(candidateMeshes);
                const points = [];
                
                for(let hit of hits) {
                    if (hit.face && hit.face.normal.y > 0.5) {
                        points.push(hit.point.y);
                    }
                }
                
                if (points.length > 0) {
                    // Sort descending (Highest first)
                    points.sort((a, b) => b - a);
                    
                    const groundY = points[points.length - 1];
                    const highPoints = points.filter(y => y > groundY + 20.0);
                    const midPoints = points.filter(y => y > groundY + 5.0 && y <= groundY + 20.0);

                    // 1. Try High Tier
                    if (highPoints.length > 0 && Math.random() < BIAS_HIGH) {
                        return highPoints[Math.floor(Math.random() * highPoints.length)];
                    }
                    
                    // 2. Try Mid Tier
                    if (midPoints.length > 0 && Math.random() < BIAS_MID) {
                        return midPoints[Math.floor(Math.random() * midPoints.length)];
                    }
                    
                    // 3. Fallback (Ground or Random)
                    return points[Math.floor(Math.random() * points.length)];
                }
            }
            return getGroundHeight(x, z);
        }
        
        function snapToFloor(pos) {
            const origin = pos.clone();
            origin.y += 1.0; 
            globalRaycaster.set(origin, new THREE.Vector3(0, -1, 0));
            globalRaycaster.far = 6.0; 
            const hits = globalRaycaster.intersectObjects(groundObjects);
            if(hits.length > 0) {
                pos.y = hits[0].point.y + 1.6;
            }
        }

        function getTeleportTarget(maxDist = CONFIG.teleportRange) {
            globalRaycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            globalRaycaster.far = maxDist;
            const intersects = globalRaycaster.intersectObjects(worldObjects);
            if (intersects.length > 0) {
                return { point: intersects[0].point, hit: true, normal: intersects[0].face.normal };
            } else {
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                return { point: camera.position.clone().addScaledVector(dir, maxDist), hit: false, normal: null };
            }
        }

        function performJump() {
             player.velocity.y = CONFIG.jumpForce;
             if(player.isSliding) {
                  player.velocity.y = 15; 
                  const forward = new THREE.Vector3();
                  camera.getWorldDirection(forward);
                  forward.y=0; forward.normalize();
             }
             if(player.onGround) {
                 player.airTimeStart = performance.now();
                 spawnRipple(camera.position.clone().add(new THREE.Vector3(0,-1.5,0)), new THREE.Vector3(0,1,0), 0x00ffff);
             } else {
                 spawnRipple(camera.position.clone().add(new THREE.Vector3(0,-1.5,0)), new THREE.Vector3(0,1,0), 0x00ffaa);
             }
             player.onGround = false;
             player.lastJumpTime = performance.now(); 
             AudioSys.playJump();
        }
        
        function performWallJump() {
            if (performance.now() - player.lastWallJumpTime < 300) return false;
            globalRaycaster.far = 1.5;
            const dirs = [
                new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0),
                new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)
            ];
            let hitWall = false;
            let wallNormal = new THREE.Vector3(0,1,0); 
            for(let d of dirs) {
                d.applyQuaternion(camera.quaternion);
                globalRaycaster.set(camera.position, d);
                const intersects = globalRaycaster.intersectObjects(walls);
                if(intersects.length > 0) {
                    hitWall = true;
                    const force = Math.max(CONFIG.wallPushForce, (player.wallImpactVelocity || 0) * 0.9);
                    player.velocity.addScaledVector(d, -force);
                    if (intersects[0].face) wallNormal = intersects[0].face.normal;
                    spawnRipple(intersects[0].point, wallNormal, 0xffff00);
                    break;
                }
            }
            if (hitWall) {
                player.velocity.y = CONFIG.wallJumpForce;
                player.onGround = false;
                player.lastJumpTime = performance.now();
                player.lastWallJumpTime = performance.now(); 
                AudioSys.playWallJump();
                return true;
            }
            return false;
        }

        function tryAimTeleport() {
            if (player.teleportTarget) {
                const force = player.teleportLocked;
                executeTeleport(player.teleportTarget, null, force); 
                player.teleportActive = false; 
            }
        }

        function tryInstantTeleport() {
            const result = getTeleportTarget();
            executeTeleport(result.point, result.normal);
            document.getElementById('icon-q').classList.add('active');
            setTimeout(() => document.getElementById('icon-q').classList.remove('active'), 200);
        }

        function resolveTeleportPosition(target, normal) {
            const dest = target.clone();
            const origin = camera.position;

            // 1. Range Clamping
            // Clamp immediately to ensure environmental queries happen at the actual destination
            const distSq = dest.distanceToSquared(origin);
            const maxSq = CONFIG.teleportRange * CONFIG.teleportRange;
            if (distSq > maxSq) {
                dest.sub(origin).normalize().multiplyScalar(CONFIG.teleportRange).add(origin);
            }

            // 2. Lateral Wall Offset
            // Push away from vertical surfaces; ignore horizontal normals (floors/ceilings)
            if (normal && Math.abs(normal.y) < 0.5) {
                dest.addScaledVector(normal, 0.8);
            }

            // 3. Vertical Environment Scan
            // Determine physical ceiling height at target coordinates
            const halfW = 0.3;
            const playerHeight = 1.8;
            const offsetBuffer = 2.0; 
            let ceilingY = Infinity;
            
            if (spatialGrid) {
                const scanBox = _box3_1; // Reuse global box
                scanBox.min.set(dest.x - halfW, -100, dest.z - halfW);
                scanBox.max.set(dest.x + halfW, 500, dest.z + halfW);

                const candidates = spatialGrid.query(scanBox);
                for (const wall of candidates) {
                    if (wall.mesh.userData.isFloor) continue;
                    
                    // Check if target is within the X/Z footprint of the block
                    if (dest.x >= wall.box.min.x && dest.x <= wall.box.max.x &&
                        dest.z >= wall.box.min.z && dest.z <= wall.box.max.z) {
                        
                        const wallBottom = wall.box.min.y;
                        
                        // Identify the lowest ceiling above (or enveloping) the target
                        if (wallBottom > (dest.y - 0.5) && wallBottom < ceilingY) {
                            ceilingY = wallBottom;
                        }
                    }
                }
            }

            // 4. Ceiling Constraint
            // Force target to fit underneath detected ceiling
            if (ceilingY !== Infinity) {
                if (dest.y + offsetBuffer > ceilingY) {
                    dest.y = ceilingY - offsetBuffer;
                }
            }

            // 5. Floor Snapping
            // Snap to ground if close, ensuring we don't violate ceiling constraints
            const gh = getGroundHeight(dest.x, dest.z, dest.y);
            if (dest.y > gh && dest.y - gh < 3.0) {
                if (ceilingY === Infinity || (ceilingY - offsetBuffer) > gh) {
                    if (dest.y < gh + 0.01) dest.y = gh + 0.01;
                }
            }
            
            // 6. Physics Resolution
            // Resolve lateral collisions to prevent clipping into walls
            const tempBox = _box3_1;
            tempBox.min.set(dest.x - halfW, dest.y, dest.z - halfW);
            tempBox.max.set(dest.x + halfW, dest.y + playerHeight, dest.z + halfW);

            if (spatialGrid) {
                const collisions = spatialGrid.query(tempBox);
                for(const wall of collisions) {
                    if (wall.mesh.userData.isFloor) continue;
                    
                    if (tempBox.intersectsBox(wall.box)) {
                        // Ignore vertical overlaps (handled by steps 3-5)
                        const overlapY = Math.min(tempBox.max.y - wall.box.min.y, wall.box.max.y - tempBox.min.y);
                        const overlapX = Math.min(tempBox.max.x - wall.box.min.x, wall.box.max.x - tempBox.min.x);
                        const overlapZ = Math.min(tempBox.max.z - wall.box.min.z, wall.box.max.z - tempBox.min.z);
                        
                        if (overlapY < overlapX && overlapY < overlapZ) continue;

                        const wallCenterX = (wall.box.min.x + wall.box.max.x) / 2;
                        const wallCenterZ = (wall.box.min.z + wall.box.max.z) / 2;
                        
                        if (overlapX < overlapZ) {
                            const sign = (dest.x < wallCenterX) ? -1 : 1;
                            dest.x += (overlapX + 0.05) * sign; 
                        } else {
                            const sign = (dest.z < wallCenterZ) ? -1 : 1;
                            dest.z += (overlapZ + 0.05) * sign;
                        }
                        tempBox.min.set(dest.x - halfW, dest.y, dest.z - halfW);
                        tempBox.max.set(dest.x + halfW, dest.y + playerHeight, dest.z + halfW);
                    }
                }
            }
            
            return dest;
        }

        function executeTeleport(target, normal, force = false) {
            if (player.energy < CONFIG.teleportCost) {
                AudioSys.playMiss();
                return;
            }
            player.energy -= CONFIG.teleportCost;
            
            let dest;
            if (force) {
                dest = target.clone();
            } else {
                dest = resolveTeleportPosition(target, normal);
            }

            const startInAir = !player.onGround;
            const finalGround = getGroundHeight(dest.x, dest.z);
            const endInAir = (dest.y - finalGround) > 0.5;

            player.lastTeleportWasAerial = startInAir || endInAir;
            player.hasPhaseStruck = false; 

            spawnParticles(camera.position, 0x00ffaa, 20); 
            
            player.lastTeleportDest = dest.clone();

            camera.position.set(dest.x, dest.y + 1.6, dest.z);
            
            player.jumpsRemaining = 1; 
            player.onGround = false; 
            if(!startInAir) player.airTimeStart = performance.now();
            player.lastTeleportTime = performance.now(); 
            AudioSys.playTeleport();
            spawnParticles(camera.position, 0x00ffaa, 30);
        }

        function updateComboUI() {
            const el = document.getElementById('combo-display');
            const meme = document.getElementById('meme-overlay');
            let memeText = "";
            let isPattern = false;

            // --- Century Threshold Logic ---
            const currentCentury = Math.floor(comboCount / 100);
            const isNewMilestone = currentCentury > lastCenturyMarked && comboCount >= 100;

            if (MEME_TRIGGERS[comboCount]) {
                memeText = MEME_TRIGGERS[comboCount];
                showKillMessage(memeText, "achievement", "#00ffff");
            } 
            
            if (comboCount >= 100) {
                const s = comboCount.toString();
                if (/^(\d)\1+$/.test(s)) isPattern = true;
                else if ("123456789".includes(s) || "987654321".includes(s)) isPattern = true;
            }

            if (memeText) {
                meme.innerText = memeText;
                meme.style.display = "block";
                setTimeout(() => meme.style.display = "none", 4000); 
            }

            if (isPattern) {
                el.classList.add('cyan-mode');
            } else if (comboCount !== 666 && comboCount !== 777) { 
                if (MEME_TRIGGERS[comboCount] && (comboCount === 666 || comboCount === 777)) {
                     el.classList.add('cyan-mode');
                } else {
                     el.classList.remove('cyan-mode');
                }
            }

            if(comboCount < 2) {
                el.style.display = 'none';
            } else {
                el.style.display = 'block';
                el.innerText = comboCount + " STRIKES";
                let fontSize = "1.5rem"; 
                let color = "#ffcc00";
                let opacity = "1";
                let blur = "none";
                let textShadow = "4px 4px 0px rgba(0,0,0,0.5)";
                
                if(comboCount >= 5) fontSize = "3rem"; 
                
                if (comboCount >= 10) {
                    if (comboCount % 10 === 0) {
                        fontSize = "4rem"; 
                        color = "#ff0000";
                        textShadow = "0 0 20px #ff0000, 4px 4px 0px rgba(0,0,0,0.8)";
                    } else {
                        fontSize = "3rem"; 
                        opacity = "0.8"; 
                        blur = "none"; 
                    }
                }
                
                // --- Dynamic Milestone Trigger ---
                if (isNewMilestone) {
                    lastCenturyMarked = currentCentury;
                    const milestoneValue = currentCentury * 100;
                    
                    const MILESTONE_TITLES = [
                        "CENTURION", "VANGUARD", "OVERLORD", "ELITE", "BEHEMOTH", 
                        "MONOLITH", "LEGEND", "ZENITH", "APEX", "SUPREME"
                    ];
                    // Pick title based on hundred, clamping to the last index if over 1000
                    const titleIdx = Math.min(currentCentury - 1, MILESTONE_TITLES.length - 1);
                    const milestoneTitle = MILESTONE_TITLES[titleIdx];

                    fontSize = "6rem"; 
                    color = "#ff00ff";
                    textShadow = "0 0 50px #ff00ff, 0 0 20px #fff";
                    blur = "none";
                    opacity = "1";

                    spawnFirework(camera.position.clone().add(new THREE.Vector3(0,0,-5)));
                    GameStats.addAchievement(`${milestoneValue} STRIKES ${milestoneTitle}`, "#ff00ff", "PERSISTENT");
                }

                el.style.fontSize = fontSize;
                if(!el.classList.contains('cyan-mode')) {
                    el.style.color = color;
                    el.style.textShadow = textShadow;
                }
                el.style.opacity = opacity;
                el.style.filter = blur;
                el.style.transform = "translateX(-50%) scale(1.3) skewX(-15deg)";
                requestAnimationFrame(() => {
                     setTimeout(() => {
                         el.style.transform = "translateX(-50%) scale(1) skewX(-15deg)";
                     }, 50);
                });
            }
            if(comboCount > GameStats.highestCombo) GameStats.highestCombo = comboCount;
        }

        const BOT_TYPES = {
            NORMAL: { scale: 1, hp: 200, speedMod: 1, dmgRed: 1, skill: 1, name: "NORMAL", color: 0x2F4F4F, eye: 0xffffff },   
            BRUTE: { scale: 2, hp: 600, speedMod: 0.85, dmgRed: 1, skill: 2, name: "BRUTE", color: 0x191970, eye: 0xffff00 }, 
            TITAN: { scale: 3, hp: 1200, speedMod: 0.75, dmgRed: 1, skill: 2, name: "TITAN", color: 0x4B0082, eye: 0xff8c00 }, 
            COLOSSUS: { scale: 5, hp: 4000, speedMod: 0.6, dmgRed: 0.5, skill: 1, name: "COLOSSUS", color: 0x800000, eye: 0xff0000 } 
        };
        
        function getBotReactionTime(bot) {
            const hpPct = bot.health / bot.maxHealth;
            const base = 100 + (1 - hpPct) * 300; 
            const rand = Math.random() * 50;
            return base + rand;
        }

        class Enemy {
            constructor(posOverride = null, typeOverride = null, initialState = 'ROAM', aggroDelay = 0, ws = null) {
                this.mesh = new THREE.Group();
                this.id = Math.random();

                // --- Spawn Logic ---
                let spawnY = 0;

                if (posOverride) {
                    this.mesh.position.copy(posOverride);
                    this.mesh.position.x += (Math.random() - 0.5) * 2;
                    this.mesh.position.z += (Math.random() - 0.5) * 2;
                    spawnY = this.mesh.position.y;

                    if (typeOverride) this.type = typeOverride;
                    else this.type = BOT_TYPES.NORMAL;
                } else {
                    let x, z;
                    const usedDecorations = ws ? ws.decorations : decorations;
                    const spawnRange = ws ? ws.config.size * 0.4 : 175;
                    let validSpawn = false;

                    // Try spawning near decoration
                    if (Math.random() < 0.4 && usedDecorations.length > 0) {
                        const dec = usedDecorations[Math.floor(Math.random() * usedDecorations.length)];
                        const range = (dec.scale - 2) * 0.6;
                        if (range > 2) {
                            x = dec.visualMesh.position.x + (Math.random() - 0.5) * 2 * range;
                            z = dec.visualMesh.position.z + (Math.random() - 0.5) * 2 * range;
                            validSpawn = true;
                        }
                    }

                    // Fallback random spawn
                    if (!validSpawn) {
                        do {
                            x = (Math.random() - 0.5) * (spawnRange * 2);
                            z = (Math.random() - 0.5) * (spawnRange * 2);
                        } while (Math.abs(x) < 20 && Math.abs(z) < 20);
                    }

                    spawnY = getRandomSpawnY(x, z);
                    if (spawnY <= -999) spawnY = 0;

                    // Determine Type based on Height
                    let r = Math.random();
                    let type = 'NORMAL';
                    if (spawnY > 35) {
                        if (r < 0.4) type = 'COLOSSUS';
                        else if (r < 0.9) type = 'TITAN';
                        else type = 'BRUTE';
                    } else if (spawnY > 5) {
                        if (r < 0.05) type = 'COLOSSUS';
                        else if (r < 0.4) type = 'TITAN';
                        else if (r < 0.8) type = 'BRUTE';
                        else type = 'NORMAL';
                    } else {
                        if (r < 0.01) type = 'COLOSSUS';
                        else if (r < 0.05) type = 'TITAN';
                        else if (r < 0.20) type = 'BRUTE';
                        else type = 'NORMAL';
                    }
                    this.type = BOT_TYPES[type];
                    this.mesh.position.set(x, spawnY + this.type.scale, z);
                }

                // --- Mesh Setup ---
                const bodyMat = new THREE.MeshPhysicalMaterial({
                    color: this.type.color,
                    metalness: 0.1,
                    roughness: 0.2,
                    clearcoat: 0.5
                });
                this.body = new THREE.Mesh(sharedEnemyGeo, bodyMat);

                if (ws && ws.config.bots > 100) this.body.castShadow = false;
                else this.body.castShadow = true;

                this.body.receiveShadow = true;
                this.mesh.add(this.body);

                this.outline = new THREE.LineSegments(sharedEnemyEdgeGeo, new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3
                }));
                this.outline.scale.setScalar(1.02);
                this.mesh.add(this.outline);

                const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
                this.eyeMat = new THREE.MeshBasicMaterial({ color: this.type.eye });
                this.eyeL = new THREE.Mesh(eyeGeo, this.eyeMat);
                this.eyeL.position.set(-0.2, 0.5, 0.5);
                this.eyeR = new THREE.Mesh(eyeGeo, this.eyeMat);
                this.eyeR.position.set(0.2, 0.5, 0.5);
                this.mesh.add(this.eyeL);
                this.mesh.add(this.eyeR);
                this.mesh.scale.setScalar(this.type.scale);

                // --- Health Bar UI ---
                this.healthBarGroup = new THREE.Group();
                const barGeo = new THREE.PlaneGeometry(1.2, 0.15);
                const barMat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
                this.healthBar = new THREE.Mesh(barGeo, barMat);
                this.healthBar.position.z = 0.01;
                this.healthBarGroup.add(this.healthBar);
                const bgGeo = new THREE.PlaneGeometry(1.3, 0.25);
                const bgMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
                const bg = new THREE.Mesh(bgGeo, bgMat);
                this.healthBarGroup.add(bg);
                const uiScale = 1 + (this.type.scale - 1) * 0.5;
                this.healthBarGroup.scale.setScalar(uiScale);
                this.healthBarGroup.visible = false;

                if (ws) {
                    ws.enemies.push(this);
                    ws.group.add(this.mesh);
                    ws.group.add(this.healthBarGroup);
                } else {
                    enemies.push(this);
                    (currentWorldGroup || scene).add(this.mesh);
                    (currentWorldGroup || scene).add(this.healthBarGroup);
                }

                // --- Stats & State ---
                this.maxHealth = this.type.hp;
                this.health = this.maxHealth;
                this.velocity = new THREE.Vector3();
                this.jumps = 0;
                this.state = initialState;
                this.hasAggroed = initialState === 'AGGRO';
                this.reactionTimer = aggroDelay > 0 ? aggroDelay * 1000 : 0;

                this.targetPos = new THREE.Vector3();
                this.lastKnownPos = new THREE.Vector3();
                this.searchTimer = 0;
                this.pickRoamTarget();

                this.lastAttack = performance.now();
                this.actionTimer = 0;
                this.isSprinting = false;
                this.isSliding = false;
                this.wasSliding = false;
                this.isDeadCorpse = false;
                this.corpseTimer = 0;
                this.confusedTimer = 0;
                this.streak = 0;
                this.lastHitTime = 0;
                this.lastDamageTime = 0;
                this.isRegenerating = false;
                this.isRetreating = false;
                this.pendingRetreat = false;
                this.teleportTimer = 0;
                this.teleportDelay = 0;
                this.personalSpeedMod = 0.8 + Math.random() * 0.4;
                this.portalCooldown = 0;
                this.strafeDir = Math.random() < 0.5 ? 1 : -1;
                this.strafeTimer = 0;
                this.dodgeTimer = 0;
                this.dodgeReactionTimer = 0;
                this.ledgeTimer = 0;
                this.lastPos = new THREE.Vector2(this.mesh.position.x, this.mesh.position.z);
                this.stamina = 10;
                this.maxStamina = 10;
                this.staminaRegen = 3;
                this.visionTimer = Math.random() * 0.5;
                this.canSeePlayerCached = false;

                // LOD variables
                this.targetRotation = this.mesh.rotation.y;
                this.lastGroundHeight = 0;
                this.groundCheckTimer = 0;
                this.currentMoveSpeed = 0;
                this.currentMoveDir = new THREE.Vector3();

                this.updateTheme(currentTheme);
            }

            setHighlight(active) {
                if (active) {
                    this.body.material.emissive.setHex(0xff0000);
                    this.body.material.emissiveIntensity = 1.0;
                    this.outline.material.color.setHex(0xffffff);
                    this.outline.material.opacity = 0.8;
                } else {
                    this.updateTheme(currentTheme);
                    this.outline.scale.setScalar(1.02);
                }
            }

            updateTheme(t) {
                if (t === 2) {
                    this.outline.material.color.setHex(0x00ffff);
                    this.outline.material.opacity = 0.8;
                    this.body.material.color.setHex(0x000000);
                    this.body.material.emissive.setHex(0x000000);
                    this.body.material.emissiveIntensity = 0;
                } else {
                    this.outline.material.color.setHex(0xffffff);
                    this.outline.material.opacity = 0.3;
                    this.body.material.color.setHex(this.type.color);
                    this.body.material.emissiveIntensity = 0;
                }
            }

            pickRoamTarget() {
                const myGround = getGroundHeight(this.mesh.position.x, this.mesh.position.z, this.mesh.position.y);

                if (myGround > -500) {
                    for (let i = 0; i < 10; i++) {
                        const tx = this.mesh.position.x + (Math.random() - 0.5) * 60;
                        const tz = this.mesh.position.z + (Math.random() - 0.5) * 60;
                        if (Math.abs(tx) > 150 || Math.abs(tz) > 150) continue;

                        const tGround = getGroundHeight(tx, tz, this.mesh.position.y);

                        if (Math.abs(tGround - myGround) < 3.0 && tGround > -500) {
                            this.targetPos.set(tx, tGround, tz);
                            return;
                        }
                    }
                }

                const roamRange = WorldManager.current ? WorldManager.current.config.size * 0.3 : 150;
                this.targetPos.set(
                    (Math.random() - 0.5) * roamRange,
                    this.mesh.position.y,
                    (Math.random() - 0.5) * roamRange
                );
            }

            canSeePlayer(playerPos) {
                if (this.isDeadCorpse || this.state === 'CONFUSED') return false;
                return this.canSeePlayerCached;
            }

            checkVision(playerPos) {
                if (this.isDeadCorpse || this.state === 'CONFUSED') return false;
                _vec3_3.copy(this.mesh.position).add(new THREE.Vector3(0, 0.5, 0));
                const distToPlayer = _vec3_3.distanceTo(playerPos);
                _vec3_1.subVectors(playerPos, _vec3_3).normalize();
                globalRaycaster.set(_vec3_3, _vec3_1);
                globalRaycaster.far = 60;
                const hits = globalRaycaster.intersectObjects(walls);
                if (hits.length > 0 && hits[0].distance < distToPlayer) {
                    return false;
                }
                return true;
            }

            performJump(forceMultiplier = 1.0) {
                this.velocity.y = CONFIG.jumpForce * forceMultiplier;
                this.jumps++;
                this.mesh.position.y += 0.2; // Prevent ground stickiness
                
                // Visuals: Calculate feet position using shared vector (Zero Allocation)
                _vec3_1.copy(this.mesh.position);
                _vec3_1.y -= this.type.scale;
                
                // Use shared vector for "Up" direction (Zero Allocation)
                _vec3_2.set(0, 1, 0);
                
                spawnRipple(_vec3_1, _vec3_2, this.type.eye);
                
                AudioSys.playJump(this.mesh.position);
            }

            update(dt, playerPos) {
                const distSq = this.mesh.position.distanceToSquared(camera.position);

                // --- Visual LOD ---
                let logicInterval = 1;
                if (distSq > 22500) logicInterval = 10;
                else if (distSq > 2500) logicInterval = 3;

                if (distSq > 22500) {
                    this.outline.visible = false;
                    this.healthBarGroup.visible = false;
                    this.eyeL.visible = false;
                    this.eyeR.visible = false;
                } else {
                    this.outline.visible = true;
                    this.eyeL.visible = true;
                    this.eyeR.visible = true;
                    if (this.hasAggroed && !this.isDeadCorpse) this.healthBarGroup.visible = true;
                }

                // --- Logic LOD ---
                const shouldRunLogic = (frameCounter + Math.floor(this.id * 100)) % logicInterval === 0;
                if (shouldRunLogic) {
                    this.updateAI(dt * logicInterval, playerPos, logicInterval);
                }

                // --- Physics LOD (Always runs) ---
                this.updatePhysics(dt, distSq);
            }

            updateAI(dt, playerPos, intervalMultiplier) {
                if (this.isDeadCorpse) return;

                // Ground Check (Optimized)
                const distMoved = Math.hypot(this.mesh.position.x - this.lastPos.x, this.mesh.position.z - this.lastPos.y);
                const isInAir = Math.abs(this.mesh.position.y - this.lastGroundHeight) > 2.0;

                if (distMoved > 1.0 || isInAir || this.groundCheckTimer <= 0) {
                    this.lastGroundHeight = getGroundHeight(this.mesh.position.x, this.mesh.position.z, this.mesh.position.y);
                    this.groundCheckTimer = 0.5;
                } else {
                    this.groundCheckTimer -= dt;
                }

                this.visionTimer -= dt;
                if (this.visionTimer <= 0) {
                    this.canSeePlayerCached = this.checkVision(playerPos);
                    this.visionTimer = 0.3 + Math.random() * 0.2;
                }

                if (this.reactionTimer > 0) {
                    this.reactionTimer -= dt * 1000;
                    this.currentMoveSpeed = 0;
                    return;
                }

                // Stats Regen
                const now = performance.now();
                if (now - this.lastDamageTime > CONFIG.regenDelay && this.health < this.maxHealth) {
                    this.health += CONFIG.regenRate * dt;
                    if (this.health >= this.maxHealth) {
                        this.health = this.maxHealth;
                        this.isRetreating = false;
                    }
                }

                if (this.stamina < this.maxStamina) {
                    this.stamina = Math.min(this.maxStamina, this.stamina + this.staminaRegen * dt);
                }

                if (this.teleportTimer > 0) this.teleportTimer -= dt * 1000;
                if (this.teleportDelay > 0) this.teleportDelay -= dt;
                if (this.portalCooldown > 0) this.portalCooldown -= dt;
                if (this.strafeTimer > 0) this.strafeTimer -= dt;
                if (this.dodgeTimer > 0) this.dodgeTimer -= dt;
                if (this.dodgeReactionTimer > 0) this.dodgeReactionTimer -= dt;
                if (this.ledgeTimer > 0) this.ledgeTimer -= dt;

                // Portals
                if (this.portalCooldown <= 0) {
                    for (let p of portals) {
                        if (this.mesh.position.distanceTo(p.mesh.position) < 3.0) {
                            p.teleportEntity(this.mesh.position, this.velocity);
                            this.portalCooldown = 0.5;
                        }
                    }
                }

                let dest = this.targetPos;
                let speed = (this.isSprinting ? CONFIG.botSprintSpeed : CONFIG.botSpeed) * this.type.speedMod * this.personalSpeedMod;
                const hpPct = this.health / this.maxHealth;
                const groundY = this.lastGroundHeight;

                // --- State Machine ---
                if (this.state === 'ROAM') {
                    speed = CONFIG.botRoamSpeed * this.type.speedMod * this.personalSpeedMod;

                    if (this.mesh.position.y < 20) {
                        if (Math.random() < 0.002 * intervalMultiplier) {
                            const range = WorldManager.current ? WorldManager.current.config.size * 0.4 : 150;
                            const tx = (Math.random() - 0.5) * 2 * range;
                            const tz = (Math.random() - 0.5) * 2 * range;
                            const ty = getRandomSpawnY(tx, tz);

                            if (ty > 50) {
                                spawnParticles(this.mesh.position, 0x00ffff, 20);
                                this.mesh.position.set(tx, ty + this.type.scale, tz);
                                this.velocity.set(0, 0, 0);
                                this.targetPos.set(tx, ty, tz);
                                spawnParticles(this.mesh.position, 0x00ffff, 20);
                                return;
                            }
                        }
                    }

                    if (this.onGroundSafe(groundY)) {
                        // Zero-Alloc LookAhead
                        _aiFwd.set(0,0,1).applyAxisAngle(_UP, this.mesh.rotation.y);
                        _aiTemp.copy(this.mesh.position).addScaledVector(_aiFwd, 2.0);
                        
                        const aheadHeight = getGroundHeight(_aiTemp.x, _aiTemp.z);
                        if (groundY - aheadHeight > 3.0) {
                            if (Math.random() < 0.1 * intervalMultiplier) this.pickRoamTarget();
                        }
                    }
                    if (Math.hypot(this.mesh.position.x - dest.x, this.mesh.position.z - dest.z) < 3) {
                        this.pickRoamTarget();
                    }
                    if (this.onGroundSafe(groundY) && Math.random() < 0.005 * intervalMultiplier) {
                        this.performJump(0.8);
                    }
                } else if (this.state === 'AGGRO') {
                    if (this.canSeePlayer(playerPos)) {
                        this.lastKnownPos.copy(playerPos);
                        dest = playerPos;
                        const dist = this.mesh.position.distanceTo(playerPos);

                        // Retreat Logic
                        if (hpPct < 0.5 && !this.isRetreating && !this.pendingRetreat) {
                            this.pendingRetreat = true;
                            if (this.teleportDelay <= 0) {
                                this.teleportDelay = getBotReactionTime(this) / 1000;
                            }
                        }
                        if (this.pendingRetreat && this.teleportDelay <= 0) {
                            this.isRetreating = true;
                            this.pendingRetreat = false;
                        }
                        if (this.isRetreating) {
                            speed = CONFIG.botSprintSpeed * this.type.speedMod * this.personalSpeedMod * 1.3;
                            this.isSprinting = true;

                            const slideBase = (hpPct < 0.25) ? 0.4 : 0.05;
                            if (!this.isSliding && Math.random() < slideBase * intervalMultiplier) this.isSliding = true;

                            // Zero-Alloc Retreat Dir
                            _aiDir.subVectors(this.mesh.position, playerPos).normalize();
                            
                            globalRaycaster.set(this.mesh.position, _aiDir);
                            globalRaycaster.far = 5;
                            const wallsAhead = globalRaycaster.intersectObjects(walls);
                            
                            if (wallsAhead.length > 0) {
                                let escapeFound = false;
                                // Calculate Left (-Z, X) and Right (Z, -X) without new objects
                                _aiTemp.set(-_aiDir.z, 0, _aiDir.x); // Left
                                globalRaycaster.set(this.mesh.position, _aiTemp);
                                
                                if (globalRaycaster.intersectObjects(walls).length === 0) {
                                    _aiDir.copy(_aiTemp);
                                    escapeFound = true;
                                } else {
                                    _aiTemp.set(_aiDir.z, 0, -_aiDir.x); // Right
                                    globalRaycaster.set(this.mesh.position, _aiTemp);
                                    if (globalRaycaster.intersectObjects(walls).length === 0) {
                                        _aiDir.copy(_aiTemp);
                                        escapeFound = true;
                                    }
                                }
                                if (!escapeFound && dist < 10) {
                                    if (this.onGroundSafe(groundY)) {
                                        this.performJump(1.25);
                                        _aiDir.subVectors(playerPos, this.mesh.position).normalize();
                                    }
                                } else if (!escapeFound) {
                                    _aiDir.set((Math.random() - 0.5), 0, (Math.random() - 0.5)).normalize();
                                }
                            }
                            // Set target 40 units away
                            this.targetPos.copy(this.mesh.position).addScaledVector(_aiDir, 40);
                            dest = this.targetPos;
                        }

                        // Teleport Logic (Simplified Allocations)
                        if (this.teleportTimer <= 0 && this.stamina >= 10 && this.teleportDelay <= 0) {
                            let wantsToTp = (dist < 15 && this.isRetreating) || (dist > 25 && !this.isRetreating) || (dist < 15 && !this.isRetreating);
                            if (wantsToTp && !this.teleportReactionPending) {
                                this.teleportDelay = getBotReactionTime(this) / 1000;
                                this.teleportReactionPending = true;
                            }
                            if (this.teleportDelay <= 0 && this.teleportReactionPending) {
                                this.teleportReactionPending = false;
                                let tpChance = (this.isRetreating ? 0.05 : (dist > 25 ? 0.02 : 0.005));

                                if (Math.random() < tpChance * intervalMultiplier) {
                                    _aiTemp.set(0,0,0); // Use as 'newPos' holder
                                    let validTp = false;
                                    const minRange = 5;
                                    const maxRange = 20;
                                    const tpRange = minRange + (1.0 - hpPct) * (maxRange - minRange);
                                    
                                    if (this.isRetreating) {
                                        _aiDir.subVectors(this.mesh.position, playerPos).normalize();
                                        _aiDir.x += (Math.random() - 0.5) * 0.5;
                                        _aiDir.z += (Math.random() - 0.5) * 0.5;
                                        _aiDir.normalize();
                                        _aiTemp.copy(this.mesh.position).addScaledVector(_aiDir, tpRange);
                                        validTp = true;
                                    } else if (dist > 25) {
                                        _aiDir.subVectors(playerPos, this.mesh.position).normalize();
                                        const travelDist = dist - 5;
                                        if (travelDist > 5) {
                                            _aiTemp.copy(this.mesh.position).addScaledVector(_aiDir, Math.min(travelDist, maxRange));
                                            validTp = true;
                                        }
                                    } else if (dist < 15 && !this.isRetreating) {
                                        _aiTemp.copy(this.mesh.position).add(new THREE.Vector3((Math.random() - 0.5) * 10, 0, (Math.random() - 0.5) * 10));
                                        validTp = true;
                                    }
                                    
                                    if (validTp) {
                                        _aiDir.subVectors(_aiTemp, this.mesh.position);
                                        const tpDist = _aiDir.length();
                                        _aiDir.normalize();
                                        globalRaycaster.set(this.mesh.position, _aiDir);
                                        globalRaycaster.far = tpDist;
                                        if (globalRaycaster.intersectObjects(walls).length > 0) {
                                            // Hit wall, simple abort for now to save allocation
                                            validTp = false; 
                                        }
                                        
                                        if (validTp && getGroundHeight(_aiTemp.x, _aiTemp.z) > -10) {
                                            spawnParticles(this.mesh.position, 0xff00ff, 15);
                                            this.mesh.position.copy(_aiTemp);
                                            spawnParticles(this.mesh.position, 0xff00ff, 15);
                                            AudioSys.playTeleport(this.mesh.position);
                                            this.stamina -= 10;
                                            this.teleportTimer = 500;
                                        }
                                    }
                                }
                            }
                        }

                        // Attack Logic
                        if (dist < 5 * this.type.scale) {
                            const now = performance.now();
                            if (now - this.lastAttack > CONFIG.botAttackCooldown) {
                                this.lastAttack = now;
                                spawnSlash(this.mesh);
                                AudioSys.playSlash(this.mesh.position);
                                // Zero-Alloc Lunge
                                _aiDir.subVectors(playerPos, this.mesh.position).normalize();
                                _aiDir.y = 0; _aiDir.normalize();
                                
                                const lungeForce = 25 + (this.type.scale * 5);
                                this.velocity.addScaledVector(_aiDir, lungeForce);
                                
                                const hitChance = 1.05 - (this.type.scale * 0.1);
                                if (Math.random() < hitChance) {
                                    if (now - this.lastHitTime > 2000) this.streak = 0;
                                    let dmg = Math.min((CONFIG.botDamage * this.type.scale) + (this.streak * 2), 40);
                                    this.streak++;
                                    this.lastHitTime = now;
                                    damagePlayer(dmg);
                                } else {
                                    AudioSys.playMiss();
                                    this.streak = 0;
                                }
                            }
                        }
                    } else {
                        dest = this.lastKnownPos;
                        if (this.mesh.position.distanceTo(dest) < 3) {
                            this.state = 'SEARCH';
                            this.searchTimer = 3000;
                            this.body.material.color.setHex(0xffaa00);
                        }
                    }
                } else if (this.state === 'SEARCH') {
                    speed = 0;
                    this.searchTimer -= dt * 1000;
                    if (this.canSeePlayer(playerPos)) {
                        this.state = 'AGGRO';
                        this.body.material.color.setHex(0x8b0000);
                        this.reactionTimer = CONFIG.botAggroDelay;
                    } else if (this.searchTimer <= 0) {
                        this.state = 'ROAM';
                        this.body.material.color.setHex(this.type.color);
                        this.pickRoamTarget();
                    }
                }

                this.actionTimer -= dt;
                if (this.actionTimer <= 0) {
                    this.actionTimer = 0.5 + Math.random() * 1.5;
                    let sprintChance = (this.type.skill >= 2 ? 0.7 : 0.3);
                    let slideChance = (this.type.skill >= 2 ? 0.4 : 0.1);
                    this.isSprinting = Math.random() < sprintChance;
                    const wantsToSlide = this.isSprinting && Math.random() < slideChance;
                    if (wantsToSlide && !this.wasSliding) AudioSys.playBotSlide(this.mesh.position);
                    this.isSliding = wantsToSlide;
                    this.wasSliding = wantsToSlide;
                }

                // --- Intent Calculation ---
                this.currentMoveSpeed = 0;

                if (this.type.speedMod !== 0 && this.state !== 'SEARCH' && this.state !== 'CONFUSED') {
                    // Reuse _aiFwd as the 'move direction' accumulator
                    _aiFwd.subVectors(dest, this.mesh.position);
                    _aiFwd.y = 0; _aiFwd.normalize();
                    _aiDir.copy(_aiFwd); // Save clean destination dir

                    if (this.state === 'AGGRO' && !this.isRetreating) {
                        _aiDir.subVectors(playerPos, this.mesh.position);
                        _aiDir.y = 0; _aiDir.normalize();
                    }

                    if (this.state === 'AGGRO' && !this.isRetreating && this.canSeePlayer(playerPos)) {
                        const dist = this.mesh.position.distanceTo(playerPos);
                        if (this.dodgeTimer <= 0) {
                            camera.getWorldDirection(_aiTemp); // Recycle temp for player look dir
                            _aiTemp.y = 0; _aiTemp.normalize();
                            
                            _tempB.subVectors(this.mesh.position, playerPos).normalize(); // To Bot
                            
                            if (_aiTemp.dot(_tempB) > 0.9 && player.velocity.length() > 10) {
                                if (this.dodgeReactionTimer <= 0) this.dodgeReactionTimer = getBotReactionTime(this) / 1000;
                            }
                        }
                        if (this.dodgeReactionTimer > 0 && this.dodgeReactionTimer <= dt && this.dodgeTimer <= 0) {
                            this.strafeDir *= -1;
                            this.dodgeTimer = 1.0;
                            this.dodgeReactionTimer = 0;
                        }
                        if (this.strafeTimer <= 0) {
                            this.strafeDir *= -1;
                            this.strafeTimer = 1.5 + Math.random() * 2.0;
                        }
                        const idealRange = 1.5 + (3.0 * this.type.scale);
                        if (dist < 15 + (10 * this.type.scale)) {
                            // Orbit Vector: (-Z, X)
                            _tempA.set(-_aiFwd.z, 0, _aiFwd.x).multiplyScalar(this.strafeDir);
                            
                            if (dist > idealRange) {
                                _aiFwd.addScaledVector(_tempA, 0.8).normalize();
                            } else if (dist < idealRange - 2) {
                                _aiFwd.multiplyScalar(-0.5).addScaledVector(_tempA, 1.0).normalize();
                            } else {
                                const attackReady = (performance.now() - this.lastAttack > CONFIG.botAttackCooldown);
                                if (attackReady) _aiFwd.addScaledVector(_tempA, 0.2).normalize();
                                else _aiFwd.multiplyScalar(0.4).addScaledVector(_tempA, 0.8).normalize();
                            }
                            
                            _aiTemp.copy(this.mesh.position).addScaledVector(_aiFwd, 2.0);
                            if (!this.onGroundSafe(getGroundHeight(_aiTemp.x, _aiTemp.z))) {
                                if (this.ledgeTimer <= 0) {
                                    this.strafeDir *= -1;
                                    this.ledgeTimer = 0.5;
                                }
                            }
                        }
                    }

                    _aiFwd.normalize();
                    if (this.isSliding) speed *= 1.5;

                    if (this.state === 'ROAM' && this.onGroundSafe(groundY)) {
                        _aiTemp.copy(this.mesh.position).addScaledVector(_aiFwd, 2.0);
                        if (getGroundHeight(_aiTemp.x, _aiTemp.z) < groundY - 3) {
                            speed = 0;
                            if (this.state === 'ROAM') this.pickRoamTarget();
                            else this.velocity.set(0, 0, 0);
                        }
                    }

                    this.currentMoveDir.copy(_aiFwd);
                    this.currentMoveSpeed = speed;

                    let lookDir = _aiFwd;
                    if (this.state === 'AGGRO' && !this.isRetreating) lookDir = _aiDir;
                    
                    if (lookDir.lengthSq() > 0.1) {
                        this.targetRotation = Math.atan2(lookDir.x, lookDir.z);
                    }

                    // Anti-Stuck
                    if (speed > 0.5) {
                        const dx = this.mesh.position.x - this.lastPos.x;
                        const dz = this.mesh.position.z - this.lastPos.y;
                        if (Math.sqrt(dx*dx + dz*dz) < speed * dt * 0.1) {
                            if (this.state === 'ROAM') {
                                this.targetRotation += Math.PI / 2; // Simple rotation instead of vector alloc
                            } else if (this.state === 'AGGRO') {
                                this.strafeDir *= -1;
                            }
                        }
                    }
                    this.lastPos.set(this.mesh.position.x, this.mesh.position.z);
                }

                if (this.isSliding) {
                    if (currentTheme === 0 && Math.random() < 0.3 * intervalMultiplier) spawnSnowTrail(this.mesh.position);
                }
            }

            updatePhysics(dt, distSq) {
                // Visuals
                if (this.state === 'AGGRO') this.eyeMat.color.setHex(0xff0000);
                else if (this.state === 'SEARCH') this.eyeMat.color.setHex(0xffaa00);
                else this.eyeMat.color.setHex(this.type.eye);

                // Dead State
                if (this.isDeadCorpse) {
                    this.corpseTimer -= dt;
                    this.mesh.rotation.x = Math.PI / 2;
                    this.mesh.position.y = this.lastGroundHeight + 0.5;
                    this.body.material.opacity = this.corpseTimer / 3.0;
                    this.body.material.transparent = true;
                    this.eyeMat.opacity = this.corpseTimer / 3.0;
                    this.eyeMat.transparent = true;
                    if (this.corpseTimer <= 0) {
                        this.remove();
                    }
                    return;
                }

                // Confused State
                if (this.state === 'CONFUSED') {
                    this.confusedTimer -= dt;
                    this.mesh.rotation.x = -Math.PI / 2;
                    this.mesh.position.y = this.lastGroundHeight + 0.5;
                    if (this.confusedTimer <= 0) {
                        this.state = this.hasAggroed ? 'AGGRO' : 'ROAM';
                        this.mesh.rotation.x = 0;
                    }
                    this.healthBarGroup.position.copy(this.mesh.position).add(new THREE.Vector3(0, 1.0 * this.type.scale, 0));
                    return;
                }

                // Gravity & Ground Physics
                const groundY = this.lastGroundHeight;
                const floorThreshold = groundY + (1 * this.type.scale);

                if (this.mesh.position.y > floorThreshold + 0.1) {
                    this.velocity.y -= CONFIG.gravity * dt;

                    // Fall Recovery Jump (Double Jump logic)
                    let jumpChance = 0.05;
                    if (this.isRetreating && (this.health / this.maxHealth) < 0.3) jumpChance = 0.3;
                    if (this.velocity.y < -8 && this.jumps < 2 && Math.random() < jumpChance * dt * 60) {
                        this.performJump(0.9); // Air recovery (approx 18 force)
                    }
                } else {
                    // Fall Damage / Confused Check
                    if (this.velocity.y < -22) {
                        let shouldFall = true;
                        if (this.state === 'AGGRO') {
                            if (Math.random() < 0.9) shouldFall = false;
                        }
                        if (shouldFall) {
                            this.state = 'CONFUSED';
                            const impactSpeed = Math.abs(this.velocity.y);
                            this.confusedTimer = 3.0 + Math.min(2.0, (impactSpeed - 22) / 5.0);
                            this.velocity.y = 0;
                            return;
                        }
                    }
                    this.velocity.y = 0;
                    this.mesh.position.y = floorThreshold;
                    this.jumps = 0;
                }

                // Rotation Smoothing
                if (this.state === 'SEARCH') {
                    const lookTime = performance.now() * 0.002;
                    this.mesh.rotation.y = Math.sin(lookTime) * Math.PI;
                } else {
                    let rotDiff = this.targetRotation - this.mesh.rotation.y;
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                    this.mesh.rotation.y += rotDiff * dt * 8;
                }

                if (this.isSliding) this.mesh.rotation.x = 0.5;
                else if (this.state !== 'CONFUSED') this.mesh.rotation.x = 0;

                // Move Execution
                if (this.currentMoveSpeed > 0) {
                    this.mesh.position.addScaledVector(this.currentMoveDir, this.currentMoveSpeed * dt);
                }
                this.mesh.position.addScaledVector(this.velocity, dt);

                // Drag
                const drag = Math.exp(-2.0 * dt);
                this.velocity.x *= drag;
                this.velocity.z *= drag;

                // UI Updates
                this.healthBarGroup.position.copy(this.mesh.position).add(new THREE.Vector3(0, 1.3 * this.type.scale, 0));
                this.healthBarGroup.lookAt(camera.position);
                if (this.hasAggroed) {
                    this.healthBarGroup.visible = true;
                    this.healthBar.scale.x = Math.max(0, this.health / this.maxHealth);
                }

                // Collision Bounds & Resolution
                const isNear = distSq < 2500;
                if (isNear) {
                    _box3_1.setFromObject(this.body);
                } else {
                    const p = this.mesh.position;
                    const s = this.type.scale;
                    _box3_1.min.set(p.x - 0.5 * s, p.y, p.z - 0.5 * s);
                    _box3_1.max.set(p.x + 0.5 * s, p.y + 2 * s, p.z + 0.5 * s);
                }

                const botBox = _box3_1;

                if (spatialGrid) {
                    const nearbyWalls = spatialGrid.query(botBox);

                    for (const wb of nearbyWalls) {
                        if (wb.mesh.userData.isFloor) continue;
                        if (this.mesh.position.y >= wb.box.max.y - 0.5) continue;

                        if (botBox.intersectsBox(wb.box)) {
                            const xOverlap = Math.min(botBox.max.x - wb.box.min.x, wb.box.max.x - botBox.min.x);
                            const zOverlap = Math.min(botBox.max.z - wb.box.min.z, wb.box.max.z - botBox.min.z);

                            const wallX = wb.mesh.matrixWorld.elements[12];
                            const wallZ = wb.mesh.matrixWorld.elements[14];

                            if (xOverlap < zOverlap) {
                                const sign = (this.mesh.position.x < wallX) ? -1 : 1;
                                this.mesh.position.x += xOverlap * sign;
                            } else {
                                const sign = (this.mesh.position.z < wallZ) ? -1 : 1;
                                this.mesh.position.z += zOverlap * sign;
                            }
                        }
                    }
                }
            }

            onGroundSafe(groundY) {
                return Math.abs(this.mesh.position.y - (groundY + this.type.scale)) < 0.5;
            }

            takeHit(amt) {
                if (this.isDeadCorpse || this.state === 'CONFUSED') {
                    if (this.state === 'CONFUSED') {
                        amt *= 2;
                        if (this.health < this.maxHealth * 0.3) {
                            this.state = 'AGGRO';
                            this.confusedTimer = 0;
                            this.mesh.rotation.x = 0;
                            this.isRetreating = true;
                            this.performJump(0.75); // Stun recovery jump (approx 15 force)
                            this.jumps = 1;
                        }
                    }
                }
                amt *= this.type.dmgRed;
                this.health -= amt;
                this.lastDamageTime = performance.now();
                this.body.material.color.setHex(0xffffff);
                setTimeout(() => {
                    if (!this.isDeadCorpse && this.state !== 'CONFUSED') {
                        if (currentTheme === 2) {
                            this.body.material.color.setHex(0x000000);
                        } else {
                            if (this.state === 'SEARCH') this.body.material.color.setHex(0xffaa00);
                            else if (this.state === 'AGGRO') this.body.material.color.setHex(0x8b0000);
                            else this.body.material.color.setHex(this.type.color);
                        }
                    }
                }, 100);
                if (this.state !== 'AGGRO' && this.state !== 'CONFUSED') {
                    this.state = 'AGGRO';
                    this.reactionTimer = CONFIG.botAggroDelay;
                    this.hasAggroed = true;
                }
                if (this.health <= 0) {
                    addScore(1000 * this.type.scale);
                    GameStats.botKills++;
                    GameStats.checkKillMilestone();
                    spawnParticles(this.mesh.position, 0x8b0000, 20 * this.type.scale);
                    AudioSys.playHit(this.mesh.position);
                    let shouldSplit = false;
                    let nextType = BOT_TYPES.NORMAL;
                    let roll = Math.random();
                    if (this.type.name === "COLOSSUS") {
                        if (roll < 0.90) {
                            shouldSplit = true;
                            nextType = BOT_TYPES.TITAN;
                        }
                    } else if (this.type.name === "TITAN") {
                        if (roll < 0.70) {
                            shouldSplit = true;
                            nextType = BOT_TYPES.BRUTE;
                        }
                    } else if (this.type.name === "BRUTE") {
                        if (roll < 0.40) {
                            shouldSplit = true;
                            nextType = BOT_TYPES.NORMAL;
                        }
                    }
                    if (!shouldSplit) {
                        this.isDeadCorpse = true;
                        this.corpseTimer = 3.0;
                        this.healthBarGroup.visible = false;
                        this.outline.visible = false;
                        showKillMessage("THREAT NEUTRALIZED");
                    } else {
                        const count = Math.random() > 0.5 ? 2 : 1;
                        const delays = [0.2, 0.5];
                        for (let i = 0; i < count; i++) {
                            new Enemy(this.mesh.position, nextType, 'AGGRO', delays[i], WorldManager.current);
                        }
                        showKillMessage(this.type.name + " SPLIT!");
                        this.remove();
                    }
                }
            }

            remove() {
                if (this.mesh.parent) {
                    this.mesh.parent.remove(this.mesh);
                }
                if (this.healthBarGroup.parent) {
                    this.healthBarGroup.parent.remove(this.healthBarGroup);
                }
                const idx = enemies.indexOf(this);
                if (idx > -1) enemies.splice(idx, 1);
            }
        }
        
        function damagePlayer(amt) {
            player.health -= amt;
            player.lastDamageTime = performance.now();
            const overlay = document.getElementById('damage-overlay');
            overlay.style.background = "radial-gradient(circle, transparent 20%, rgba(255,0,0,0.6) 100%)";
            setTimeout(() => {
                overlay.style.background = "radial-gradient(circle, transparent 50%, rgba(255,0,0,0.0) 100%)";
            }, 200);
            if(player.health <= 0) {
                if (player.extraLives > 0) {
                    player.extraLives--;
                    player.health = CONFIG.playerMaxHP; 
                    showKillMessage("EXTRA LIFE USED!", "achievement", "#00ff00");
                    AudioSys.playTeleport(); 
                    updateLivesDisplay();
                } else {
                    player.health = 0;
                    player.isDead = true;
                    document.exitPointerLock();
                    showKillMessage("TERMINATED", "achievement");
                    const diff = Date.now() - sessionStartTime;
                    const mins = Math.floor(diff / 60000);
                    const secs = Math.floor((diff % 60000) / 1000);
                    document.getElementById('session-timer').innerText = `Session Time: ${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;
                }
            }
        }
        
        function updateLivesDisplay() {
            const el = document.getElementById('lives-display');
            if (player.extraLives > 0) {
                let hearts = "";
                for(let i=0; i<player.extraLives; i++) hearts += " ";
                el.innerText = hearts;
            } else {
                el.innerText = "";
            }
        }
        
        function addScore(amt) {
            const oldScore = player.score;
            player.score += amt;
            document.getElementById('score-display').innerText = "SCORE: " + player.score;
            if (Math.floor(player.score / 10000) > Math.floor(oldScore / 10000)) {
                if (player.extraLives < 3) {
                    player.extraLives++;
                    showKillMessage("EXTRA LIFE EARNED!", "achievement", "#00ff00");
                    updateLivesDisplay();
                }
            }
        }

        function resetGame() {
            player.health = CONFIG.playerMaxHP;
            player.energy = CONFIG.energyMax; 
            player.score = 0;
            player.extraLives = 0;
            player.isDead = false;
            player.isSliding = false;
            player.isCrouching = false;
            player.velocity.set(0,0,0);
            player.totalHits = 0; 
            camera.position.set(0, 2, 0);
            
            lastCenturyMarked = 0;
            bankedActiveTime = 0;
            totalBreakTime = 0;
            breakCount = 0;
            lastSegmentDuration = 0;
            segmentStartTime = performance.now();
            
            updateLivesDisplay();
            
            // Wipe Active World Enemies
            for(let i=enemies.length-1; i>=0; i--) enemies[i].remove();
            enemies.length = 0;
            
            particles.forEach(p => {
                scene.remove(p.mesh);
                p.mesh.geometry.dispose();
                p.mesh.material.dispose();
            });
            particles.length = 0;
            
            projectiles.forEach(p => {
                scene.remove(p.mesh);
                p.mesh.geometry.dispose();
                p.mesh.material.dispose();
            });
            projectiles.length = 0;
            
            GameStats.reset();
            comboCount = 0;
            updateComboUI();
            document.getElementById('score-display').innerText = "SCORE: 0";
            document.getElementById('health-fill').classList.remove('health-critical');
            document.getElementById('low-health-vignette').style.boxShadow = "inset 0 0 100px rgba(255, 0, 0, 0)";

            // FIX: Remove inline shadow override and use opacity
            const vig = document.getElementById('low-health-vignette');
            vig.style.boxShadow = ""; 
            vig.style.opacity = "0";
        }
        
        function showKillMessage(text, type="", color=null) {
            const feed = document.getElementById('kill-feed');
            const msg = document.createElement('div');
            msg.className = "kill-msg " + type;
            msg.innerHTML = text; 
            if(color) {
                msg.style.color = color;
                msg.style.borderLeftColor = color;
            }
            feed.prepend(msg);
            if(feed.children.length > 6) feed.removeChild(feed.lastChild);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const dt = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;
            frameCounter++;
            
            if(showFPS) {
                fpsFrames++;
                if(now > lastFpsTime + 1000) {
                    document.getElementById('fps-display').innerHTML = '<div class="fps-inner">FPS: ' + fpsFrames + '</div>';
                    fpsFrames = 0;
                    lastFpsTime = now;
                }
            }
            
            if (isLocked && !player.isDead) {
                const cap = WorldManager.current ? WorldManager.current.config.bots : 60;
                
                if (Math.random() < 0.05 && enemies.length < cap) {
                    new Enemy(null, null, 'ROAM', 0, WorldManager.current);
                }
                
                // Logic Phase
                player.update(dt);
                NarrativeSys.update(dt);

                const currentWorld = WorldManager.current;
                if (currentWorld && currentWorld.moonBox) {
                    const dist = camera.position.distanceTo(currentWorld.moonBox.position);
                    currentWorld.moonBox.material.opacity = (dist < 80) ? 0.3 : 0;
                }

                updateWeather(dt);
                for(let p of portals) p.update(dt);
                
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    projectiles[i].update(dt);
                    if (!projectiles[i].active) projectiles.splice(i, 1);
                }
                
                const playerPos = camera.position;
                for (let i = enemies.length - 1; i >= 0; i--) {
                    enemies[i].update(dt, playerPos);
                }

                // --- VISUAL POOL UPDATES ---
                // 1. Particles (Sparks, Smoke, Clouds)
                for (let i = 0; i < 800; i++) {
                    const p = _particlePool[i];
                    if (!p.active) continue;

                    p.life -= dt;
                    if (p.life <= 0) {
                        p.active = false;
                        p.mesh.visible = false;
                        continue;
                    }

                    if (p.type === 'flash') {
                        const progress = 1.0 - (p.life / p.maxLife); 
                        p.mesh.material.opacity = 1.0 - progress;
                        p.mesh.scale.setScalar(THREE.MathUtils.lerp(p.scaleStart, p.scaleEnd, progress));
                    } 
                    else if (p.type === 'spark') {
                        p.velocity.y -= p.gravity * dt; 
                        p.mesh.position.addScaledVector(p.velocity, dt);
                        p.mesh.scale.setScalar(p.life * 2.0); 
                    }
                    else if (p.type === 'static') {
                         p.mesh.position.addScaledVector(p.velocity, dt);
                         p.mesh.scale.setScalar(p.life * 2); 
                         p.mesh.material.opacity = p.targetOpacity || 1.0; 
                    } 
                    else if (p.type === 'snow-trail') {
                         p.mesh.material.opacity = p.life * 0.4; 
                    } 
                }

                // 2. Ripples (Impact Rings)
                for (let i = 0; i < 50; i++) {
                    const r = _ripplePool[i];
                    if (!r.active) continue;

                    r.life -= dt;
                    if (r.life <= 0) {
                        r.active = false;
                        r.mesh.visible = false;
                        continue;
                    }

                    const progress = 1.0 - (r.life / r.maxLife);
                    const ease = 1 - Math.pow(1 - progress, 3); 
                    // RESTORE: Original layered scale math
                    const finalScale = (1 + ease) * (r.scaleOffset || 1.0);
                    r.mesh.scale.setScalar(finalScale);
                    r.mesh.material.opacity = (1.0 - ease) * 0.1;
                }

                // 3. Slashes (Melee FX)
                let isSlashActive = false;
                for (let i = 0; i < 20; i++) {
                    const s = _slashPool[i];
                    if (!s.active) continue;

                    // FIX: Scale fade by dt to make it frame-rate independent and slower
                    // 2.5 is the tuned multiplier to match the original 'feel'
                    s.mesh.material.opacity -= s.fadeSpeed * dt * 30;
                    
                    if (s.isHit) s.mesh.scale.multiplyScalar(1.05);

                    if (s.mesh.material.opacity <= 0) {
                        s.active = false;
                        s.mesh.visible = false;
                        if (s.mesh.parent) s.mesh.parent.remove(s.mesh);
                    } else {
                        if (s.mesh.parent === camera) isSlashActive = true;
                    }
                }
                slashActive = isSlashActive;

                

                // UI & State Phase
                if (comboCount > 0) {
                    comboTimer -= dt;
                    if (comboTimer <= 0) {
                        comboCount = 0;
                        updateComboUI();
                    }
                }
                
                const hpPct = Math.max(0, player.health / (CONFIG.playerMaxHP/100)); 
                const enPct = Math.max(0, (player.energy / CONFIG.energyMax) * 100);
                document.getElementById('health-fill').style.width = hpPct + '%';
                document.getElementById('energy-fill').style.width = enPct + '%';
                
                const btn = document.getElementById('start-btn');
                if (btn.innerText === "b r e a t h e" && isLocked) {
                     btn.innerText = "ENTER ARENA";
                     btn.style.opacity = 1;
                     btn.style.letterSpacing = "2px";
                }
            }
            Minimap.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
