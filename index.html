<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Blade: Melee Arena v44.22e</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; transition: background-color 0.5s; }
        
        /* --- CYBERPUNK HUD (Compact) --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 32px; height: 32px;
            transform: translate(-50%, -50%) rotate(22.5deg); 
            opacity: 1; transition: opacity 0.1s;
            z-index: 5;
        }
        #crosshair svg { width: 100%; height: 100%; filter: drop-shadow(0 0 4px rgba(51, 204, 255, 0.8)); }

        /* Top HUD */
        #hud-top { 
            padding: 15px; display: flex; justify-content: space-between; align-items: flex-start;
        }
        .hud-panel {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #33ccff;
            padding: 6px 15px;
            color: #fff;
            font-family: 'Arial Black', sans-serif;
            font-style: italic;
            transform: skewX(-15deg);
            box-shadow: 0 0 5px rgba(51, 204, 255, 0.2);
            backdrop-filter: blur(4px);
        }
        .hud-panel-content { transform: skewX(15deg); }

        #score-display { font-size: 1.2rem; color: #33ccff; text-shadow: 2px 2px 0px rgba(0,0,0,0.8); }
        #mode-display { font-size: 0.7rem; color: #aaa; letter-spacing: 1px; }

        /* Bottom HUD */
        #hud-bottom { 
            padding: 25px; display: flex; gap: 20px; align-items: flex-end; 
        }
        
        .stat-group {
            display: flex; flex-direction: column; gap: 5px;
        }
        .stat-header {
            display: flex; align-items: center; gap: 10px; margin-left: 5px;
        }
        .stat-label {
            font-family: 'Arial Black', sans-serif; font-size: 0.8rem; color: white;
            text-transform: uppercase; letter-spacing: 1px;
            text-shadow: 1px 1px 0 #000;
        }
        #lives-display {
            color: #ff3333; font-size: 1rem; text-shadow: 0 0 5px #ff0000;
        }
        
        .bar-frame {
            width: 250px; height: 18px;
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.2);
            transform: skewX(-20deg);
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .bar-fill {
            height: 100%; width: 100%;
            transition: width 0.1s linear;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        #health-fill { background: linear-gradient(90deg, #cc0000, #ff3333); box-shadow: 0 0 10px #ff3333; transition: all 0.1s; }
        #stamina-fill { background: linear-gradient(90deg, #0066cc, #33ccff); box-shadow: 0 0 10px #33ccff; }
        
        .health-critical {
            animation: pulse-red 0.5s infinite alternate;
        }
        
        @keyframes pulse-red {
            from { box-shadow: 0 0 10px #ff0000; filter: brightness(1); }
            to { box-shadow: 0 0 25px #ff0000; filter: brightness(1.5); }
        }

        /* Ability Icon */
        .ability-group { margin-left: auto; transform: skewX(-10deg); }
        .ability-icon { 
            width: 60px; height: 60px;
            border: 1px solid #fff; 
            background: rgba(0,0,0,0.6);
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center; 
            font-weight: bold; color: white; 
            transition: 0.2s;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .ability-icon-inner { transform: skewX(10deg); text-align: center; }
        .ability-icon.active { 
            border-color: #00ffaa; box-shadow: 0 0 15px #00ffaa; color: #00ffaa; 
            background: rgba(0, 255, 170, 0.1);
        }
        .ability-key { font-size: 1.4rem; font-family: 'Arial Black', sans-serif; }
        .ability-name { font-size: 0.6rem; letter-spacing: 1px; opacity: 0.8; }

        /* MENUS */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 10, 20, 0.95); display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: white; z-index: 10;
            pointer-events: auto; backdrop-filter: blur(5px);
            background-image: 
                linear-gradient(rgba(51, 204, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(51, 204, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
        }
        
        #start-content {
            display: flex; flex-direction: column; align-items: center;
            padding: 50px 60px;
            background: linear-gradient(135deg, rgba(10,20,30,0.95), rgba(5,10,15,0.95));
            clip-path: polygon(
                30px 0, 100% 0, 
                100% calc(100% - 30px), calc(100% - 30px) 100%, 
                0 100%, 0 30px
            );
            position: relative;
            max-width: 900px; width: 80%;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        #start-content::after {
            content: ''; position: absolute; top:0; left:0; width:100%; height:100%;
            box-shadow: inset 0 0 0 2px rgba(51, 204, 255, 0.3);
            pointer-events: none;
            clip-path: polygon(30px 0, 100% 0, 100% calc(100% - 30px), calc(100% - 30px) 100%, 0 100%, 0 30px);
        }

        h1 { 
            font-size: 5rem; margin: 0 0 10px 0; color: #fff; 
            text-shadow: 4px 4px 0px #33ccff; 
            font-style: italic; text-transform: uppercase; letter-spacing: -2px;
            font-family: 'Arial Black', sans-serif;
        }

        #player-title-display {
            font-size: 2rem; color: #aaa; margin-bottom: 20px;
            text-transform: uppercase; letter-spacing: 4px; font-weight: 300;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
            text-align: center;
        }
        
        p { font-size: 1.1rem; color: #aaa; margin-top: 5px; text-align: center; line-height: 1.5; font-family: monospace; }
        
        .btn-row { display: flex; gap: 20px; margin-top: 40px; width: 100%; justify-content: center; }
        
        .btn {
            padding: 25px 60px; background: #33ccff; border: none;
            color: #000; font-size: 2rem; cursor: pointer; transition: all 0.5s; 
            font-weight: 900; text-transform: uppercase; letter-spacing: 2px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            position: relative; overflow: hidden;
            pointer-events: auto; min-width: 300px;
            font-family: 'Arial Black', sans-serif;
        }
        .btn::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
            transition: 0.5s;
        }
        .btn:hover::before { left: 100%; }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 40px #33ccff; color: white; background: #000; border: 2px solid #33ccff; }
        
        .btn-secondary { 
            padding: 12px 24px; font-size: 1rem; background: transparent; 
            border: 1px solid #555; color: #888; pointer-events: auto;
            font-family: 'Segoe UI', sans-serif; font-weight: bold; text-transform: uppercase;
            transition: 0.2s;
        }
        .btn-secondary:hover { border-color: #fff; color: #fff; background: rgba(255,255,255,0.1); }

        #stats-container {
            margin-top: 30px; width: 100%; display: grid; 
            grid-template-columns: 1fr 1fr; gap: 40px;
            border-top: 1px solid rgba(255,255,255,0.1); padding-top: 30px;
        }
        .stat-box { text-align: left; }
        .stat-title { color: #33ccff; font-size: 1rem; font-weight: bold; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
        .stat-value { color: #fff; font-size: 0.9rem; font-family: monospace; line-height: 1.6; opacity: 0.8; }

        #kill-feed { position: absolute; top: 100px; left: 20px; text-align: left; display: flex; flex-direction: column; gap: 4px; }
        .kill-msg { 
            color: white; font-size: 13px; font-weight: bold; 
            text-shadow: 1px 1px 0px rgba(0,0,0,0.5); 
            animation: fadeOut 5s forwards; 
            border-left: 3px solid #fff; padding-left: 8px; 
            background: linear-gradient(90deg, rgba(0,0,0,0.6), transparent);
            font-family: 'Arial Black', sans-serif; font-style: italic;
            padding-top: 2px; padding-bottom: 2px;
        }
        .kill-msg.combo { border-left-color: #ffcc00; color: #ffcc00; font-size: 12px; }
        .kill-msg.achievement { border-left-color: #ff00ff; color: #ff00ff; font-size: 14px; text-shadow: 0 0 8px #ff00ff; }

        .slick-streak {
            font-family: 'Segoe UI', sans-serif; font-weight: 300; font-style: normal; margin-left: 4px;
        }

        @keyframes fadeOut { 0% { opacity: 1; transform: translateX(0); } 80% { opacity: 1; } 100% { opacity: 0; transform: translateX(-30px); } }

        #combo-display {
            position: absolute; top: 10%; left: 50%; transform: translateX(-50%);
            color: #ffcc00; font-family: 'Arial Black', sans-serif;
            text-shadow: 4px 4px 0px rgba(0,0,0,0.5); display: none; 
            text-align: center; font-style: italic; z-index: 5;
            transition: all 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            white-space: nowrap; 
        }

        #meme-overlay {
            position: absolute; top: -60px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 16px; padding: 12px 24px;
            color: #fff; font-family: 'Segoe UI', sans-serif; font-weight: 500; font-size: 2rem;
            white-space: nowrap; display: none;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 10;
        }

        @keyframes popIn { 0% { transform: translateX(-50%) scale(0); opacity: 0; } 100% { transform: translateX(-50%) scale(1); opacity: 1; } }

        #session-timer {
            position: absolute; bottom: 15px; right: 20px;
            font-family: monospace; font-size: 0.8rem; color: #666;
            opacity: 0.5; display: none;
        }

        #damage-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: radial-gradient(circle, transparent 50%, rgba(255,0,0,0.0) 100%);
            pointer-events: none; transition: background 0.1s;
        }

        #low-health-vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 100px rgba(255, 0, 0, 0);
            pointer-events: none;
            transition: box-shadow 0.3s ease-in-out;
        }

        /* Light Theme Adjustments for HUD */
        .light-theme .hud-panel { background: rgba(255,255,255,0.7); border-color: #0088ff; color: #000; }
        .light-theme #score-display { color: #0066cc; text-shadow: none; }
        .light-theme .stat-label { color: #333; text-shadow: none; }
        .light-theme .bar-frame { border-color: rgba(0,0,0,0.2); background: rgba(255,255,255,0.5); }
        .light-theme .ability-icon { border-color: #0066cc; background: rgba(255,255,255,0.6); color: #0066cc; }
    </style>
</head>
<body>

    <div id="damage-overlay"></div>
    <div id="low-health-vignette"></div>

    <div id="ui-layer" class="light-theme">
        <div id="hud-top">
            <div class="hud-panel">
                <div class="hud-panel-content">
                    <span id="score-display">SCORE: 0</span>
                </div>
            </div>
            <div class="hud-panel" style="border-color: #aaa;">
                <div class="hud-panel-content" id="mode-display">PRESS 'T' TO CYCLE THEME</div>
            </div>
        </div>
        
        <div id="combo-wrapper" style="position:absolute; top:10%; left:50%; width:0; height:0;">
            <div id="meme-overlay">nice.</div>
            <div id="combo-display">2 HITS</div>
        </div>

        <div id="kill-feed"></div>
        
        <div id="crosshair">
            <svg viewBox="0 0 100 100" fill="currentColor">
                <path d="M50,5 Q10,50 50,95 Q30,50 50,5 Z" />
            </svg>
        </div>
        
        <div id="hud-bottom">
            <div class="stat-group">
                <div class="stat-header">
                    <span class="stat-label">HEALTH</span>
                    <span id="lives-display"></span>
                </div>
                <div class="bar-frame"><div id="health-fill" class="bar-fill"></div></div>
            </div>
            <div class="stat-group">
                <span class="stat-label">STAMINA</span>
                <div class="bar-frame"><div id="stamina-fill" class="bar-fill"></div></div>
            </div>
            <div class="ability-group">
                <div class="ability-icon" id="icon-q">
                    <div class="ability-icon-inner">
                        <div class="ability-key">Q</div>
                        <div class="ability-name" id="tp-label">AIM</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <div id="start-content">
            <h1 id="game-title">NEON BLADE</h1>
            <div id="player-title-display"></div>
            <p>
                <strong>WASD</strong> Move | <strong>SPACE</strong> Jump | <strong>SHIFT</strong> Sprint<br>
                <strong>C</strong> Slide/Crouch | <strong>Q</strong> Teleport | <strong>HOLD M1</strong> Auto Strike
            </p>
            
            <div class="btn-row">
                <button class="btn" id="start-btn">ENTER ARENA</button>
            </div>
            
            <div id="stats-container">
                <div class="stat-box">
                    <div class="stat-title">Current Session</div>
                    <div class="stat-value" id="stat-session">
                        Highest Combo: 0<br>
                        Score: 0
                    </div>
                </div>
                <div class="stat-box">
                    <div class="stat-title">Style Matrix</div>
                    <div class="stat-value" id="stat-moves">
                        <!-- Dynamically filled -->
                    </div>
                </div>
            </div>

            <div id="session-timer">Session Time: 00:00</div>

            <div class="btn-row" style="margin-top: 30px; gap: 15px;">
                <button class="btn-secondary" id="tp-mode-btn">TP MODE: AIM</button>
                <button class="btn-secondary" id="theme-btn">THEME: LIGHT</button>
            </div>
            <p style="font-size: 0.8rem; margin-top: 30px; opacity: 0.5;">PRESS ESC TO PAUSE</p>
            <div style="margin-top: 8px; font-size: 0.65rem; color: #555; font-family: monospace; letter-spacing: 1px;">NEON BLADE: MELEE ARENA v44.22e</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            baseSpeed: 14,
            crouchSpeed: 6,
            sprintSpeed: 28,
            
            jumpForce: 24,
            wallJumpForce: 22,
            wallPushForce: 10, 
            gravity: 40,
            
            frictionGround: 6.0, 
            frictionAir: 0.02, 
            airControl: 1.0,  
            frictionSlide: 1.2, 
            slideBoost: 18, 
            bunnyHopBoost: 7.5,
            
            staminaMax: 100,
            staminaDrain: 25, 
            staminaRegen: 15,
            teleportCost: 10,
            
            attackRange: 8,
            attackCooldown: 250,
            playerDamage: 40, 
            
            teleportRange: 20,

            botBaseHP: 100,
            botDamage: 10, 
            botAttackCooldown: 1500,
            botSpeed: 10,
            botSprintSpeed: 18, 
            botRoamSpeed: 6,
            botAggroDuration: 10000, 
            botReactionDelay: 1000,
            
            regenDelay: 3000, 
            regenRate: 25
        };

        // --- GAME STATS ---
        const MASTERY_RANKS = [
            { count: 10, title: "NOVICE" },
            { count: 25, title: "APPRENTICE" },
            { count: 50, title: "ADEPT" },
            { count: 75, title: "EXPERT" },
            { count: 100, title: "MASTER" },
            { count: 150, title: "GRANDMASTER" },
            { count: 250, title: "LEGEND" },
            { count: 400, title: "DEMIGOD" },
            { count: 600, title: "GODLIKE" },
            { count: 1000, title: "OMNIPOTENT" }
        ];

        const MEME_TEXTS_69 = ["nice.", "yikwim ;)", "cultured.", "smooth.", "wink wink"];
        const MEME_TEXTS_420 = ["blaze it", "high score?", "chilled.", "smoke 'em", "cloud 9"];

        const GameStats = {
            highestCombo: 0,
            achievements: [],
            moves: {
                slideHit: 0,
                midAirHit: 0,
                longAirHit: 0,
                teleportHit: 0,
                wallJumpHit: 0
            },
            reset: function() {
                this.highestCombo = 0;
                this.achievements = [];
                for(let k in this.moves) this.moves[k] = 0;
            },
            addAchievement: function(name, color="#ff00ff") {
                if(!this.achievements.includes(name)) {
                    this.achievements.push(name);
                    showKillMessage(name, "achievement", color);
                } else {
                    showKillMessage(name, "achievement", color);
                }
            },
            checkMoveMilestone: function(key, name, color="#00ffff") {
                const count = this.moves[key];
                const rank = MASTERY_RANKS.find(r => r.count === count);
                
                if (rank) {
                    this.addAchievement(`${name} ${rank.title}`, color);
                }
            }
        };

        // --- AUDIO SYSTEM ---
        const AudioSys = {
            ctx: null,
            slideOsc: null,
            slideGain: null,
            
            init: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            
            playTone: function(freq, type, duration, vol=0.1, ramp='exp') {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                if(ramp === 'exp') gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                else gain.gain.linearRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            toggleSlideSound: function(active) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                if(active && !this.slideOsc) {
                    const bufferSize = this.ctx.sampleRate; 
                    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for(let i=0; i<bufferSize; i++) data[i] = Math.random()*2-1;

                    this.slideOsc = this.ctx.createBufferSource();
                    this.slideOsc.buffer = buffer;
                    this.slideOsc.loop = true;
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 400; 
                    this.slideGain = this.ctx.createGain();
                    this.slideGain.gain.setValueAtTime(0, t);
                    this.slideGain.gain.linearRampToValueAtTime(0.2, t + 0.2);
                    this.slideOsc.connect(filter);
                    filter.connect(this.slideGain);
                    this.slideGain.connect(this.ctx.destination);
                    this.slideOsc.start();
                } else if (!active && this.slideOsc) {
                    try {
                        this.slideGain.gain.linearRampToValueAtTime(0, t + 0.1);
                        this.slideOsc.stop(t + 0.1);
                    } catch(e) {}
                    this.slideOsc = null;
                    this.slideGain = null;
                }
            },

            playJump: function() { 
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(400, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            },

            playWallJump: function() {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            },

            playSlash: function() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc1 = this.ctx.createOscillator();
                osc1.type = 'triangle';
                osc1.frequency.setValueAtTime(1200, t); 
                osc1.frequency.exponentialRampToValueAtTime(200, t + 0.15);
                const g1 = this.ctx.createGain();
                g1.gain.setValueAtTime(0.25, t);
                g1.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                osc1.connect(g1); g1.connect(this.ctx.destination);
                osc1.start(); osc1.stop(t + 0.2);
            },
            
            playMiss: function() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const bSize = this.ctx.sampleRate * 0.1;
                const b = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const d = b.getChannelData(0);
                for(let i=0;i<bSize;i++) d[i] = Math.random()*2-1;
                const n = this.ctx.createBufferSource();
                n.buffer = b;
                const ng = this.ctx.createGain();
                ng.gain.setValueAtTime(0.1, t);
                ng.gain.exponentialRampToValueAtTime(0.001, t+0.1);
                const nf = this.ctx.createBiquadFilter();
                nf.type = 'lowpass';
                nf.frequency.value = 800;
                n.connect(nf); nf.connect(ng); ng.connect(this.ctx.destination);
                n.start();
            },

            playHit: function() { 
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const oscA = this.ctx.createOscillator();
                oscA.type = 'square';
                oscA.frequency.setValueAtTime(450, t);
                oscA.frequency.exponentialRampToValueAtTime(300, t+0.15);
                const oscB = this.ctx.createOscillator();
                oscB.type = 'square';
                oscB.frequency.setValueAtTime(680, t);
                oscB.frequency.exponentialRampToValueAtTime(500, t+0.15);
                const gainA = this.ctx.createGain();
                gainA.gain.setValueAtTime(0.1, t);
                gainA.gain.exponentialRampToValueAtTime(0.001, t+0.15);
                const gainB = this.ctx.createGain();
                gainB.gain.setValueAtTime(0.1, t);
                gainB.gain.exponentialRampToValueAtTime(0.001, t+0.15);
                oscA.connect(gainA); oscA.start(); oscA.stop(t+0.15);
                oscB.connect(gainB); oscB.start(); oscB.stop(t+0.15);
                gainA.connect(this.ctx.destination);
                gainB.connect(this.ctx.destination);
            },

            playTeleport: function() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.exponentialRampToValueAtTime(2000, t + 0.1);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(t + 0.2);
            },
            
            playHeartbeat: function(speed) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(60, t);
                osc.frequency.exponentialRampToValueAtTime(1, t + 0.1);
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.5, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(t + 0.15);
            },
            
            playUI: function(active) { this.playTone(active ? 800 : 400, 'sine', 0.05, 0.05); },
            stopAll: function() { this.toggleSlideSound(false); }
        };

        // --- GLOBAL STATE ---
        let scene, camera, renderer;
        let isLocked = false;
        let lastTime = performance.now();
        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false, c: false, q: false };
        let wantsToJump = false; 
        let mouseDown = false;
        let lastUnlockTime = 0; 
        
        let currentTheme = 0; 
        let teleportMode = 'AIM'; 
        let comboCount = 0;
        let comboTimer = 0;
        let lastSlashID = 0; 
        let slashActive = false;
        let sessionStartTime = 0;
        let lastHeartbeatTime = 0;

        const materials = {};
        const textures = {};

        const player = {
            velocity: new THREE.Vector3(),
            onGround: false,
            jumpsRemaining: 2, 
            isSliding: false,
            isCrouching: false,
            isSprinting: false,
            health: 100,
            stamina: 100,
            score: 0,
            extraLives: 0,
            isDead: false,
            cameraHeightOffset: 0,
            lastDamageTime: 0,
            isRegenerating: false,
            teleportActive: false,
            teleportTarget: null,
            airTimeStart: 0,
            lastSlideTime: 0,
            lastJumpTime: 0,
            lastTeleportTime: 0,
            lastWallJumpTime: 0,
            lastTeleportWasAerial: false,
            hasPhaseStruck: false
        };

        const moveStreaks = {
            slide: { count: 0, lastTime: 0 },
            aerial: { count: 0, lastTime: 0 },
            longAerial: { count: 0, lastTime: 0 },
            wall: { count: 0, lastTime: 0 },
            phase: { count: 0, lastTime: 0 }
        };

        const worldObjects = []; 
        const walls = [];        
        const enemies = [];
        const particles = [];
        const decorations = [];
        const weatherParticles = [];

        let teleportMarker;
        let slashGeometry; 
        let lastAttackTime = 0;
        let currentSlashColor = 0x0088ff;

        // --- PROCEDURAL TEXTURES ---
        function createGridTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            if (type === 'snow') {
                ctx.fillStyle = '#ffffff'; 
                ctx.fillRect(0,0,1024,1024);
                ctx.strokeStyle = 'rgba(200, 220, 255, 0.2)'; 
                ctx.lineWidth = 2;
            } else if (type === 'neon') {
                // New Tron-Style Neon Grid
                ctx.fillStyle = '#000000'; 
                ctx.fillRect(0,0,1024,1024);
                ctx.strokeStyle = '#00ffff'; 
                ctx.lineWidth = 2;
                ctx.shadowBlur = 4;
                ctx.shadowColor = '#00ffff';
            } else {
                ctx.fillStyle = '#050505';
                ctx.fillRect(0, 0, 1024, 1024);
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 4;
            }
            
            // Grid Lines
            ctx.beginPath();
            for(let i=0; i<=1024; i+=128) {
                ctx.moveTo(i,0); ctx.lineTo(i,1024);
                ctx.moveTo(0,i); ctx.lineTo(1024,i);
            }
            ctx.stroke();

            // Minor Grid
            if (type !== 'snow') {
                ctx.lineWidth = type === 'neon' ? 1 : 2;
                ctx.strokeStyle = type === 'neon' ? 'rgba(0, 255, 255, 0.3)' : 'rgba(255,255,255,0.1)';
                ctx.beginPath();
                for(let i=0; i<=1024; i+=32) {
                    if(i % 128 === 0) continue;
                    ctx.moveTo(i,0); ctx.lineTo(i,1024);
                    ctx.moveTo(0,i); ctx.lineTo(1024,i);
                }
                ctx.stroke();
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.minFilter = THREE.LinearMipMapLinearFilter;
            tex.anisotropy = 16;
            return tex;
        }

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.4, 'rgba(255,255,255,0.5)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,64,64);
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        // --- SETUP ---
        function init() {
            lastUnlockTime = performance.now() - 5000;

            const btn = document.getElementById('start-btn');
            btn.addEventListener('click', () => {
                AudioSys.init(); 
                const now = performance.now();
                if (now - lastUnlockTime < 1300) {
                    btn.innerText = "b r e a t h e";
                    btn.style.opacity = 0.5;
                    btn.style.letterSpacing = "8px";
                    setTimeout(() => {
                        btn.innerText = "ENTER ARENA";
                        btn.style.opacity = 1;
                        btn.style.letterSpacing = "2px";
                    }, 800);
                    return;
                }
                document.body.requestPointerLock().catch(e => {
                    console.warn("Pointer lock failed:", e);
                });
            });
            document.getElementById('theme-btn').addEventListener('click', toggleTheme);
            document.getElementById('tp-mode-btn').addEventListener('click', toggleTeleportMode);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ'; 
            camera.position.set(0, 2, 0);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            // Generate Textures
            textures.gridDefault = createGridTexture('default');
            textures.gridSnow = createGridTexture('snow');
            textures.gridNeon = createGridTexture('neon');
            textures.glow = createGlowTexture();

            setupLighting();
            createLevel();
            createSlashEffect(); 
            createTeleportMarker();

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', (e) => {
                if(e.button === 0) mouseDown = true;
                if(isLocked && e.button === 0) {
                    if (teleportMode === 'AIM' && player.teleportActive) {
                        tryAimTeleport();
                        slash(); 
                    } else {
                        slash();
                    }
                }
            });
            document.addEventListener('mouseup', () => { mouseDown = false; });
            window.addEventListener('resize', onWindowResize);
            
            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === document.body;
                const screen = document.getElementById('start-screen');
                if (isLocked) {
                    screen.style.display = 'none';
                    if(player.isDead) resetGame();
                } else {
                    lastUnlockTime = performance.now();
                    screen.style.display = 'flex';
                    AudioSys.stopAll();
                    updatePauseScreenStats();
                    mouseDown = false; 
                }
            });
            
            document.addEventListener('pointerlockerror', (e) => {
                console.warn("Pointer lock error detected.", e);
                if(!isLocked) {
                    document.getElementById('start-screen').style.display = 'flex';
                }
            });

            applyTheme();
            animate();
        }

        function generatePlayerTitle() {
            let core = "NOVICE";
            const m = GameStats.moves;
            const c = GameStats.highestCombo;
            const totalStyle = m.slideHit + m.midAirHit + m.teleportHit + m.wallJumpHit + m.longAirHit;

            // Titles based on Achievement/Style Mastery, NOT Score.
            if (totalStyle > 1000) core = "OMNIPOTENT";
            else if (totalStyle > 600) core = "LEGEND";
            else if (totalStyle > 300) core = "MASTER";
            else if (totalStyle > 150) core = "ELITE";
            else if (totalStyle > 75) core = "VETERAN";
            else if (totalStyle > 25) core = "SOLDIER";
            
            let prefix = "";
            let suffix = "";

            if (c > 300) prefix = "MYTHIC ";
            else if (c > 150) prefix = "UNSTOPPABLE ";
            else if (c > 50) prefix = "RELENTLESS ";
            
            if (m.teleportHit > 50) suffix = " VOID WALKER";
            else if (m.midAirHit > 100) suffix = " SKY ASSASSIN";
            else if (m.slideHit > 100) suffix = " DRIFTER";
            else if (m.wallJumpHit > 50) suffix = " WALL RUNNER";
            else if (totalStyle > 200) suffix = " STYLIST";
            
            return (prefix + core + suffix).trim();
        }

        function updatePauseScreenStats() {
            const h1 = document.getElementById('game-title');
            const timerDisplay = document.getElementById('session-timer');
            const playerTitleDisplay = document.getElementById('player-title-display');
            
            if(player.isDead) {
                let termStatus = "TERMINATED";
                let color = "#ff3333";
                
                // Significantly increased Score thresholds
                if (player.score > 500000) { termStatus = "TRANSCENDED"; color = "#aa00ff"; }
                else if (player.score > 250000) { termStatus = "ASCENDED"; color = "#00ffff"; }
                else if (player.score > 100000) { termStatus = "VANQUISHED"; color = "#ffff00"; }
                else if (player.score > 50000) { termStatus = "ELIMINATED"; color = "#ff8800"; }
                
                h1.innerText = termStatus;
                h1.style.color = color;
                h1.style.textShadow = `4px 4px 0px ${color}44`;
                
                playerTitleDisplay.innerText = generatePlayerTitle();
                playerTitleDisplay.style.display = "block";
                
                timerDisplay.style.display = "block";
            } else {
                h1.innerText = "PAUSED";
                h1.style.color = "#33ccff";
                h1.style.textShadow = "4px 4px 0px #33ccff";
                playerTitleDisplay.style.display = "none";
                timerDisplay.style.display = "none";
            }

            let achStr = GameStats.achievements.join(', ');
            if(!achStr) achStr = "None yet";

            const statSession = document.getElementById('stat-session');
            statSession.innerHTML = `
                <strong>SCORE:</strong> ${player.score}<br>
                <strong>MAX COMBO:</strong> ${GameStats.highestCombo}<br>
                <strong>ACHIEVEMENTS:</strong><br>${achStr}
            `;

            const statMoves = document.getElementById('stat-moves');
            let movesHtml = "";
            if(GameStats.moves.slideHit > 0) movesHtml += `Slide Strikes: ${GameStats.moves.slideHit}<br>`;
            if(GameStats.moves.midAirHit > 0) movesHtml += `Aerial Strikes: ${GameStats.moves.midAirHit}<br>`;
            if(GameStats.moves.longAirHit > 0) movesHtml += `Long Air Strikes: ${GameStats.moves.longAirHit}<br>`;
            if(GameStats.moves.teleportHit > 0) movesHtml += `Teleport Strikes: ${GameStats.moves.teleportHit}<br>`;
            if(GameStats.moves.wallJumpHit > 0) movesHtml += `Wall Jump Strikes: ${GameStats.moves.wallJumpHit}<br>`;

            if(movesHtml === "") movesHtml = "No style points yet.";
            statMoves.innerHTML = movesHtml;
        }

        let ambientLight, hemiLight, dirLight;

        function setupLighting() {
            ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 50, 0);
            scene.add(hemiLight);
            
            dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(80, 120, 80);
            dirLight.castShadow = true;
            dirLight.shadow.bias = -0.0001;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.left = -200;
            dirLight.shadow.camera.right = 200;
            dirLight.shadow.camera.top = 200;
            dirLight.shadow.camera.bottom = -200;
            scene.add(dirLight);
        }

        function toggleTheme() {
            currentTheme = (currentTheme + 1) % 4;
            const names = ["LIGHT", "DARK", "NEON", "HALLOWEEN"];
            document.getElementById('theme-btn').innerText = "THEME: " + names[currentTheme];
            applyTheme();
        }

        function toggleTeleportMode() {
            if (teleportMode === 'AIM') {
                teleportMode = 'INSTANT';
            } else {
                teleportMode = 'AIM';
            }
            document.getElementById('tp-mode-btn').innerText = "TP MODE: " + teleportMode;
            document.getElementById('tp-label').innerText = teleportMode;
        }

        function applyTheme() {
            const body = document.body;
            const ui = document.getElementById('ui-layer');
            const crosshair = document.getElementById('crosshair');
            
            // Reset common props
            materials.floor.roughness = 0.5;
            materials.floor.metalness = 0.1;
            materials.floor.emissiveIntensity = 0;
            materials.floor.emissiveMap = null;
            materials.wall.emissiveIntensity = 0;
            materials.wall.emissiveMap = null;

            if (currentTheme === 0) { // LIGHT (SNOW)
                const bgCol = 0x667788; 
                scene.background = new THREE.Color(bgCol);
                scene.fog = new THREE.FogExp2(bgCol, 0.008); 
                body.style.backgroundColor = "#667788";
                ui.classList.add('light-theme');
                
                materials.floor.map = textures.gridSnow;
                materials.floor.map.repeat.set(400/64, 400/64); 
                materials.floor.color.setHex(0x556677); 
                materials.floor.roughness = 0.9;
                
                materials.wall.color.setHex(0xdddddd);
                materials.wall.roughness = 0.5;
                
                currentSlashColor = 0x0088ff;
                materials.marker.color.setHex(0x003366); // Darker blue for visibility on white
                crosshair.style.color = "#0088ff";
                
                ambientLight.intensity = 0.6; 
                hemiLight.intensity = 0.6;
                dirLight.intensity = 0.8; 
                dirLight.color.setHex(0xffffff);

            } else {
                ui.classList.remove('light-theme');
                
                if (currentTheme === 1) { // DARK (CYBER)
                    scene.background = new THREE.Color(0x080808);
                    scene.fog = new THREE.FogExp2(0x080808, 0.01);
                    body.style.backgroundColor = "#080808";
                    
                    // Dark Theme uses Neon Grid (Cyan)
                    materials.floor.map = textures.gridNeon;
                    materials.floor.map.repeat.set(400/32, 400/32);
                    materials.floor.color.setHex(0xffffff); 
                    
                    materials.wall.color.setHex(0x444444); 
                    
                    currentSlashColor = 0x00aaff; 
                    materials.marker.color.setHex(0x00ffaa);
                    crosshair.style.color = "#00aaff";
                    
                    ambientLight.intensity = 1.0; 
                    hemiLight.intensity = 0.6;
                    dirLight.intensity = 0.6;

                } else if (currentTheme === 2) { // NEON (Classic v44)
                    const bgCol = 0x050505;
                    scene.background = new THREE.Color(bgCol);
                    scene.fog = new THREE.FogExp2(bgCol, 0.01);
                    body.style.backgroundColor = "#050505";
                    
                    // Neon Theme uses Default Grid (Grey)
                    materials.floor.map = textures.gridDefault;
                    materials.floor.map.repeat.set(400/32, 400/32);
                    materials.floor.color.setHex(0x444444);
                    
                    materials.wall.color.setHex(0x001122); 
                    
                    currentSlashColor = 0x00ffff; 
                    materials.marker.color.setHex(0x00ffff);
                    crosshair.style.color = "#00ffff";
                    
                    ambientLight.intensity = 0.8;
                    hemiLight.intensity = 0.5;
                    dirLight.intensity = 0.8;
                    dirLight.color.setHex(0x00ffff);

                } else { // HALLOWEEN
                    scene.background = new THREE.Color(0x150500); 
                    scene.fog = new THREE.FogExp2(0x150500, 0.008);
                    body.style.backgroundColor = "#150500";
                    
                    materials.floor.map = textures.gridDefault;
                    materials.floor.map.repeat.set(400/32, 400/32);
                    materials.floor.color.setHex(0x2a1100); 
                    
                    materials.wall.color.setHex(0x332200); 
                    
                    currentSlashColor = 0xff8800; 
                    materials.marker.color.setHex(0xff4400);
                    crosshair.style.color = "#ff8800";
                    
                    ambientLight.intensity = 1.0; 
                    hemiLight.intensity = 0.7;
                    dirLight.intensity = 0.8;
                    dirLight.color.setHex(0xffaa00);
                }
            }
            
            if(materials.slash) materials.slash.color.setHex(currentSlashColor);
            
            // Update decorations and enemies for theme specific styles
            decorations.forEach(d => d.updateTheme(currentTheme));
            enemies.forEach(e => e.updateTheme(currentTheme));
        }

        // --- LEVEL GENERATION ---
        function createLevel() {
            // PBR Materials
            materials.floor = new THREE.MeshPhysicalMaterial({ 
                map: textures.gridDefault, 
                color: 0xffffff, 
                roughness: 0.5,
                metalness: 0.1 
            });
            
            materials.wall = new THREE.MeshPhysicalMaterial({ 
                color: 0xeeeeee, 
                roughness: 0.2, 
                metalness: 0.1 
            });
            
            materials.obstacle = new THREE.MeshPhysicalMaterial({ 
                color: 0xcccccc, 
                roughness: 0.3,
                clearcoat: 0.5,
                clearcoatRoughness: 0.1
            });
            
            materials.slash = new THREE.MeshBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0, side: THREE.DoubleSide, depthTest: false });
            materials.marker = new THREE.MeshStandardMaterial({ 
                color: 0x0088ff, 
                emissive: 0x0088ff,
                emissiveIntensity: 2.0,
                transparent: true, 
                opacity: 0.9,
                roughness: 0.2,
                metalness: 0.8,
                wireframe: true // Revert to wireframe look
            });

            createBox(0, -1, 0, 400, 2, 400, materials.floor, true);
            createBox(0, 50, -200, 400, 100, 2, materials.wall, false, true);
            createBox(0, 50, 200, 400, 100, 2, materials.wall, false, true);
            createBox(-200, 50, 0, 2, 100, 400, materials.wall, false, true);
            createBox(200, 50, 0, 2, 100, 400, materials.wall, false, true);
            
            for(let i=0; i<20; i++) {
                let x = (Math.random() - 0.5) * 300;
                let z = (Math.random() - 0.5) * 300;
                if(Math.abs(x) < 30 && Math.abs(z) < 30) { x += 50; }
                const scale = 1 + Math.random() * 6; 
                decorations.push(new Decoration(x, z, scale));
            }

            for(let i=0; i<3; i++) {
                let x = (Math.random() - 0.5) * 340;
                let z = (Math.random() - 0.5) * 340;
                decorations.push(new Decoration(x, z, 21));
            }
             for(let i=0; i<2; i++) {
                let x = (Math.random() - 0.5) * 340;
                let z = (Math.random() - 0.5) * 340;
                decorations.push(new Decoration(x, z, 35));
            }
            decorations.push(new Decoration(150, 150, 70));
        }

        function createBox(x, y, z, w, h, d, mat, isFloor=false, isWall=false) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            if (isWall || !isFloor) {
                 const edges = new THREE.EdgesGeometry(geo);
                 const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.05 }));
                 mesh.add(line);
            }

            scene.add(mesh);
            mesh.geometry.computeBoundingBox();
            if (isFloor || !isWall) worldObjects.push(mesh);
            if (!isFloor) walls.push(mesh);
            return mesh;
        }

        const GIFT_PALETTES = [
            { box: 0xcc0000, ribbon: 0xffd700 }, // Red/Gold
            { box: 0x006400, ribbon: 0xcc0000 }, // Green/Red
            { box: 0x0044aa, ribbon: 0xc0c0c0 }, // Blue/Silver
            { box: 0xffffff, ribbon: 0xcc0000 }, // White/Red
            { box: 0x663399, ribbon: 0xffd700 }  // Purple/Gold
        ];

        class Decoration {
            constructor(x, z, scale) {
                this.scale = scale;
                const size = 2;
                this.palette = GIFT_PALETTES[Math.floor(Math.random() * GIFT_PALETTES.length)];

                const colliderGeo = new THREE.BoxGeometry(size, size, size);
                const colliderMat = new THREE.MeshBasicMaterial({ visible: false });
                this.colliderMesh = new THREE.Mesh(colliderGeo, colliderMat);
                this.colliderMesh.position.set(x, scale, z);
                this.colliderMesh.scale.setScalar(scale);
                this.colliderMesh.geometry.computeBoundingBox();
                walls.push(this.colliderMesh);
                scene.add(this.colliderMesh);

                const visualGeo = new THREE.BoxGeometry(size, size, size);
                this.mat = materials.obstacle.clone();
                this.visualMesh = new THREE.Mesh(visualGeo, this.mat);
                this.visualMesh.castShadow = true;
                this.visualMesh.receiveShadow = true;
                this.visualMesh.position.copy(this.colliderMesh.position);
                this.visualMesh.scale.setScalar(scale);
                
                this.visualMesh.updateMatrixWorld();
                worldObjects.push(this.visualMesh);
                
                // Tech Wireframe Overlay
                const edges = new THREE.EdgesGeometry(visualGeo);
                this.edges = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 }));
                this.visualMesh.add(this.edges);

                // HALLOWEEN FACES
                this.faceGroup = new THREE.Group();
                const faceMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const eyeGeo = new THREE.ConeGeometry(0.3, 0.1, 3);
                const eyeL = new THREE.Mesh(eyeGeo, faceMat);
                eyeL.position.set(-0.5, 0.2, 1.01); 
                eyeL.rotation.x = -Math.PI/2; eyeL.rotation.z = Math.PI;
                const eyeR = new THREE.Mesh(eyeGeo, faceMat);
                eyeR.position.set(0.5, 0.2, 1.01);
                eyeR.rotation.x = -Math.PI/2; eyeR.rotation.z = Math.PI;
                const mouthGeo = new THREE.BoxGeometry(1.2, 0.3, 0.1);
                const mouth = new THREE.Mesh(mouthGeo, faceMat);
                mouth.position.set(0, -0.5, 1.01);
                this.faceGroup.add(eyeL); this.faceGroup.add(eyeR); this.faceGroup.add(mouth);
                const stemGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 6);
                const stemMat = new THREE.MeshBasicMaterial({ color: 0x006400 });
                this.stem = new THREE.Mesh(stemGeo, stemMat);
                this.stem.position.set(0, 1.2, 0);
                this.faceGroup.add(this.stem);
                this.visualMesh.add(this.faceGroup);

                // GIFT BOX RIBBONS
                this.ribbonGroup = new THREE.Group();
                this.ribbonMat = new THREE.MeshBasicMaterial({ color: this.palette.ribbon });
                const r1Geo = new THREE.BoxGeometry(2.05, 2.05, 0.4); 
                const r1 = new THREE.Mesh(r1Geo, this.ribbonMat);
                const r2Geo = new THREE.BoxGeometry(0.4, 2.05, 2.05); 
                const r2 = new THREE.Mesh(r2Geo, this.ribbonMat);
                const bowGeo = new THREE.SphereGeometry(0.4, 8, 8);
                const bow = new THREE.Mesh(bowGeo, this.ribbonMat);
                bow.position.y = 1.025; 
                this.ribbonGroup.add(r1); this.ribbonGroup.add(r2); this.ribbonGroup.add(bow);
                this.ribbonGroup.visible = false;
                this.visualMesh.add(this.ribbonGroup);
                
                scene.add(this.visualMesh);
            }

            updateTheme(t) {
                // Reset common props
                this.mat.color.setHex(0xcccccc);
                this.mat.emissive.setHex(0x000000);
                this.mat.wireframe = false;
                this.faceGroup.visible = false;
                this.ribbonGroup.visible = false;
                this.edges.visible = true;
                this.edges.material.opacity = 0.1;
                this.edges.material.color.setHex(0xffffff);
                this.edges.material.linewidth = 1;
                this.visualMesh.rotation.y = 0; // Reset rotation

                if (t === 3) { // Halloween
                    const r = 0.8 + Math.random()*0.2;
                    const g = 0.3 + Math.random()*0.3;
                    this.mat.color.setRGB(r, g, 0); // Random orange
                    this.mat.emissive = new THREE.Color(r*0.1, g*0.1, 0);
                    this.faceGroup.visible = true;
                    this.edges.visible = false;
                    this.visualMesh.rotation.y = (Math.PI / 2) * Math.floor(Math.random() * 4);
                } else if (t === 0) { // Light (Gifts)
                    this.mat.color.setHex(this.palette.box);
                    this.ribbonMat.color.setHex(this.palette.ribbon);
                    this.ribbonGroup.visible = true;
                    this.edges.material.color.setHex(0x000000);
                } else {
                    if(t === 1) { // Dark/Cyber (Actually uses Neon Grid)
                         this.mat.color.setHex(0x112233);
                         this.mat.emissive.setHex(0x001122);
                         this.edges.material.color.setHex(0x00ffff);
                         this.edges.material.opacity = 0.8;
                         this.edges.material.linewidth = 1;
                    }
                    if(t === 2) { // Neon (Uses Grey Grid, Dark Look)
                         this.mat.color.setHex(0x001122); // Dark Blueish
                         this.edges.material.color.setHex(0x00ffff); 
                         this.edges.material.opacity = 0.5; 
                    }
                }
            }
        }

        function updateWeather(dt) {
            const isHalloween = currentTheme === 3;
            const isSnow = currentTheme === 0;

            if (!isHalloween && !isSnow && weatherParticles.length === 0) return;

            if ((!isSnow && weatherParticles.some(p => p.type === 'snow')) || 
                (!isHalloween && weatherParticles.some(p => p.type === 'leaf'))) {
                 weatherParticles.forEach(l => scene.remove(l.mesh));
                 weatherParticles.length = 0;
                 if (!isHalloween && !isSnow) return;
            }

            const limit = isSnow ? 300 : 80;
            const spawnRate = isSnow ? 0.4 : 0.1;

            if(weatherParticles.length < limit && Math.random() < spawnRate) {
                let mesh, vel, type;
                const px = camera.position.x + (Math.random()-0.5)*50;
                const pz = camera.position.z + (Math.random()-0.5)*50;

                if (isSnow) {
                    const geo = new THREE.PlaneGeometry(0.1, 0.1);
                    const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
                    mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(px, 30, pz);
                    mesh.lookAt(camera.position); 
                    vel = new THREE.Vector3((Math.random()-0.5)*2, -4 - Math.random()*4, (Math.random()-0.5)*2);
                    type = 'snow';
                } else {
                    const geo = new THREE.PlaneGeometry(0.3, 0.3);
                    const mat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xffaa00 : 0x884400, side: THREE.DoubleSide });
                    mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(px, 30, pz);
                    mesh.rotation.set(Math.random(), Math.random(), Math.random());
                    vel = new THREE.Vector3((Math.random()-0.5)*3, -3 - Math.random()*3, (Math.random()-0.5)*3);
                    type = 'leaf';
                }

                scene.add(mesh);
                weatherParticles.push({ mesh: mesh, vel: vel, type: type, swayOffset: Math.random() * 100, landed: false, landTimer: 2.0 });
            }

            for(let i=weatherParticles.length-1; i>=0; i--) {
                const l = weatherParticles[i];

                if (l.landed) {
                    l.landTimer -= dt;
                    l.mesh.material.opacity = (l.landTimer / 2.0) * 0.8;
                    if (l.landTimer <= 0) {
                        scene.remove(l.mesh);
                        l.mesh.geometry.dispose();
                        l.mesh.material.dispose();
                        weatherParticles.splice(i, 1);
                    }
                    continue; 
                }

                l.mesh.position.addScaledVector(l.vel, dt);
                
                if (l.type === 'leaf') {
                    l.mesh.rotation.x += dt * 2;
                    l.mesh.rotation.y += dt;
                    l.mesh.position.x += Math.sin(performance.now() * 0.002 + l.swayOffset) * dt * 2;
                } else {
                    l.mesh.position.x += Math.sin(performance.now() * 0.001 + l.swayOffset) * dt * 0.5;
                    l.mesh.rotation.z += dt; 
                }

                if(l.mesh.position.y <= 0) {
                    if (l.type === 'snow') {
                        l.landed = true;
                        l.mesh.position.y = 0.05; 
                        l.mesh.rotation.x = -Math.PI / 2;
                        l.vel.set(0,0,0);
                    } else {
                        scene.remove(l.mesh);
                        l.mesh.geometry.dispose();
                        l.mesh.material.dispose();
                        weatherParticles.splice(i, 1);
                    }
                }
            }
        }

        function spawnSnowTrail(pos) {
            const mat = new THREE.SpriteMaterial({ map: textures.glow, color: 0xffffff, transparent: true, opacity: 0.8 }); // Prominent snow
            const mesh = new THREE.Sprite(mat);
            mesh.scale.set(0.8, 0.8, 0.8);
            mesh.position.copy(pos);
            mesh.position.y = getGroundHeight(pos.x, pos.z) + 0.1;
            scene.add(mesh);
            particles.push({
                mesh: mesh,
                vel: new THREE.Vector3(0,0,0),
                life: 1.5, 
                isStatic: true
            });
        }

        function spawnSnowKickup(pos) {
            for(let i=0; i<3; i++) {
                const mat = new THREE.SpriteMaterial({ map: textures.glow, color: 0xffffff, transparent: true, opacity: 0.8 });
                const mesh = new THREE.Sprite(mat);
                mesh.scale.set(0.3, 0.3, 0.3);
                mesh.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5), 0.1, (Math.random()-0.5)));
                const vel = new THREE.Vector3(
                    (Math.random()-0.5) * 2, 
                    1 + Math.random() * 3, 
                    (Math.random()-0.5) * 2
                );
                scene.add(mesh);
                particles.push({ mesh: mesh, vel: vel, life: 0.5, isStatic: false });
            }
        }

        // --- VISUALS ---
        function createSlashEffect() {
            const shape = new THREE.Shape();
            shape.moveTo(0, 1.2);
            shape.quadraticCurveTo(-0.5, 0, 0, -1.2);
            shape.quadraticCurveTo(-0.2, 0, 0, 1.2);
            slashGeometry = new THREE.ShapeGeometry(shape);
            slashGeometry.center(); 
        }

        function spawnSlash(parent) {
            const mat = materials.slash.clone();
            mat.color.setHex(currentSlashColor);
            
            const mesh = new THREE.Mesh(slashGeometry, mat);
            mesh.material.transparent = true;
            mesh.material.opacity = 1;
            mesh.material.depthTest = false; 
            mesh.material.depthWrite = false;
            mesh.renderOrder = 999; 
            mesh.userData.fadeSpeed = 0.15; 
            mesh.userData.isHit = false;

            let mySlashID = -1;

            if(parent === camera) {
                mesh.position.set(0, 0, -2.0); 
                mesh.rotation.z = -Math.PI / 8; 
                camera.add(mesh);
                
                mySlashID = ++lastSlashID;
                slashActive = true;
                document.getElementById('crosshair').style.opacity = 0;
            } else {
                mesh.position.set(0, 1.5, 1.0);
                mesh.lookAt(camera.position);
                mesh.rotation.z = Math.PI / 2; 
                parent.add(mesh);
            }
            
            let progress = 0;
            function animateSlash() {
                progress += mesh.userData.fadeSpeed;
                if (progress < 1) {
                    mesh.material.opacity = 1 - progress;
                    requestAnimationFrame(animateSlash);
                } else {
                    mesh.visible = false;
                    if(parent === camera) {
                        camera.remove(mesh);
                        if(mySlashID === lastSlashID) {
                            slashActive = false;
                        }
                    }
                    else parent.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                }
            }
            animateSlash();
            return mesh;
        }

        function spawnImpact(pos) {
            const mat = new THREE.SpriteMaterial({ map: textures.glow, color: 0xffffff, transparent: true, opacity: 1, blending: THREE.AdditiveBlending });
            const mesh = new THREE.Sprite(mat);
            mesh.scale.set(2, 2, 2);
            mesh.position.copy(pos);
            scene.add(mesh);
            let life = 1.0;
            function animateImpact() {
                life -= 0.15;
                mesh.material.opacity = life;
                mesh.scale.setScalar(2 + (1-life)*2);
                if(life > 0) requestAnimationFrame(animateImpact);
                else { scene.remove(mesh); }
            }
            animateImpact();
        }

        function spawnFirework(pos) {
            spawnParticles(pos, 0xffcc00, 30);
            spawnParticles(pos, 0x00ffff, 30);
            spawnParticles(pos, 0xff00ff, 30);
            AudioSys.playTeleport(); 
        }

        function createTeleportMarker() {
            teleportMarker = new THREE.Group();
            
            // Revert to Wireframe Octahedron/Diamond (Simpler style)
            const geo = new THREE.OctahedronGeometry(0.8, 0);
            const diamond = new THREE.Mesh(geo, materials.marker);
            diamond.position.y = 1.5;
            teleportMarker.add(diamond);

            // Bottom Ring
            const ringGeo = new THREE.RingGeometry(0.8, 1.0, 32);
            const ringMat = materials.marker.clone();
            ringMat.side = THREE.DoubleSide;
            ringMat.opacity = 0.5;
            ringMat.emissiveIntensity = 1;
            
            const ring1 = new THREE.Mesh(ringGeo, ringMat);
            ring1.rotation.x = -Math.PI/2; 
            ring1.position.y = 0.1; 
            teleportMarker.add(ring1);

            teleportMarker.userData = { diamond: diamond, rings: [ring1] };
            teleportMarker.visible = false;
            scene.add(teleportMarker);
        }

        function getGroundHeight(x, z) {
            const rayOrigin = new THREE.Vector3(x, 200, z);
            const raycaster = new THREE.Raycaster(rayOrigin, new THREE.Vector3(0, -1, 0), 0, 250);
            const intersects = raycaster.intersectObjects(worldObjects);
            if (intersects.length > 0) {
                return intersects[0].point.y;
            }
            return 0;
        }

        // --- GAME LOGIC ---
        function updatePlayer(dt) {
            if (player.isDead) return;
            camera.position.y -= player.cameraHeightOffset;

            // Low Health Effects
            const vignette = document.getElementById('low-health-vignette');
            const healthFill = document.getElementById('health-fill');
            
            if (player.health < 40) {
                if (!healthFill.classList.contains('health-critical')) healthFill.classList.add('health-critical');
                
                if (player.health < 25) vignette.style.boxShadow = "inset 0 0 150px rgba(255, 0, 0, 0.6)";
                else vignette.style.boxShadow = "inset 0 0 100px rgba(255, 0, 0, 0.3)";
                
                // Heartbeat Audio
                let hbInterval = 1.0;
                if(player.health < 20) hbInterval = 0.4;
                else if(player.health < 40) hbInterval = 0.8;
                
                const now = performance.now() / 1000;
                if(now - lastHeartbeatTime > hbInterval) {
                    AudioSys.playHeartbeat();
                    lastHeartbeatTime = now;
                }
            } else {
                 if (healthFill.classList.contains('health-critical')) healthFill.classList.remove('health-critical');
                 vignette.style.boxShadow = "inset 0 0 100px rgba(255, 0, 0, 0)";
            }

            if (teleportMode === 'AIM' && player.teleportActive) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                raycaster.far = CONFIG.teleportRange;
                const intersects = raycaster.intersectObjects(worldObjects);
                if (intersects.length > 0) {
                    teleportMarker.position.copy(intersects[0].point);
                    player.teleportTarget = intersects[0].point;
                } else {
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    const target = camera.position.clone().addScaledVector(dir, CONFIG.teleportRange);
                    teleportMarker.position.copy(target);
                    player.teleportTarget = target;
                }
                teleportMarker.visible = true;
                
                // Animate Marker
                const t = performance.now();
                teleportMarker.userData.diamond.rotation.y += dt * 3;
                teleportMarker.userData.diamond.position.y = 1.5 + Math.sin(t * 0.005) * 0.2;
                teleportMarker.userData.rings[0].scale.setScalar(1 + Math.sin(t * 0.01)*0.1);

                document.getElementById('icon-q').classList.add('active');
            } else {
                teleportMarker.visible = false;
                document.getElementById('icon-q').classList.remove('active');
            }

            // Handle Crosshair Visibility
            const ch = document.getElementById('crosshair');
            if (slashActive || (teleportMode === 'AIM' && player.teleportActive)) {
                ch.style.opacity = 0;
            } else {
                ch.style.opacity = 1;
            }

            const now = performance.now();
            
            // REGEN LOGIC
            if (player.isRegenerating) {
                player.health += CONFIG.regenRate * dt;
                if (player.health >= 100) {
                    player.health = 100;
                    player.isRegenerating = false;
                }
            } else {
                if (now - player.lastDamageTime > CONFIG.regenDelay && player.health < 100) {
                    player.isRegenerating = true;
                }
            }

            const isMoving = (keys.w || keys.a || keys.s || keys.d);
            player.isSprinting = keys.shift && player.stamina > 0 && isMoving && !player.isCrouching;
            if (player.isSprinting) {
                player.stamina -= CONFIG.staminaDrain * dt;
                if (player.stamina < 0) player.stamina = 0;
            } else {
                player.stamina += CONFIG.staminaRegen * dt;
                if (player.stamina > 100) player.stamina = 100;
            }

            // SLIDE & CROUCH
            if (keys.c) {
                if (player.onGround) {
                    const speed = new THREE.Vector2(player.velocity.x, player.velocity.z).length();
                    if ((player.isSprinting || player.isSliding || speed > CONFIG.baseSpeed) && !player.isCrouching) {
                        if (!player.isSliding) {
                            player.isSliding = true;
                            player.lastSlideTime = performance.now(); 
                            const forward = new THREE.Vector3();
                            camera.getWorldDirection(forward);
                            forward.y = 0; forward.normalize();
                            player.velocity.addScaledVector(forward, CONFIG.slideBoost);
                        }
                    } else if (!player.isSliding) {
                        player.isCrouching = true;
                    }
                }
            } else {
                player.isSliding = false;
                player.isCrouching = false;
            }
            
            if (player.isSliding && currentTheme === 0) {
                if (Math.random() < 0.3) spawnSnowTrail(camera.position);
                if (Math.random() < 0.5) spawnSnowKickup(camera.position);
            }

            AudioSys.toggleSlideSound(player.isSliding && new THREE.Vector2(player.velocity.x, player.velocity.z).length() > 5);
            const targetHeight = (player.isSliding || player.isCrouching) ? -0.8 : 0;
            player.cameraHeightOffset = THREE.MathUtils.lerp(player.cameraHeightOffset, targetHeight, dt * 15);

            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0; forward.normalize();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

            const inputDir = new THREE.Vector3();
            if (keys.w) inputDir.add(forward);
            if (keys.s) inputDir.sub(forward);
            if (keys.a) inputDir.sub(right);
            if (keys.d) inputDir.add(right);
            if (inputDir.length() > 0) inputDir.normalize();

            let targetSpeed = CONFIG.baseSpeed;
            if (player.isCrouching) targetSpeed = CONFIG.crouchSpeed;
            if (player.isSprinting) targetSpeed = CONFIG.sprintSpeed;
            let friction = player.onGround ? CONFIG.frictionGround : CONFIG.frictionAir;
            let drive = friction; 
            if (!player.onGround) { friction = CONFIG.frictionAir; drive = CONFIG.airControl; }
            if (player.isSliding) { friction = CONFIG.frictionSlide; drive = 0; targetSpeed = 0; }

            if (inputDir.length() > 0 && !player.isSliding) {
                player.velocity.addScaledVector(inputDir, targetSpeed * drive * dt);
            }

            const damping = Math.exp(-friction * dt);
            player.velocity.x *= damping;
            player.velocity.z *= damping;
            player.velocity.y -= CONFIG.gravity * dt;

            const nextPos = camera.position.clone().addScaledVector(player.velocity, dt);
            const playerBox = new THREE.Box3();
            const radius = 0.4;
            playerBox.min.set(nextPos.x - radius, nextPos.y - 1.5, nextPos.z - radius);
            playerBox.max.set(nextPos.x + radius, nextPos.y + 0.5, nextPos.z + radius);

            // WALL COLLISION
            let touchingWall = false;
            for (const wall of walls) {
                const box = wall.geometry.boundingBox.clone();
                box.applyMatrix4(wall.matrixWorld);
                
                if (playerBox.intersectsBox(box)) {
                    touchingWall = true;
                    const xOverlap = Math.min(playerBox.max.x - box.min.x, box.max.x - playerBox.min.x);
                    const zOverlap = Math.min(playerBox.max.z - box.min.z, box.max.z - playerBox.min.z);
                    
                    if (xOverlap < zOverlap) {
                        const sign = (playerBox.getCenter(new THREE.Vector3()).x < box.getCenter(new THREE.Vector3()).x) ? -1 : 1;
                        nextPos.x += xOverlap * sign;
                        player.velocity.x = 0;
                    } else {
                        const sign = (playerBox.getCenter(new THREE.Vector3()).z < box.getCenter(new THREE.Vector3()).z) ? -1 : 1;
                        nextPos.z += zOverlap * sign;
                        player.velocity.z = 0;
                    }
                    playerBox.min.set(nextPos.x - radius, nextPos.y - 1.5, nextPos.z - radius);
                    playerBox.max.set(nextPos.x + radius, nextPos.y + 0.5, nextPos.z + radius);
                }
            }

            // GROUND DETECTION
            const rayOrigin = nextPos.clone();
            const raycaster = new THREE.Raycaster(rayOrigin, new THREE.Vector3(0, -1, 0), 0, 5); 
            const intersects = raycaster.intersectObjects(worldObjects);
            const wasOnGround = player.onGround;
            player.onGround = false;
            
            if (intersects.length > 0) {
                const dist = intersects[0].distance;
                const desiredHeight = 1.6; 
                if (dist < desiredHeight + 0.2 && player.velocity.y <= 0) {
                    nextPos.y = intersects[0].point.y + desiredHeight;
                    player.velocity.y = 0;
                    player.onGround = true;
                    player.jumpsRemaining = 2; 
                    
                    if(!wasOnGround) {
                        moveStreaks.longAerial.count = 0; 
                        moveStreaks.aerial.count = 0;
                        player.lastTeleportWasAerial = false; // Reset state on land
                    }
                }
            }

            // Auto-Hop Logic (Ground)
            if (player.onGround && wantsToJump) {
                 performJump();
                 // Reset streaks immediately to prevent stacking bug on bunnyhops
                 moveStreaks.longAerial.count = 0;
                 moveStreaks.aerial.count = 0;
            }
            // Auto-Hop Logic (Wall)
            else if (!player.onGround && touchingWall && wantsToJump && player.jumpsRemaining > 0) {
                 performWallJump();
            }

            if (wasOnGround && !player.onGround) {
                player.airTimeStart = performance.now();
            }

            camera.position.copy(nextPos);
            camera.position.y += player.cameraHeightOffset;
            
            // Rabbit Hole Logic
            if (camera.position.y < -20) {
                GameStats.addAchievement("DOWN THE RABBIT HOLE", "#ff00ff");
                damagePlayer(20);
                camera.position.set(0, 2, 0);
                player.velocity.set(0,0,0);
            }
        }

        function performJump() {
             player.velocity.y = CONFIG.jumpForce;
             if(player.isSliding) {
                  player.velocity.y = 15; 
                  const forward = new THREE.Vector3();
                  camera.getWorldDirection(forward);
                  forward.y=0; forward.normalize();
                  player.velocity.addScaledVector(forward, CONFIG.bunnyHopBoost);
             }
             
             // FIX: Reset air time start if we are launching from ground.
             // This prevents the "Stacking Score" bug where airTimeStart remains old.
             if(player.onGround) {
                 player.airTimeStart = performance.now();
             }
             
             player.onGround = false;
             player.lastJumpTime = performance.now(); 
             AudioSys.playJump();
        }
        
        function performWallJump() {
            const ray = new THREE.Raycaster(camera.position, new THREE.Vector3(0,0,0), 0, 1.5);
            const dirs = [
                new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0),
                new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)
            ];
            let hitWall = false;
            for(let d of dirs) {
                d.applyQuaternion(camera.quaternion);
                ray.set(camera.position, d);
                if(ray.intersectObjects(walls).length > 0) {
                    hitWall = true;
                    player.velocity.addScaledVector(d, -CONFIG.wallPushForce);
                    break;
                }
            }
            
            if (hitWall) {
                player.velocity.y = CONFIG.wallJumpForce;
                player.jumpsRemaining--;
                player.onGround = false;
                player.lastJumpTime = performance.now();
                player.lastWallJumpTime = performance.now(); 
                // Note: We do NOT reset airTimeStart on wall jumps to allow Long Aerial combos.
                AudioSys.playWallJump();
            }
        }

        function executeTeleport(target) {
             if (player.stamina < CONFIG.teleportCost) {
                 // Not enough stamina
                 AudioSys.playMiss();
                 return;
             }
             player.stamina -= CONFIG.teleportCost;

             let yOffset = 0;
             const currentGroundY = getGroundHeight(camera.position.x, camera.position.z);
             const startInAir = (camera.position.y - currentGroundY) > 1.0; 

             const ray = new THREE.Raycaster(target.clone().add(new THREE.Vector3(0,1,0)), new THREE.Vector3(0,-1,0), 0, 2);
             const hits = ray.intersectObjects(worldObjects);
             if(hits.length > 0) yOffset = 1.6;

             const groundAtTarget = getGroundHeight(target.x, target.z);
             const endInAir = (target.y - groundAtTarget) > 0.5;

             player.lastTeleportWasAerial = startInAir || endInAir;
             player.hasPhaseStruck = false; 

             spawnParticles(camera.position, 0x00ffaa, 20); 
             
             camera.position.set(target.x, target.y + yOffset, target.z);
             player.velocity.y = 2; 
             player.jumpsRemaining = 1; 
             player.onGround = false; 
             
             if(!startInAir) {
                 player.airTimeStart = performance.now();
             }
             
             player.lastTeleportTime = performance.now(); 
             
             AudioSys.playTeleport();
             spawnParticles(target, 0x00ffaa, 30);
        }

        function tryAimTeleport() {
            if (player.teleportTarget) {
                executeTeleport(player.teleportTarget);
                player.teleportActive = false; 
            }
        }

        function tryInstantTeleport() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            raycaster.far = CONFIG.teleportRange;
            const intersects = raycaster.intersectObjects(worldObjects);
            let target;
            if (intersects.length > 0) {
                 target = intersects[0].point;
            } else {
                 const dir = new THREE.Vector3();
                 camera.getWorldDirection(dir);
                 target = camera.position.clone().addScaledVector(dir, CONFIG.teleportRange);
            }
            executeTeleport(target);
            document.getElementById('icon-q').classList.add('active');
            setTimeout(() => document.getElementById('icon-q').classList.remove('active'), 200);
        }

        function updateComboUI() {
            const el = document.getElementById('combo-display');
            const meme = document.getElementById('meme-overlay');
            
            // Meme Check
            let memeText = "";
            const ccStr = comboCount.toString();
            
            if (ccStr.includes('69')) { 
                memeText = MEME_TEXTS_69[Math.floor(Math.random() * MEME_TEXTS_69.length)];
                showKillMessage("YIKWIM ;)", "achievement", "#ff00ff"); 
            }
            else if (ccStr.includes('420')) { 
                memeText = MEME_TEXTS_420[Math.floor(Math.random() * MEME_TEXTS_420.length)];
            }
            else if (comboCount === 1000) { memeText = "go touch grass"; }
            
            if (memeText) {
                meme.innerText = memeText;
                meme.style.display = "block";
                setTimeout(() => meme.style.display = "none", 3000);
            }

            if(comboCount < 2) {
                el.style.display = 'none';
            } else {
                el.style.display = 'block';
                el.innerText = comboCount + " HITS";
                
                // Default values
                let fontSize = "2rem";
                let color = "#ffcc00";
                let opacity = "1";
                let blur = "none";
                let textShadow = "4px 4px 0px rgba(0,0,0,0.5)";
                
                if(comboCount >= 5) fontSize = "4rem";
                
                if (comboCount >= 10) {
                    if (comboCount % 10 === 0) {
                        fontSize = "5rem";
                        color = "#ff0000";
                        textShadow = "0 0 20px #ff0000, 4px 4px 0px rgba(0,0,0,0.8)";
                    } else {
                        fontSize = "4rem"; 
                        opacity = "0.8"; 
                        blur = "none"; 
                    }
                }
                
                if (comboCount % 100 === 0 && comboCount > 0) {
                    fontSize = "8rem"; 
                    color = "#ff00ff";
                    textShadow = "0 0 50px #ff00ff, 0 0 20px #fff";
                    blur = "none";
                    opacity = "1";
                    spawnFirework(camera.position.clone().add(new THREE.Vector3(0,0,-5)));
                    GameStats.addAchievement(comboCount + " HITS LEGEND", "#ff00ff");
                }

                el.style.fontSize = fontSize;
                el.style.color = color;
                el.style.opacity = opacity;
                el.style.filter = blur;
                el.style.textShadow = textShadow;
                
                el.style.transform = "translateX(-50%) scale(1.3) rotate(0deg)";
                requestAnimationFrame(() => {
                     setTimeout(() => {
                         el.style.transform = "translateX(-50%) scale(1) rotate(0deg)";
                     }, 50);
                });
            }
            if(comboCount > GameStats.highestCombo) GameStats.highestCombo = comboCount;
        }

        function slash() {
            const now = performance.now();
            if (now - lastAttackTime < CONFIG.attackCooldown) return;
            lastAttackTime = now;

            AudioSys.playSlash();
            const slashMesh = spawnSlash(camera);
            
            const uniqueHitEnemies = new Set();
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);

            // 1. Raycast Check
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); 
            raycaster.far = CONFIG.attackRange;
            
            const hitObjects = [];
            enemies.forEach(e => { 
                if (!e.isDeadCorpse) e.mesh.traverse(c => hitObjects.push(c)); 
            });
            
            const hitIntersects = raycaster.intersectObjects(hitObjects);
            hitIntersects.forEach(hit => {
                let hitObj = hit.object;
                while(hitObj.parent && !enemies.some(e => e.mesh === hitObj)) {
                    hitObj = hitObj.parent;
                }
                const enemy = enemies.find(e => e.mesh === hitObj);
                if(enemy) uniqueHitEnemies.add(enemy);
            });

            // 2. Cone Check
            enemies.forEach(e => {
                if(e.isDeadCorpse) return;
                const toEnemy = e.mesh.position.clone().sub(camera.position);
                const dist = toEnemy.length();
                if (dist < CONFIG.attackRange) {
                    toEnemy.normalize();
                    const angle = camDir.angleTo(toEnemy);
                    if (angle < 0.5) { 
                        uniqueHitEnemies.add(e);
                    }
                }
            });

            if (uniqueHitEnemies.size > 0) {
                const hitCount = uniqueHitEnemies.size;
                if (hitCount >= 10) GameStats.addAchievement("SLAUGHTERHOUSE", "#ff0000");
                else if (hitCount >= 5) GameStats.addAchievement("CROWD CONTROL", "#ff8800");
                else if (hitCount >= 3) GameStats.addAchievement("TRIPLE THREAT", "#ffff00");

                let hitScore = 10;
                let addedScore = 0;
                let comboNames = [];

                const COMBO_WINDOW = 1000; 
                const STREAK_WINDOW = 1500; 

                const recentSlide = (now - player.lastSlideTime < COMBO_WINDOW) || player.isSliding;
                const recentTeleport = (now - player.lastTeleportTime < COMBO_WINDOW);
                const recentWallJump = (now - player.lastWallJumpTime < COMBO_WINDOW);

                function updateStreak(type, baseBonus) {
                    if (now - moveStreaks[type].lastTime < STREAK_WINDOW) {
                        moveStreaks[type].count++;
                    } else {
                        moveStreaks[type].count = 0;
                    }
                    moveStreaks[type].lastTime = now;
                    return baseBonus + moveStreaks[type].count;
                }

                if (recentSlide) {
                    const bonus = updateStreak('slide', 25);
                    addedScore += bonus;
                    comboNames.push("SLIDE");
                    GameStats.moves.slideHit++;
                    GameStats.checkMoveMilestone('slideHit', "SLIDE", "#00ffff");
                }
                
                // --- NEW AERIAL LOGIC (v44.22) ---
                if (!player.onGround) {
                     // Check flight duration
                     const airDuration = (now - player.airTimeStart) / 1000;
                     
                     if (airDuration > 0.8) {
                        // LONG AERIAL
                        const extraTicks = Math.floor((airDuration - 0.8) / 0.2); 
                        const longAirBonus = 50 + (extraTicks * 10);
                        addedScore += longAirBonus;
                        comboNames.push("LONG AERIAL");
                        GameStats.moves.longAirHit++;
                        GameStats.checkMoveMilestone('longAirHit', "SKY ASSASSIN", "#ff00aa");
                     } else {
                        // NORMAL AERIAL
                        const bonus = updateStreak('aerial', 25);
                        addedScore += bonus;
                        comboNames.push("AERIAL");
                        GameStats.moves.midAirHit++;
                        GameStats.checkMoveMilestone('midAirHit', "AERIAL", "#ff00aa");
                     }
                }
                
                if (recentTeleport && !player.hasPhaseStruck) {
                     const bonus = updateStreak('phase', 50);
                     addedScore += bonus;
                     comboNames.push("TELEPORT");
                     player.hasPhaseStruck = true; 
                     GameStats.moves.teleportHit++;
                     GameStats.checkMoveMilestone('teleportHit', "VOID WALKER", "#aa00ff");
                }

                if (recentWallJump) {
                    const bonus = updateStreak('wall', 30);
                    addedScore += bonus;
                    comboNames.push("WALL");
                    GameStats.moves.wallJumpHit++;
                    GameStats.checkMoveMilestone('wallJumpHit', "WALL RUNNER", "#00ffaa");
                }
                
                hitScore += addedScore;
                
                if (comboNames.length > 0) {
                    let totalStreak = 0;
                    for(let k in moveStreaks) {
                        if(now - moveStreaks[k].lastTime < STREAK_WINDOW) totalStreak += moveStreaks[k].count;
                    }
                    
                    let streakColor = "#" + new THREE.Color(currentSlashColor).getHexString();
                    if (currentTheme === 0) streakColor = "#001133"; 
                    if (currentTheme === 1) streakColor = "#00ffff"; 
                    
                    let msg = comboNames.join(" ") + " +" + addedScore;
                    if(totalStreak > 0) {
                         msg += ` <span class="slick-streak" style="color:${streakColor}">+${totalStreak}</span>`;
                    }
                    
                    showKillMessage(msg, "combo");
                }
                
                const hitList = Array.from(uniqueHitEnemies).map(e => ({
                    enemy: e,
                    dist: e.mesh.position.distanceTo(camera.position)
                }));
                hitList.sort((a, b) => a.dist - b.dist);

                hitList.forEach((h, index) => {
                    if (h.enemy.state === 'CONFUSED') {
                        GameStats.addAchievement("NO REST FOR THE WICKED", "#aa00ff");
                    }
                    const damageMult = Math.max(0.1, 1.0 - (index * 0.1));
                    addScore(hitScore); 
                    h.enemy.takeHit(CONFIG.playerDamage * damageMult);
                    spawnParticles(h.enemy.mesh.position, 0x00ffff, 10);
                    spawnImpact(h.enemy.mesh.position);
                });
                
                AudioSys.playHit();

                comboCount += uniqueHitEnemies.size;
                comboTimer = 3.0; 
                updateComboUI();

                if(slashMesh) {
                    slashMesh.material.color.setHex(0xffffff); 
                    slashMesh.material.opacity = 1; 
                    slashMesh.scale.setScalar(1.2); 
                    slashMesh.userData.fadeSpeed = 0.06; 
                    slashMesh.userData.isHit = true; 
                }
            }
        }

        // --- ENEMY AI ---
        const BOT_TYPES = {
            NORMAL: { scale: 1, hp: 100, speedMod: 1, dmgRed: 1, skill: 1, name: "NORMAL", color: 0x2F4F4F, eye: 0xffffff },   
            BRUTE: { scale: 2, hp: 300, speedMod: 0.7, dmgRed: 1, skill: 2, name: "BRUTE", color: 0x191970, eye: 0xffff00 },    
            TITAN: { scale: 3, hp: 600, speedMod: 0.5, dmgRed: 1, skill: 2, name: "TITAN", color: 0x4B0082, eye: 0xff8c00 },    
            COLOSSUS: { scale: 5, hp: 2000, speedMod: 0.3, dmgRed: 0.5, skill: 1, name: "COLOSSUS", color: 0x800000, eye: 0xff0000 }
        };

        class Enemy {
            constructor(posOverride = null, typeOverride = null, initialState = 'ROAM', aggroDelay = 0) {
                this.mesh = new THREE.Group();
                this.id = Math.random(); 
                
                let spawnY = 0;
                
                if (posOverride) {
                    this.mesh.position.copy(posOverride);
                    this.mesh.position.x += (Math.random()-0.5)*2;
                    this.mesh.position.z += (Math.random()-0.5)*2;
                    spawnY = this.mesh.position.y;
                    
                    if (typeOverride) {
                        this.type = typeOverride;
                    } else {
                        this.type = BOT_TYPES.NORMAL;
                    }
                } else {
                    let x, z;
                    do {
                        x = (Math.random() - 0.5) * 200;
                        z = (Math.random() - 0.5) * 200;
                    } while (Math.abs(x) < 20 && Math.abs(z) < 20);
                    
                    const groundY = getGroundHeight(x, z);
                    spawnY = groundY;
                    
                    let r = Math.random();
                    let type = 'NORMAL';
                    
                    if (groundY > 35) {
                        if (r < 0.4) type = 'COLOSSUS';
                        else if (r < 0.9) type = 'TITAN';
                        else type = 'BRUTE';
                    } else if (groundY > 5) {
                        if (r < 0.05) type = 'COLOSSUS';
                        else if (r < 0.4) type = 'TITAN';
                        else if (r < 0.8) type = 'BRUTE';
                        else type = 'NORMAL';
                    } else {
                        if (r < 0.01) type = 'COLOSSUS';
                        else if (r < 0.05) type = 'TITAN';
                        else if (r < 0.20) type = 'BRUTE';
                        else type = 'NORMAL';
                    }
                    
                    this.type = BOT_TYPES[type];
                    this.mesh.position.set(x, spawnY + this.type.scale, z);
                }
                
                const bodyGeo = new THREE.BoxGeometry(1, 2, 1);
                const bodyMat = new THREE.MeshPhysicalMaterial({ 
                    color: this.type.color,
                    metalness: 0.1,
                    roughness: 0.2,
                    clearcoat: 0.5
                });
                this.body = new THREE.Mesh(bodyGeo, bodyMat);
                this.mesh.add(this.body);

                // Wireframe Overlay
                const edges = new THREE.EdgesGeometry(bodyGeo);
                this.outline = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 }));
                this.outline.scale.setScalar(1.02);
                this.mesh.add(this.outline);
                
                const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
                this.eyeMat = new THREE.MeshBasicMaterial({ color: this.type.eye });
                const leftEye = new THREE.Mesh(eyeGeo, this.eyeMat);
                leftEye.position.set(-0.2, 0.5, 0.5); 
                const rightEye = new THREE.Mesh(eyeGeo, this.eyeMat);
                rightEye.position.set(0.2, 0.5, 0.5);
                this.mesh.add(leftEye); this.mesh.add(rightEye);
                this.mesh.scale.setScalar(this.type.scale);

                this.healthBarGroup = new THREE.Group();
                const barGeo = new THREE.PlaneGeometry(1.2, 0.15);
                const barMat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
                this.healthBar = new THREE.Mesh(barGeo, barMat);
                this.healthBar.position.z = 0.01; 
                this.healthBarGroup.add(this.healthBar);
                const bgGeo = new THREE.PlaneGeometry(1.3, 0.25);
                const bgMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
                const bg = new THREE.Mesh(bgGeo, bgMat);
                this.healthBarGroup.add(bg);
                const uiScale = 1 + (this.type.scale - 1) * 0.5;
                this.healthBarGroup.scale.setScalar(uiScale);
                this.healthBarGroup.visible = false;
                scene.add(this.healthBarGroup); 

                this.maxHealth = this.type.hp;
                this.health = this.maxHealth;
                this.velocity = new THREE.Vector3();
                this.jumps = 0;
                this.state = initialState; 
                this.hasAggroed = initialState === 'AGGRO'; 
                this.reactionTimer = aggroDelay > 0 ? aggroDelay * 1000 : 0;
                
                this.targetPos = new THREE.Vector3();
                this.lastKnownPos = new THREE.Vector3();
                this.searchTimer = 0;
                this.pickRoamTarget();
                
                this.lastAttack = performance.now();
                this.actionTimer = 0; 
                this.isSprinting = false;
                this.isSliding = false;
                this.isDeadCorpse = false; 
                this.corpseTimer = 0;
                this.confusedTimer = 0; 
                
                this.updateTheme(currentTheme);
                scene.add(this.mesh);
                enemies.push(this);
            }

            updateTheme(t) {
                if(t === 2) { // Neon
                    this.outline.material.color.setHex(0x00ffff);
                    this.outline.material.opacity = 0.8;
                    this.body.material.color.setHex(0x000000);
                    this.body.material.emissive.setHex(0x000000); 
                    this.body.material.emissiveIntensity = 0;
                } else {
                    this.outline.material.color.setHex(0xffffff);
                    this.outline.material.opacity = 0.3;
                    this.body.material.color.setHex(this.type.color);
                    this.body.material.emissiveIntensity = 0;
                }
            }

            pickRoamTarget() {
                this.targetPos.set(
                    (Math.random() - 0.5) * 150,
                    this.mesh.position.y,
                    (Math.random() - 0.5) * 150
                );
            }

            canSeePlayer(playerPos) {
                if (this.isDeadCorpse || this.state === 'CONFUSED') return false;
                if (this.mesh.position.distanceTo(playerPos) > 60) return false; 
                const toPlayer = playerPos.clone().sub(this.mesh.position).normalize();
                
                const ray = new THREE.Raycaster(this.mesh.position, toPlayer, 0, 60);
                const hits = ray.intersectObjects(walls);
                if (hits.length > 0 && hits[0].distance < this.mesh.position.distanceTo(playerPos)) {
                    return false; 
                }
                return true;
            }

            update(dt, playerPos) {
                if (this.isDeadCorpse) {
                    this.corpseTimer -= dt;
                    this.mesh.rotation.x = Math.PI / 2; 
                    this.mesh.position.y = getGroundHeight(this.mesh.position.x, this.mesh.position.z) + 0.5; 
                    this.body.material.opacity = this.corpseTimer / 3.0;
                    this.body.material.transparent = true;
                    this.eyeMat.opacity = this.corpseTimer / 3.0;
                    this.eyeMat.transparent = true;
                    if (this.corpseTimer <= 0) {
                        this.remove();
                    }
                    return;
                }
                
                if (this.state === 'CONFUSED') {
                    this.confusedTimer -= dt;
                    this.mesh.rotation.x = -Math.PI / 2; 
                    this.mesh.position.y = getGroundHeight(this.mesh.position.x, this.mesh.position.z) + 0.5;
                    if (this.confusedTimer <= 0) {
                        this.state = this.hasAggroed ? 'AGGRO' : 'ROAM';
                        this.mesh.rotation.x = 0;
                    }
                    
                    // Fix HP Bar Position when Fallen
                    this.healthBarGroup.position.copy(this.mesh.position).add(new THREE.Vector3(0, 0.5 * this.type.scale, 0));
                    return;
                }

                // GRAVITY
                const groundY = getGroundHeight(this.mesh.position.x, this.mesh.position.z);
                const currentY = this.mesh.position.y;
                const floorThreshold = groundY + (1 * this.type.scale);

                if (currentY > floorThreshold + 0.1) {
                    this.velocity.y -= CONFIG.gravity * dt;
                } else {
                    if (this.velocity.y < -22) { // Increased threshold so they don't trip on jumps
                        this.state = 'CONFUSED';
                        const impactSpeed = Math.abs(this.velocity.y);
                        this.confusedTimer = 3.0 + Math.min(2.0, (impactSpeed - 22) / 5.0);
                        this.velocity.y = 0;
                        return;
                    }
                    this.velocity.y = 0;
                    this.mesh.position.y = floorThreshold;
                    this.jumps = 0;
                }
                this.mesh.position.y += this.velocity.y * dt;

                this.healthBarGroup.position.copy(this.mesh.position).add(new THREE.Vector3(0, 1.3 * this.type.scale, 0));
                this.healthBarGroup.lookAt(camera.position);

                if (this.hasAggroed) {
                    this.healthBarGroup.visible = true;
                    this.healthBar.scale.x = Math.max(0, this.health / this.maxHealth);
                }
                
                if (this.state === 'AGGRO') this.eyeMat.color.setHex(0xff0000);
                else if (this.state === 'SEARCH') this.eyeMat.color.setHex(0xffaa00);
                else this.eyeMat.color.setHex(this.type.eye);

                if (this.reactionTimer > 0) {
                    this.reactionTimer -= dt * 1000;
                    return; 
                }

                let dest = this.targetPos;
                let speed = (this.isSprinting ? CONFIG.botSprintSpeed : CONFIG.botSpeed) * this.type.speedMod;
                
                if (this.state === 'ROAM') {
                    speed = CONFIG.botRoamSpeed * this.type.speedMod;
                    if (new THREE.Vector2(this.mesh.position.x - dest.x, this.mesh.position.z - dest.z).length() < 3) {
                        this.pickRoamTarget();
                    }
                    
                    // Roaming Jump Logic - Reduced Frequency
                    if (this.onGroundSafe(groundY) && Math.random() < 0.005) {
                        this.velocity.y = 16; // Moderate jump
                        this.jumps = 1;
                        this.mesh.position.y += 0.2; // Nudge
                    }

                } else if (this.state === 'AGGRO') {
                    if (this.canSeePlayer(playerPos)) {
                        this.lastKnownPos.copy(playerPos);
                        dest = playerPos;
                        const dist = this.mesh.position.distanceTo(playerPos);
                        
                        // Smart Retreat
                        if (this.health < this.maxHealth * 0.3) {
                            const retreatDir = this.mesh.position.clone().sub(playerPos).normalize();
                            dest = this.mesh.position.clone().addScaledVector(retreatDir, 30);
                            speed *= 1.2;
                            this.targetPos.copy(dest);
                        }

                        // Attack Logic
                        if (dist < 4 * this.type.scale) {
                            const now = performance.now();
                            if (now - this.lastAttack > CONFIG.botAttackCooldown) {
                                this.lastAttack = now;
                                spawnSlash(this.mesh); 
                                AudioSys.playSlash();
                                if (Math.random() < 0.3) {
                                    const dmg = Math.min(CONFIG.botDamage * this.type.scale, 30);
                                    damagePlayer(dmg); 
                                }
                                else AudioSys.playMiss();
                            }
                        }
                    } else {
                        dest = this.lastKnownPos;
                        if (this.mesh.position.distanceTo(dest) < 3) {
                            this.state = 'SEARCH';
                            this.searchTimer = 3000; 
                            this.body.material.color.setHex(0xffaa00); 
                        }
                    }
                } else if (this.state === 'SEARCH') {
                    speed = 0; 
                    this.searchTimer -= dt * 1000;
                    const lookTime = performance.now() * 0.002;
                    this.mesh.rotation.y = Math.sin(lookTime) * Math.PI;
                    
                    if (this.canSeePlayer(playerPos)) {
                        this.state = 'AGGRO';
                        this.body.material.color.setHex(0x8b0000);
                    } else if (this.searchTimer <= 0) {
                        this.state = 'ROAM';
                        this.body.material.color.setHex(this.type.color);
                        this.pickRoamTarget();
                    }
                }

                this.actionTimer -= dt;
                if (this.actionTimer <= 0) {
                    this.actionTimer = 0.5 + Math.random() * 1.5; 
                    this.isSprinting = Math.random() < (this.type.skill >= 2 ? 0.7 : 0.3);
                    this.isSliding = this.isSprinting && Math.random() < (this.type.skill >= 2 ? 0.4 : 0.1);
                }

                if(this.type.speedMod === 0) {
                     this.velocity.y = 0; 
                } else {
                    if (this.state !== 'SEARCH') {
                        const dir = new THREE.Vector3().subVectors(dest, this.mesh.position);
                        dir.y = 0; dir.normalize();
                        
                        // COMBAT JUMPING - FORCE JUMP IF STUCK OR AGGRESSIVE
                        const isMovingHorizontal = dir.lengthSq() > 0.1;
                        if (isMovingHorizontal && Math.abs(this.mesh.position.x - (this.lastX || 0)) < 0.01 && this.state !== 'SEARCH') {
                             // Stuck? Force Jump
                             if (this.onGroundSafe(groundY)) {
                                 this.velocity.y = 18;
                                 this.jumps = 1;
                                 this.mesh.position.y += 0.5;
                             }
                        }
                        this.lastX = this.mesh.position.x;
                        
                        // AGGRO DODGING
                        if (this.state === 'AGGRO' && this.canSeePlayer(playerPos)) {
                            const dist = this.mesh.position.distanceTo(playerPos);
                            const perp = new THREE.Vector3(-dir.z, 0, dir.x);
                            const noise = Math.sin(performance.now() * 0.005 + this.id * 10) * 0.8;
                            dir.addScaledVector(perp, noise);
                            if (dist < 4 * this.type.scale) {
                                dir.subVectors(this.mesh.position, playerPos).normalize().multiplyScalar(1.5);
                            }
                            // Random Combat Jump - Reduced Frequency
                            if (this.onGroundSafe(groundY) && Math.random() < 0.01) {
                                this.velocity.y = 16;
                                this.jumps = 1;
                                this.mesh.position.y += 0.2;
                            }
                        }
                        
                        dir.normalize();
                        if (this.isSliding) speed *= 1.5;
                        this.mesh.position.addScaledVector(dir, speed * dt);
                        
                        // Smooth Rotation to fix jitter
                        if (dir.lengthSq() > 0.1) {
                            const targetRot = Math.atan2(dir.x, dir.z);
                            let rotDiff = targetRot - this.mesh.rotation.y;
                            while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                            while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                            this.mesh.rotation.y += rotDiff * dt * 8; 
                        }
                    }
                    
                    if (this.isSliding) {
                        this.mesh.rotation.x = 0.5;
                        if (currentTheme === 0 && Math.random() < 0.3) spawnSnowTrail(this.mesh.position);
                    }
                    else this.mesh.rotation.x = 0;
                }

                // Simple collision resolution with less jitter
                const botBox = new THREE.Box3().setFromObject(this.body);
                botBox.expandByScalar(-0.1); 
                
                for(const wall of walls) {
                    const wb = wall.geometry.boundingBox.clone().applyMatrix4(wall.matrixWorld);
                    if(botBox.intersectsBox(wb)) {
                         const xOverlap = Math.min(botBox.max.x - wb.min.x, wb.max.x - botBox.min.x);
                         const zOverlap = Math.min(botBox.max.z - wb.min.z, wb.max.z - botBox.min.z);
                         
                         if(xOverlap < zOverlap) {
                             const sign = (this.mesh.position.x < wall.matrixWorld.elements[12]) ? -1 : 1;
                             this.mesh.position.x += xOverlap * sign;
                         } else {
                             const sign = (this.mesh.position.z < wall.matrixWorld.elements[14]) ? -1 : 1;
                             this.mesh.position.z += zOverlap * sign;
                         }
                    }
                }
            }

            onGroundSafe(groundY) {
                 return Math.abs(this.mesh.position.y - (groundY + this.type.scale)) < 0.5;
            }

            takeHit(amt) {
                if(this.isDeadCorpse || this.state === 'CONFUSED') {
                    if(this.state === 'CONFUSED') amt *= 2;
                }
                
                amt *= this.type.dmgRed;
                this.health -= amt;
                this.body.material.color.setHex(0xffffff); 
                
                setTimeout(() => { 
                    if(!this.isDeadCorpse && this.state !== 'CONFUSED') {
                        if (currentTheme === 2) { // Neon
                            this.body.material.color.setHex(0x000000);
                        } else {
                            if(this.state === 'SEARCH') this.body.material.color.setHex(0xffaa00);
                            else if(this.state === 'AGGRO') this.body.material.color.setHex(0x8b0000);
                            else this.body.material.color.setHex(this.type.color);
                        }
                    }
                }, 100);

                if (this.state !== 'AGGRO' && this.state !== 'CONFUSED') {
                    this.state = 'AGGRO'; 
                    this.reactionTimer = CONFIG.botReactionDelay; 
                    this.hasAggroed = true;
                }

                if (this.health <= 0) {
                    addScore(100 * this.type.scale);
                    spawnParticles(this.mesh.position, 0x8b0000, 20 * this.type.scale);
                    AudioSys.playHit();
                    
                    let shouldSplit = false;
                    let nextType = BOT_TYPES.NORMAL;
                    let roll = Math.random();

                    if (this.type.name === "COLOSSUS") {
                        if (roll < 0.90) { shouldSplit = true; nextType = BOT_TYPES.TITAN; }
                    } else if (this.type.name === "TITAN") {
                        if (roll < 0.70) { shouldSplit = true; nextType = BOT_TYPES.BRUTE; }
                    } else if (this.type.name === "BRUTE") {
                        if (roll < 0.40) { shouldSplit = true; nextType = BOT_TYPES.NORMAL; }
                    }

                    if (!shouldSplit) {
                        this.isDeadCorpse = true;
                        this.corpseTimer = 3.0;
                        this.healthBarGroup.visible = false;
                        this.outline.visible = false;
                        showKillMessage("THREAT NEUTRALIZED");
                    } else {
                        const count = Math.random() > 0.5 ? 2 : 1;
                        const delays = [0.2, 0.5];
                        for(let i=0; i<count; i++) {
                            new Enemy(this.mesh.position, nextType, 'AGGRO', delays[i]);
                        }
                        showKillMessage(this.type.name + " SPLIT!");
                        this.remove();
                    }
                }
            }

            remove() {
                scene.remove(this.mesh);
                scene.remove(this.healthBarGroup);
                const idx = enemies.indexOf(this);
                if(idx > -1) enemies.splice(idx, 1);
            }
        }

        function spawnParticles(pos, col, count) {
            for(let i=0; i<count; i++) {
                const mat = new THREE.SpriteMaterial({ 
                    map: textures.glow, 
                    color: col, 
                    transparent: true, 
                    blending: THREE.AdditiveBlending 
                });
                const m = new THREE.Sprite(mat);
                m.scale.set(0.5, 0.5, 0.5);
                m.position.copy(pos);
                scene.add(m);
                particles.push({
                    mesh: m, 
                    vel: new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10),
                    life: 0.5,
                    isStatic: false
                });
            }
        }

        function damagePlayer(amt) {
            player.health -= amt;
            player.lastDamageTime = performance.now();
            
            const overlay = document.getElementById('damage-overlay');
            overlay.style.background = "radial-gradient(circle, transparent 20%, rgba(255,0,0,0.6) 100%)";
            setTimeout(() => {
                overlay.style.background = "radial-gradient(circle, transparent 50%, rgba(255,0,0,0.0) 100%)";
            }, 200);
            
            if(player.health <= 0) {
                if (player.extraLives > 0) {
                    // Use Extra Life
                    player.extraLives--;
                    player.health = 100;
                    showKillMessage("EXTRA LIFE USED!", "achievement", "#00ff00");
                    AudioSys.playTeleport(); // Sound effect for revive
                    // Update Lives UI
                    updateLivesDisplay();
                } else {
                    player.health = 0;
                    player.isDead = true;
                    document.exitPointerLock();
                    showKillMessage("TERMINATED", "achievement");
                    
                    const diff = Date.now() - sessionStartTime;
                    const mins = Math.floor(diff / 60000);
                    const secs = Math.floor((diff % 60000) / 1000);
                    document.getElementById('session-timer').innerText = `Session Time: ${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;
                }
            }
        }
        
        function updateLivesDisplay() {
            const el = document.getElementById('lives-display');
            if (player.extraLives > 0) {
                let hearts = "";
                for(let i=0; i<player.extraLives; i++) hearts += " ";
                el.innerText = hearts;
            } else {
                el.innerText = "";
            }
        }
        
        function addScore(amt) {
            const oldScore = player.score;
            player.score += amt;
            document.getElementById('score-display').innerText = "SCORE: " + player.score;
            
            // Extra Life Check (Every 10,000)
            if (Math.floor(player.score / 10000) > Math.floor(oldScore / 10000)) {
                if (player.extraLives < 3) {
                    player.extraLives++;
                    showKillMessage("EXTRA LIFE EARNED!", "achievement", "#00ff00");
                    updateLivesDisplay();
                }
            }
        }

        function resetGame() {
            player.health = 100;
            player.stamina = 100;
            player.score = 0;
            player.extraLives = 0;
            player.isDead = false;
            player.isSliding = false;
            player.isCrouching = false;
            player.velocity.set(0,0,0);
            camera.position.set(0, 2, 0);
            sessionStartTime = Date.now();
            
            updateLivesDisplay();
            
            for(let i=enemies.length-1; i>=0; i--) enemies[i].remove();
            enemies.length = 0;
            
            particles.forEach(p => {
                scene.remove(p.mesh);
                p.mesh.geometry.dispose();
                p.mesh.material.dispose();
            });
            particles.length = 0;
            
            GameStats.reset();
            comboCount = 0;
            updateComboUI();
            document.getElementById('score-display').innerText = "SCORE: 0";
            
            // Clear critical effects
            document.getElementById('health-fill').classList.remove('health-critical');
            document.getElementById('low-health-vignette').style.boxShadow = "inset 0 0 100px rgba(255, 0, 0, 0)";
        }
        
        function showKillMessage(text, type="", color=null) {
            const feed = document.getElementById('kill-feed');
            const msg = document.createElement('div');
            msg.className = "kill-msg " + type;
            msg.innerHTML = text; 
            if(color) {
                msg.style.color = color;
                msg.style.borderLeftColor = color;
            }
            feed.prepend(msg);
            if(feed.children.length > 6) feed.removeChild(feed.lastChild);
        }

        function onKeyDown(e) {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = true; break;
                case 'a': keys.a = true; break;
                case 's': keys.s = true; break;
                case 'd': keys.d = true; break;
                case ' ': 
                    keys.space = true;
                    if (!isLocked) return;
                    
                    if(player.onGround) {
                        // Immediate Ground Jump
                        performJump();
                        // Also set flag to auto-hop if held on landing later
                        wantsToJump = true;
                        // Reset streaks
                        moveStreaks.longAerial.count = 0;
                        moveStreaks.aerial.count = 0;
                    } else {
                         // Mid-Air Logic
                         if (!e.repeat) { // Only first press triggers double jump
                             if(player.jumpsRemaining > 0) {
                                // Manual Wall Jump Check first if pressing jump mid-air
                                // Wait, simple logic: Try Wall Jump, else Double Jump
                                performWallJump(); // Will fail if no wall
                                
                                // If wall jump didn't trigger (velocity.y not reset to wallJumpForce), try double jump
                                // This is tricky without return values. Let's rely on standard flow.
                                // Actually, simpler: Double Jump logic is specific.
                                
                                const ray = new THREE.Raycaster(camera.position, new THREE.Vector3(0,0,0), 0, 1.5);
                                const dirs = [new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0), new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)];
                                let hitWall = false;
                                for(let d of dirs) {
                                    d.applyQuaternion(camera.quaternion);
                                    ray.set(camera.position, d);
                                    if(ray.intersectObjects(walls).length > 0) { hitWall = true; break; }
                                }
                                
                                if (!hitWall && player.jumpsRemaining > 0) {
                                    player.velocity.y = CONFIG.jumpForce;
                                    player.jumpsRemaining--;
                                    AudioSys.playJump();
                                } else if (hitWall) {
                                    // Wall jump handled in performWallJump usually, but here for manual single press:
                                    performWallJump();
                                }
                             }
                         }
                         // Holding triggers auto-hop on next landing OR wall touch
                         wantsToJump = true;
                    }
                    break;
                case 'shift': keys.shift = true; break;
                case 'c': keys.c = true; break;
                case 'q': 
                    if(!keys.q) {
                        keys.q = true;
                        if(isLocked && !player.isDead) {
                            if(teleportMode === 'INSTANT') tryInstantTeleport();
                            else if(teleportMode === 'AIM') player.teleportActive = !player.teleportActive;
                        }
                    }
                    break;
                case 't': if(!e.repeat) toggleTheme(); break;
            }
        }

        function onKeyUp(e) {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = false; break;
                case 'a': keys.a = false; break;
                case 's': keys.s = false; break;
                case 'd': keys.d = false; break;
                case ' ': 
                    keys.space = false; 
                    wantsToJump = false; 
                    break;
                case 'shift': keys.shift = false; break;
                case 'c': keys.c = false; break;
                case 'q': keys.q = false; break;
            }
        }

        function onMouseMove(e) {
            if (!isLocked || player.isDead) return;
            camera.rotation.y -= e.movementX * 0.002;
            camera.rotation.x -= e.movementY * 0.002;
            camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const now = performance.now();
            const dt = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;
            
            if (isLocked && !player.isDead) {
                if (Math.random() < 0.05 && enemies.length < 60) {
                    new Enemy();
                }
                
                if (mouseDown) {
                     if (teleportMode === 'AIM' && player.teleportActive) {
                     } else {
                        slash();
                     }
                }
                
                updatePlayer(dt);
                updateWeather(dt);
                
                for (let i = enemies.length - 1; i >= 0; i--) {
                    enemies[i].update(dt, camera.position);
                }

                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.life -= dt;
                    if (p.isStatic) {
                         p.mesh.material.opacity = p.life * 0.4; // Slightly lower opacity for trails
                    } else {
                         p.mesh.position.addScaledVector(p.vel, dt);
                         p.mesh.scale.setScalar(p.life * 2); 
                    }
                    
                    if (p.life <= 0) {
                        scene.remove(p.mesh);
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                        particles.splice(i, 1);
                    }
                }
                
                if (comboCount > 0) {
                    comboTimer -= dt;
                    if (comboTimer <= 0) {
                        comboCount = 0;
                        updateComboUI();
                    }
                }
                
                const hpPct = Math.max(0, player.health);
                const stPct = Math.max(0, player.stamina);
                document.getElementById('health-fill').style.width = hpPct + '%';
                document.getElementById('stamina-fill').style.width = stPct + '%';
                
                const btn = document.getElementById('start-btn');
                if (btn.innerText === "b r e a t h e" && isLocked) {
                     btn.innerText = "ENTER ARENA";
                     btn.style.opacity = 1;
                     btn.style.letterSpacing = "2px";
                }
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>