<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Blade: Melee Arena v43</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ddeeff; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; transition: background-color 0.5s; }
        
        /* --- CYBERPUNK HUD (Compact) --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 32px; height: 32px;
            transform: translate(-50%, -50%) rotate(22.5deg); 
            opacity: 1; transition: opacity 0.1s;
            z-index: 5;
        }
        #crosshair svg { width: 100%; height: 100%; filter: drop-shadow(0 0 4px rgba(51, 204, 255, 0.8)); }

        /* Top HUD */
        #hud-top { 
            padding: 15px; display: flex; justify-content: space-between; align-items: flex-start;
        }
        .hud-panel {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #33ccff;
            padding: 6px 15px;
            color: #fff;
            font-family: 'Arial Black', sans-serif;
            font-style: italic;
            transform: skewX(-15deg);
            box-shadow: 0 0 5px rgba(51, 204, 255, 0.2);
        }
        .hud-panel-content { transform: skewX(15deg); }

        #score-display { font-size: 1.2rem; color: #33ccff; text-shadow: 2px 2px 0px rgba(0,0,0,0.8); }
        #mode-display { font-size: 0.7rem; color: #aaa; letter-spacing: 1px; }

        /* Bottom HUD */
        #hud-bottom { 
            padding: 25px; display: flex; gap: 20px; align-items: flex-end; 
        }
        
        .stat-group {
            display: flex; flex-direction: column; gap: 5px;
        }
        .stat-label {
            font-family: 'Arial Black', sans-serif; font-size: 0.8rem; color: white;
            text-transform: uppercase; letter-spacing: 1px; margin-left: 5px;
            text-shadow: 1px 1px 0 #000;
        }
        
        .bar-frame {
            width: 250px; height: 18px; /* Increased size */
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.2);
            transform: skewX(-20deg);
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .bar-fill {
            height: 100%; width: 100%;
            transition: width 0.1s linear;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        #health-fill { background: linear-gradient(90deg, #cc0000, #ff3333); box-shadow: 0 0 10px #ff3333; }
        #stamina-fill { background: linear-gradient(90deg, #0066cc, #33ccff); box-shadow: 0 0 10px #33ccff; }

        /* Ability Icon */
        .ability-group { margin-left: auto; transform: skewX(-10deg); }
        .ability-icon { 
            width: 60px; height: 60px; /* Increased size */
            border: 1px solid #fff; 
            background: rgba(0,0,0,0.6);
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center; 
            font-weight: bold; color: white; 
            transition: 0.2s;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .ability-icon-inner { transform: skewX(10deg); text-align: center; }
        .ability-icon.active { 
            border-color: #00ffaa; box-shadow: 0 0 15px #00ffaa; color: #00ffaa; 
            background: rgba(0, 255, 170, 0.1);
        }
        .ability-key { font-size: 1.4rem; font-family: 'Arial Black', sans-serif; }
        .ability-name { font-size: 0.6rem; letter-spacing: 1px; opacity: 0.8; }

        /* MENUS */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 10, 20, 0.95); display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: white; z-index: 10;
            pointer-events: auto; backdrop-filter: blur(5px);
            background-image: 
                linear-gradient(rgba(51, 204, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(51, 204, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
        }
        
        #start-content {
            display: flex; flex-direction: column; align-items: center;
            padding: 50px 60px;
            background: linear-gradient(135deg, rgba(10,20,30,0.95), rgba(5,10,15,0.95));
            clip-path: polygon(
                30px 0, 100% 0, 
                100% calc(100% - 30px), calc(100% - 30px) 100%, 
                0 100%, 0 30px
            );
            position: relative;
            max-width: 900px; width: 80%;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        /* Fake border for clipped element */
        #start-content::after {
            content: ''; position: absolute; top:0; left:0; width:100%; height:100%;
            box-shadow: inset 0 0 0 2px rgba(51, 204, 255, 0.3);
            pointer-events: none;
            clip-path: polygon(30px 0, 100% 0, 100% calc(100% - 30px), calc(100% - 30px) 100%, 0 100%, 0 30px);
        }

        h1 { 
            font-size: 5rem; margin: 0 0 20px 0; color: #fff; 
            text-shadow: 4px 4px 0px #33ccff; 
            font-style: italic; text-transform: uppercase; letter-spacing: -2px;
            font-family: 'Arial Black', sans-serif;
        }
        
        p { font-size: 1.1rem; color: #aaa; margin-top: 5px; text-align: center; line-height: 1.5; font-family: monospace; }
        
        .btn-row { display: flex; gap: 20px; margin-top: 40px; width: 100%; justify-content: center; }
        
        /* PRESERVED BUTTON STYLE FROM FIRST CODE */
        .btn {
            padding: 25px 60px; background: #33ccff; border: none;
            color: #000; font-size: 2rem; cursor: pointer; transition: all 0.5s; 
            font-weight: 900; text-transform: uppercase; letter-spacing: 2px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            position: relative; overflow: hidden;
            pointer-events: auto; min-width: 300px;
            font-family: 'Arial Black', sans-serif;
        }
        .btn::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
            transition: 0.5s;
        }
        .btn:hover::before { left: 100%; }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 40px #33ccff; color: white; background: #000; border: 2px solid #33ccff; }
        
        .btn-secondary { 
            padding: 12px 24px; font-size: 1rem; background: transparent; 
            border: 1px solid #555; color: #888; pointer-events: auto;
            font-family: 'Segoe UI', sans-serif; font-weight: bold; text-transform: uppercase;
            transition: 0.2s;
        }
        .btn-secondary:hover { border-color: #fff; color: #fff; background: rgba(255,255,255,0.1); }

        #stats-container {
            margin-top: 30px; width: 100%; display: grid; 
            grid-template-columns: 1fr 1fr; gap: 40px;
            border-top: 1px solid rgba(255,255,255,0.1); padding-top: 30px;
        }
        .stat-box { text-align: left; }
        .stat-title { color: #33ccff; font-size: 1rem; font-weight: bold; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
        .stat-value { color: #fff; font-size: 0.9rem; font-family: monospace; line-height: 1.6; opacity: 0.8; }

        #kill-feed { position: absolute; top: 100px; left: 20px; text-align: left; display: flex; flex-direction: column; gap: 4px; }
        .kill-msg { 
            color: white; font-size: 13px; font-weight: bold; 
            text-shadow: 1px 1px 0px rgba(0,0,0,0.5); 
            animation: fadeOut 5s forwards; 
            border-left: 3px solid #fff; padding-left: 8px; 
            background: linear-gradient(90deg, rgba(0,0,0,0.6), transparent);
            font-family: 'Arial Black', sans-serif; font-style: italic;
            padding-top: 2px; padding-bottom: 2px;
        }
        .kill-msg.combo { border-left-color: #ffcc00; color: #ffcc00; font-size: 12px; }
        .kill-msg.achievement { border-left-color: #ff00ff; color: #ff00ff; font-size: 14px; text-shadow: 0 0 8px #ff00ff; }

        @keyframes fadeOut { 0% { opacity: 1; transform: translateX(0); } 80% { opacity: 1; } 100% { opacity: 0; transform: translateX(-30px); } }

        #combo-display {
            position: absolute; top: 10%; left: 50%; transform: translateX(-50%);
            color: #ffcc00; font-family: 'Arial Black', sans-serif;
            text-shadow: 4px 4px 0px rgba(0,0,0,0.5); display: none; 
            text-align: center; font-style: italic; z-index: 5;
            transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #damage-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: radial-gradient(circle, transparent 50%, rgba(255,0,0,0.0) 100%);
            pointer-events: none; transition: background 0.1s;
        }

        /* Light Theme Adjustments for HUD */
        .light-theme .hud-panel { background: rgba(255,255,255,0.7); border-color: #0088ff; color: #000; }
        .light-theme #score-display { color: #0066cc; text-shadow: none; }
        .light-theme .stat-label { color: #333; text-shadow: none; }
        .light-theme .bar-frame { border-color: rgba(0,0,0,0.2); background: rgba(255,255,255,0.5); }
        .light-theme .ability-icon { border-color: #0066cc; background: rgba(255,255,255,0.6); color: #0066cc; }
    </style>
</head>
<body>

    <div id="damage-overlay"></div>
    <div id="ui-layer" class="light-theme">
        <div id="hud-top">
            <div class="hud-panel">
                <div class="hud-panel-content" id="score-display">SCORE: 0</div>
            </div>
            <div class="hud-panel" style="border-color: #aaa;">
                <div class="hud-panel-content" id="mode-display">PRESS 'T' TO CYCLE THEME</div>
            </div>
        </div>
        
        <div id="combo-display">2 HITS</div>
        <div id="kill-feed"></div>
        
        <div id="crosshair">
            <svg viewBox="0 0 100 100" fill="currentColor">
                <path d="M50,5 Q10,50 50,95 Q30,50 50,5 Z" />
            </svg>
        </div>
        
        <div id="hud-bottom">
            <div class="stat-group">
                <span class="stat-label">HEALTH</span>
                <div class="bar-frame"><div id="health-fill" class="bar-fill"></div></div>
            </div>
            <div class="stat-group">
                <span class="stat-label">STAMINA</span>
                <div class="bar-frame"><div id="stamina-fill" class="bar-fill"></div></div>
            </div>
            <div class="ability-group">
                <div class="ability-icon" id="icon-q">
                    <div class="ability-icon-inner">
                        <div class="ability-key">Q</div>
                        <div class="ability-name" id="tp-label">AIM</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <div id="start-content">
            <h1>NEON BLADE</h1>
            <p>
                <strong>WASD</strong> Move | <strong>SPACE</strong> Jump / Wall Jump | <strong>SHIFT</strong> Sprint<br>
                <strong>C</strong> Slide/Crouch | <strong>Q</strong> Teleport | <strong>HOLD M1</strong> Auto Strike
            </p>
            
            <div class="btn-row">
                <button class="btn" id="start-btn">ENTER ARENA</button>
            </div>
            
            <div id="stats-container">
                <div class="stat-box">
                    <div class="stat-title">Current Session</div>
                    <div class="stat-value" id="stat-session">
                        Highest Combo: 0<br>
                        Score: 0
                    </div>
                </div>
                <div class="stat-box">
                    <div class="stat-title">Style Matrix</div>
                    <div class="stat-value" id="stat-moves">
                        <!-- Dynamically filled -->
                    </div>
                </div>
            </div>

            <div class="btn-row" style="margin-top: 30px; gap: 15px;">
                <button class="btn-secondary" id="tp-mode-btn">TP MODE: AIM</button>
                <button class="btn-secondary" id="theme-btn">THEME: LIGHT</button>
            </div>
            <p style="font-size: 0.8rem; margin-top: 30px; opacity: 0.5;">PRESS ESC TO PAUSE</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            baseSpeed: 14,
            crouchSpeed: 6,
            sprintSpeed: 28,
            
            jumpForce: 24,
            wallJumpForce: 22,
            wallPushForce: 20,
            gravity: 40,
            
            frictionGround: 6.0, 
            frictionAir: 0.02, 
            airControl: 1.0,  
            frictionSlide: 1.2, 
            slideBoost: 18, 
            bunnyHopBoost: 15, 
            
            staminaMax: 100,
            staminaDrain: 25, 
            staminaRegen: 15,
            
            attackRange: 8,
            attackCooldown: 250,
            playerDamage: 40, 
            
            teleportRange: 20,

            botBaseHP: 100,
            botDamage: 10, 
            botAttackCooldown: 1500,
            botSpeed: 10,
            botSprintSpeed: 18, 
            botRoamSpeed: 6,
            botAggroDuration: 10000, 
            botReactionDelay: 1000,
            
            regenDelay: 4000,
            regenRate: 25
        };

        // --- GAME STATS ---
        const GameStats = {
            highestCombo: 0,
            achievements: [],
            moves: {
                slideHit: 0,
                midAirHit: 0,
                longAirHit: 0,
                teleportHit: 0,
                wallJumpHit: 0
            },
            reset: function() {
                this.highestCombo = 0;
                this.achievements = [];
                for(let k in this.moves) this.moves[k] = 0;
            },
            addAchievement: function(name, color="#ff00ff") {
                // No exclamation marks as requested
                if(!this.achievements.includes(name)) {
                    this.achievements.push(name);
                    showKillMessage(name, "achievement", color);
                } else {
                    // Repeat achievements (like every 10 kills) just show up
                    showKillMessage(name, "achievement", color);
                }
            },
            checkMoveMilestone: function(key, name, color="#00ffff") {
                if (this.moves[key] > 0 && this.moves[key] % 10 === 0) {
                    const total = this.moves[key];
                    const rankIdx = (total / 10) - 1;
                    
                    const tiers = ["NOVICE", "ADEPT", "EXPERT", "MASTER", "GRANDMASTER", "LEGEND", "GOD", "ETERNAL", "INFINITE", "THE ONE"];
                    const tierName = tiers[Math.floor(rankIdx / 3)] || "BEYOND";
                    const level = (rankIdx % 3) + 1;
                    
                    let roman = "I";
                    if(level === 2) roman = "II";
                    if(level === 3) roman = "III";
                    
                    this.addAchievement(`${name} ${tierName} ${roman}`, color);
                }
            }
        };

        // --- AUDIO SYSTEM (Arcade Style from First Code) ---
        const AudioSys = {
            ctx: null,
            slideOsc: null,
            slideGain: null,
            
            init: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            
            playTone: function(freq, type, duration, vol=0.1, ramp='exp') {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                if(ramp === 'exp') gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                else gain.gain.linearRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            toggleSlideSound: function(active) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                if(active && !this.slideOsc) {
                    const bufferSize = this.ctx.sampleRate; 
                    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for(let i=0; i<bufferSize; i++) data[i] = Math.random()*2-1;

                    this.slideOsc = this.ctx.createBufferSource();
                    this.slideOsc.buffer = buffer;
                    this.slideOsc.loop = true;
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 400; 
                    this.slideGain = this.ctx.createGain();
                    this.slideGain.gain.setValueAtTime(0, t);
                    this.slideGain.gain.linearRampToValueAtTime(0.2, t + 0.2);
                    this.slideOsc.connect(filter);
                    filter.connect(this.slideGain);
                    this.slideGain.connect(this.ctx.destination);
                    this.slideOsc.start();
                } else if (!active && this.slideOsc) {
                    try {
                        this.slideGain.gain.linearRampToValueAtTime(0, t + 0.1);
                        this.slideOsc.stop(t + 0.1);
                    } catch(e) {}
                    this.slideOsc = null;
                    this.slideGain = null;
                }
            },

            playJump: function() { 
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(400, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            },

            playWallJump: function() {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            },

            playSlash: function() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc1 = this.ctx.createOscillator();
                osc1.type = 'triangle';
                osc1.frequency.setValueAtTime(1200, t); 
                osc1.frequency.exponentialRampToValueAtTime(200, t + 0.15);
                const g1 = this.ctx.createGain();
                g1.gain.setValueAtTime(0.25, t);
                g1.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                osc1.connect(g1); g1.connect(this.ctx.destination);
                osc1.start(); osc1.stop(t + 0.2);
            },
            
            playMiss: function() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const bSize = this.ctx.sampleRate * 0.1;
                const b = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const d = b.getChannelData(0);
                for(let i=0;i<bSize;i++) d[i] = Math.random()*2-1;
                const n = this.ctx.createBufferSource();
                n.buffer = b;
                const ng = this.ctx.createGain();
                ng.gain.setValueAtTime(0.1, t);
                ng.gain.exponentialRampToValueAtTime(0.001, t+0.1);
                const nf = this.ctx.createBiquadFilter();
                nf.type = 'lowpass';
                nf.frequency.value = 800;
                n.connect(nf); nf.connect(ng); ng.connect(this.ctx.destination);
                n.start();
            },

            playHit: function() { 
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const oscA = this.ctx.createOscillator();
                oscA.type = 'square';
                oscA.frequency.setValueAtTime(450, t);
                oscA.frequency.exponentialRampToValueAtTime(300, t+0.15);
                const oscB = this.ctx.createOscillator();
                oscB.type = 'square';
                oscB.frequency.setValueAtTime(680, t);
                oscB.frequency.exponentialRampToValueAtTime(500, t+0.15);
                const gainA = this.ctx.createGain();
                gainA.gain.setValueAtTime(0.1, t);
                gainA.gain.exponentialRampToValueAtTime(0.001, t+0.15);
                const gainB = this.ctx.createGain();
                gainB.gain.setValueAtTime(0.1, t);
                gainB.gain.exponentialRampToValueAtTime(0.001, t+0.15);
                oscA.connect(gainA); oscA.start(); oscA.stop(t+0.15);
                oscB.connect(gainB); oscB.start(); oscB.stop(t+0.15);
                gainA.connect(this.ctx.destination);
                gainB.connect(this.ctx.destination);
            },

            playTeleport: function() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.exponentialRampToValueAtTime(2000, t + 0.1);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(t + 0.2);
            },
            
            playUI: function(active) { this.playTone(active ? 800 : 400, 'sine', 0.05, 0.05); },
            stopAll: function() { this.toggleSlideSound(false); }
        };

        // --- GLOBAL STATE ---
        let scene, camera, renderer;
        let isLocked = false;
        let lastTime = performance.now();
        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false, c: false };
        let mouseDown = false;
        let lastUnlockTime = 0; 
        
        let currentTheme = 0; 
        let teleportMode = 'AIM'; 
        let comboCount = 0;
        let comboTimer = 0;
        let lastSlashID = 0; 
        let slashActive = false;

        const materials = {};

        const player = {
            velocity: new THREE.Vector3(),
            onGround: false,
            jumpsRemaining: 2, 
            isSliding: false,
            isCrouching: false,
            isSprinting: false,
            health: 100,
            stamina: 100,
            score: 0,
            isDead: false,
            cameraHeightOffset: 0,
            lastDamageTime: 0,
            teleportActive: false,
            teleportTarget: null,
            airTimeStart: 0,
            lastSlideTime: 0,
            lastJumpTime: 0,
            lastTeleportTime: 0,
            lastWallJumpTime: 0,
            lastTeleportWasAerial: false,
            hasPhaseStruck: false
        };

        const moveStreaks = {
            slide: { count: 0, lastTime: 0 },
            aerial: { count: 0, lastTime: 0 },
            longAerial: { count: 0, lastTime: 0 },
            wall: { count: 0, lastTime: 0 },
            phase: { count: 0, lastTime: 0 }
        };

        const worldObjects = []; 
        const walls = [];        
        const enemies = [];
        const particles = [];
        const decorations = [];
        const leaves = [];

        let teleportMarker;
        let slashGeometry; 
        let lastAttackTime = 0;
        let gridHelper;
        let currentSlashColor = 0x0088ff;

        // --- SETUP ---
        function init() {
            // Initialize lastUnlockTime such that the first click always works
            lastUnlockTime = performance.now() - 5000;

            const btn = document.getElementById('start-btn');
            btn.addEventListener('click', () => {
                AudioSys.init(); 
                
                // "Breathe" Delay Logic
                const now = performance.now();
                if (now - lastUnlockTime < 1300) {
                    btn.innerText = "b r e a t h e";
                    btn.style.opacity = 0.5;
                    btn.style.letterSpacing = "8px";
                    setTimeout(() => {
                        btn.innerText = "ENTER ARENA";
                        btn.style.opacity = 1;
                        btn.style.letterSpacing = "2px";
                    }, 800);
                    return;
                }

                document.body.requestPointerLock().catch(e => {
                    console.warn("Pointer lock failed:", e);
                });
            });
            document.getElementById('theme-btn').addEventListener('click', toggleTheme);
            document.getElementById('tp-mode-btn').addEventListener('click', toggleTeleportMode);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ'; // FIX: Prevent gimbal lock/roll for FPS
            camera.position.set(0, 2, 0);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            setupLighting();
            createLevel();
            createSlashEffect(); 
            createTeleportMarker();

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mousedown', (e) => {
                if(e.button === 0) mouseDown = true;
                if(isLocked && e.button === 0) {
                    if (teleportMode === 'AIM' && player.teleportActive) {
                        tryAimTeleport();
                        slash(); // Trigger Phase Strike
                    } else {
                        slash();
                    }
                }
            });
            document.addEventListener('mouseup', () => { mouseDown = false; });
            window.addEventListener('resize', onWindowResize);
            
            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === document.body;
                const screen = document.getElementById('start-screen');
                if (isLocked) {
                    screen.style.display = 'none';
                    if(player.isDead) resetGame();
                } else {
                    lastUnlockTime = performance.now();
                    screen.style.display = 'flex';
                    AudioSys.stopAll();
                    updatePauseScreenStats();
                    mouseDown = false; 
                }
            });
            
            document.addEventListener('pointerlockerror', (e) => {
                console.warn("Pointer lock error detected.", e);
                if(!isLocked) {
                    document.getElementById('start-screen').style.display = 'flex';
                }
            });

            applyTheme();
            animate();
        }

        function updatePauseScreenStats() {
            const h1 = document.querySelector('#start-screen h1');
            
            if(player.isDead) {
                h1.innerText = "TERMINATED";
                h1.style.color = "#ff3333";
                h1.style.textShadow = "4px 4px 0px #880000";
            } else {
                h1.innerText = "PAUSED";
                h1.style.color = "#33ccff";
                h1.style.textShadow = "4px 4px 0px #33ccff";
            }

            // Render Stats
            let achStr = GameStats.achievements.join(', ');
            if(!achStr) achStr = "None yet";

            const statSession = document.getElementById('stat-session');
            statSession.innerHTML = `
                <strong>SCORE:</strong> ${player.score}<br>
                <strong>MAX COMBO:</strong> ${GameStats.highestCombo}<br>
                <strong>ACHIEVEMENTS:</strong><br>${achStr}
            `;

            const statMoves = document.getElementById('stat-moves');
            let movesHtml = "";
            if(GameStats.moves.slideHit > 0) movesHtml += `Slide Strikes: ${GameStats.moves.slideHit}<br>`;
            if(GameStats.moves.midAirHit > 0) movesHtml += `Aerial Strikes: ${GameStats.moves.midAirHit}<br>`;
            if(GameStats.moves.longAirHit > 0) movesHtml += `Long Air Strikes: ${GameStats.moves.longAirHit}<br>`;
            if(GameStats.moves.teleportHit > 0) movesHtml += `Teleport Strikes: ${GameStats.moves.teleportHit}<br>`;
            if(GameStats.moves.wallJumpHit > 0) movesHtml += `Wall Jump Strikes: ${GameStats.moves.wallJumpHit}<br>`;

            if(movesHtml === "") movesHtml = "No style points yet.";
            statMoves.innerHTML = movesHtml;
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
            scene.add(ambientLight);
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 50, 0);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -200;
            dirLight.shadow.camera.right = 200;
            dirLight.shadow.camera.top = 200;
            dirLight.shadow.camera.bottom = -200;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);
        }

        function toggleTheme() {
            currentTheme = (currentTheme + 1) % 4;
            const names = ["LIGHT", "DARK", "NEON", "HALLOWEEN"];
            document.getElementById('theme-btn').innerText = "THEME: " + names[currentTheme];
            applyTheme();
        }

        function toggleTeleportMode() {
            if (teleportMode === 'AIM') {
                teleportMode = 'INSTANT';
            } else {
                teleportMode = 'AIM';
            }
            document.getElementById('tp-mode-btn').innerText = "TP MODE: " + teleportMode;
            document.getElementById('tp-label').innerText = teleportMode;
        }

        function updateGridHelper(c1, c2) {
            if(gridHelper) {
                scene.remove(gridHelper);
                gridHelper.geometry.dispose();
                gridHelper.material.dispose();
            }
            gridHelper = new THREE.GridHelper(400, 50, c1, c2);
            scene.add(gridHelper);
        }

        function applyTheme() {
            const body = document.body;
            const ui = document.getElementById('ui-layer');
            const crosshair = document.getElementById('crosshair');
            
            if (currentTheme === 0) { // LIGHT
                scene.background = new THREE.Color(0xddeeff);
                scene.fog = new THREE.FogExp2(0xddeeff, 0.003);
                body.style.backgroundColor = "#ddeeff";
                ui.classList.add('light-theme');
                if(materials.floor) materials.floor.color.setHex(0xffffff);
                if(materials.wall) materials.wall.color.setHex(0xeeeeee);
                if(materials.obstacle) materials.obstacle.color.setHex(0xcccccc);
                if(materials.grid) { materials.grid.color.setHex(0x000000); materials.grid.opacity = 0.2; }
                currentSlashColor = 0x0088ff;
                if(materials.marker) materials.marker.color.setHex(0x0088ff);
                crosshair.style.color = "#0088ff";
                updateGridHelper(0x888888, 0xcccccc);
            } else if (currentTheme === 1) { // DARK
                scene.background = new THREE.Color(0x151515);
                scene.fog = new THREE.FogExp2(0x151515, 0.006);
                body.style.backgroundColor = "#151515";
                ui.classList.remove('light-theme');
                if(materials.floor) materials.floor.color.setHex(0x222222);
                if(materials.wall) materials.wall.color.setHex(0x555555);
                if(materials.obstacle) materials.obstacle.color.setHex(0x444444);
                if(materials.grid) { materials.grid.color.setHex(0x00ffff); materials.grid.opacity = 0.3; }
                currentSlashColor = 0x00aaff; 
                if(materials.marker) materials.marker.color.setHex(0x00ffaa);
                crosshair.style.color = "#00aaff";
                updateGridHelper(0xffffff, 0x444444);
            } else if (currentTheme === 2) { // NEON
                scene.background = new THREE.Color(0x050010);
                scene.fog = new THREE.FogExp2(0x050010, 0.006);
                body.style.backgroundColor = "#050010";
                ui.classList.remove('light-theme');
                if(materials.floor) materials.floor.color.setHex(0x100020);
                if(materials.wall) materials.wall.color.setHex(0x400080);
                if(materials.obstacle) materials.obstacle.color.setHex(0x400060);
                if(materials.grid) { materials.grid.color.setHex(0x00ffff); materials.grid.opacity = 0.8; }
                currentSlashColor = 0xff00ff; 
                if(materials.marker) materials.marker.color.setHex(0xff00ff);
                crosshair.style.color = "#ff00ff";
                updateGridHelper(0xff00ff, 0x00ffff);
            } else { // HALLOWEEN
                scene.background = new THREE.Color(0x100500); 
                scene.fog = new THREE.FogExp2(0x100500, 0.005);
                body.style.backgroundColor = "#100500";
                ui.classList.remove('light-theme');
                if(materials.floor) materials.floor.color.setHex(0x4a2500); 
                if(materials.wall) materials.wall.color.setHex(0x663311);   
                if(materials.obstacle) materials.obstacle.color.setHex(0xff6600);
                if(materials.grid) { materials.grid.color.setHex(0xff6600); materials.grid.opacity = 0.3; }
                currentSlashColor = 0xff8800; 
                if(materials.marker) materials.marker.color.setHex(0xff4400);
                crosshair.style.color = "#ff8800";
                updateGridHelper(0xffaa00, 0x662200);
            }
            
            if(materials.slash) materials.slash.color.setHex(currentSlashColor);
            decorations.forEach(d => d.updateTheme(currentTheme));
        }

        // --- LEVEL GENERATION ---
        function createLevel() {
            materials.floor = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1 });
            materials.wall = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.2 });
            materials.obstacle = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.2 });
            materials.grid = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
            materials.slash = new THREE.MeshBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0, side: THREE.DoubleSide, depthTest: false });
            materials.marker = new THREE.MeshBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0.5 });

            createBox(0, -1, 0, 400, 2, 400, materials.floor, true);
            createBox(0, 50, -200, 400, 100, 2, materials.wall, false, true);
            createBox(0, 50, 200, 400, 100, 2, materials.wall, false, true);
            createBox(-200, 50, 0, 2, 100, 400, materials.wall, false, true);
            createBox(200, 50, 0, 2, 100, 400, materials.wall, false, true);
            
            for(let i=0; i<20; i++) {
                let x = (Math.random() - 0.5) * 300;
                let z = (Math.random() - 0.5) * 300;
                if(Math.abs(x) < 30 && Math.abs(z) < 30) { x += 50; }
                const scale = 1 + Math.random() * 6; 
                decorations.push(new Decoration(x, z, scale));
            }

            for(let i=0; i<3; i++) {
                let x = (Math.random() - 0.5) * 340;
                let z = (Math.random() - 0.5) * 340;
                decorations.push(new Decoration(x, z, 21));
            }
             for(let i=0; i<2; i++) {
                let x = (Math.random() - 0.5) * 340;
                let z = (Math.random() - 0.5) * 340;
                decorations.push(new Decoration(x, z, 35));
            }
            decorations.push(new Decoration(150, 150, 70));
        }

        function createBox(x, y, z, w, h, d, mat, isFloor=false, isWall=false) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, materials.grid);
            mesh.add(line);
            scene.add(mesh);
            mesh.geometry.computeBoundingBox();
            if (isFloor || !isWall) worldObjects.push(mesh);
            if (!isFloor) walls.push(mesh);
            return mesh;
        }

        class Decoration {
            constructor(x, z, scale) {
                this.scale = scale;
                const size = 2;
                
                // PHYSICS FIX: No rotation on visual mesh relative to collider
                const colliderGeo = new THREE.BoxGeometry(size, size, size);
                const colliderMat = new THREE.MeshBasicMaterial({ visible: false });
                this.colliderMesh = new THREE.Mesh(colliderGeo, colliderMat);
                this.colliderMesh.position.set(x, scale, z);
                this.colliderMesh.scale.setScalar(scale);
                this.colliderMesh.geometry.computeBoundingBox();
                walls.push(this.colliderMesh);
                scene.add(this.colliderMesh);

                const visualGeo = new THREE.BoxGeometry(size, size, size);
                this.mat = materials.obstacle.clone();
                this.visualMesh = new THREE.Mesh(visualGeo, this.mat);
                this.visualMesh.castShadow = true;
                this.visualMesh.receiveShadow = true;
                this.visualMesh.position.copy(this.colliderMesh.position);
                this.visualMesh.scale.setScalar(scale);
                
                this.visualMesh.updateMatrixWorld();
                this.visualMesh.geometry.computeBoundingBox();
                worldObjects.push(this.visualMesh);
                
                this.faceGroup = new THREE.Group();
                const faceMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const eyeGeo = new THREE.ConeGeometry(0.3, 0.1, 3);
                const eyeL = new THREE.Mesh(eyeGeo, faceMat);
                eyeL.position.set(-0.5, 0.2, 1.01); 
                eyeL.rotation.x = -Math.PI/2; eyeL.rotation.z = Math.PI;
                const eyeR = new THREE.Mesh(eyeGeo, faceMat);
                eyeR.position.set(0.5, 0.2, 1.01);
                eyeR.rotation.x = -Math.PI/2; eyeR.rotation.z = Math.PI;
                const mouthGeo = new THREE.BoxGeometry(1.2, 0.3, 0.1);
                const mouth = new THREE.Mesh(mouthGeo, faceMat);
                mouth.position.set(0, -0.5, 1.01);
                this.faceGroup.add(eyeL); this.faceGroup.add(eyeR); this.faceGroup.add(mouth);
                const stemGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 6);
                const stemMat = new THREE.MeshBasicMaterial({ color: 0x006400 });
                this.stem = new THREE.Mesh(stemGeo, stemMat);
                this.stem.position.set(0, 1.2, 0);
                this.faceGroup.add(this.stem);
                this.visualMesh.add(this.faceGroup);
                
                const edges = new THREE.EdgesGeometry(visualGeo);
                this.edges = new THREE.LineSegments(edges, materials.grid);
                this.visualMesh.add(this.edges);

                scene.add(this.visualMesh);
            }

            updateTheme(t) {
                if (t === 3) { // Halloween
                    const r = 0.8 + Math.random()*0.2;
                    const g = 0.3 + Math.random()*0.3;
                    this.mat.color.setRGB(r, g, 0);
                    this.mat.emissive = new THREE.Color(r*0.1, g*0.1, 0);
                    this.faceGroup.visible = true;
                    this.edges.visible = false;
                } else {
                    if(t === 0) this.mat.color.setHex(0xcccccc);
                    if(t === 1) this.mat.color.setHex(0x444444);
                    if(t === 2) this.mat.color.setHex(0x400060);
                    this.mat.emissive.setHex(0x000000);
                    this.faceGroup.visible = false;
                    this.edges.visible = true;
                }
            }
        }

        function updateWeather(dt) {
            if (currentTheme !== 3) {
                if(leaves.length > 0) {
                    leaves.forEach(l => scene.remove(l.mesh));
                    leaves.length = 0;
                }
                return;
            }
            if(leaves.length < 80 && Math.random() < 0.1) {
                const geo = new THREE.PlaneGeometry(0.3, 0.3);
                const mat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xffaa00 : 0x884400, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                const px = camera.position.x + (Math.random()-0.5)*50;
                const pz = camera.position.z + (Math.random()-0.5)*50;
                mesh.position.set(px, 30, pz);
                mesh.rotation.set(Math.random(), Math.random(), Math.random());
                scene.add(mesh);
                leaves.push({ mesh: mesh, vel: new THREE.Vector3((Math.random()-0.5)*3, -3 - Math.random()*3, (Math.random()-0.5)*3), swayOffset: Math.random() * 100 });
            }
            for(let i=leaves.length-1; i>=0; i--) {
                const l = leaves[i];
                l.mesh.position.addScaledVector(l.vel, dt);
                l.mesh.rotation.x += dt * 2;
                l.mesh.rotation.y += dt;
                l.mesh.position.x += Math.sin(performance.now() * 0.002 + l.swayOffset) * dt * 2;
                if(l.mesh.position.y < 0) {
                    scene.remove(l.mesh);
                    l.mesh.geometry.dispose();
                    l.mesh.material.dispose();
                    leaves.splice(i, 1);
                }
            }
        }

        // --- VISUALS ---
        function createSlashEffect() {
            const shape = new THREE.Shape();
            shape.moveTo(0, 1.2);
            shape.quadraticCurveTo(-0.5, 0, 0, -1.2);
            shape.quadraticCurveTo(-0.2, 0, 0, 1.2);
            slashGeometry = new THREE.ShapeGeometry(shape);
            slashGeometry.center(); 
        }

        function spawnSlash(parent) {
            const mat = materials.slash.clone();
            mat.color.setHex(currentSlashColor);
            
            const mesh = new THREE.Mesh(slashGeometry, mat);
            mesh.material.transparent = true;
            mesh.material.opacity = 1;
            mesh.material.depthTest = false; 
            mesh.material.depthWrite = false;
            mesh.renderOrder = 999; 
            mesh.userData.fadeSpeed = 0.15; 
            mesh.userData.isHit = false;

            let mySlashID = -1;

            if(parent === camera) {
                mesh.position.set(0, 0, -2.0); 
                mesh.rotation.z = -Math.PI / 8; 
                camera.add(mesh);
                
                mySlashID = ++lastSlashID;
                slashActive = true;
                document.getElementById('crosshair').style.opacity = 0;
            } else {
                mesh.position.set(0, 1.5, 1.0);
                mesh.lookAt(camera.position);
                mesh.rotation.z = Math.PI / 2; 
                parent.add(mesh);
            }
            
            let progress = 0;
            function animateSlash() {
                progress += mesh.userData.fadeSpeed;
                if (progress < 1) {
                    mesh.material.opacity = 1 - progress;
                    if(parent === camera && mySlashID === lastSlashID) {
                        // Keep opacity 0 while slash is active
                    }
                    requestAnimationFrame(animateSlash);
                } else {
                    mesh.visible = false;
                    if(parent === camera) {
                        camera.remove(mesh);
                        if(mySlashID === lastSlashID) {
                            slashActive = false;
                        }
                    }
                    else parent.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                }
            }
            animateSlash();
            return mesh;
        }

        function spawnImpact(pos) {
            const geo = new THREE.SphereGeometry(0.5, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            scene.add(mesh);
            let life = 1.0;
            function animateImpact() {
                life -= 0.15;
                mesh.scale.setScalar(1 + (1-life)*2);
                mesh.material.opacity = life;
                if(life > 0) requestAnimationFrame(animateImpact);
                else { scene.remove(mesh); }
            }
            animateImpact();
        }

        function spawnFirework(pos) {
            spawnParticles(pos, 0xffcc00, 30);
            spawnParticles(pos, 0x00ffff, 30);
            spawnParticles(pos, 0xff00ff, 30);
            AudioSys.playTeleport(); // Use tp sound as placeholder
        }

        function createTeleportMarker() {
            const geo = new THREE.OctahedronGeometry(0.4); 
            teleportMarker = new THREE.Group();
            const core = new THREE.Mesh(geo, materials.marker);
            core.scale.set(0.8, 2.5, 0.8); core.position.y = 2.0; teleportMarker.add(core);
            const ringGeo = new THREE.RingGeometry(1.4, 1.6, 32);
            const ringMat = materials.marker.clone();
            ringMat.side = THREE.DoubleSide;
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = -Math.PI/2; ring.position.y = 0.1; teleportMarker.add(ring);
            teleportMarker.userData = { core: core, ring: ring };
            teleportMarker.visible = false;
            scene.add(teleportMarker);
        }

        function getGroundHeight(x, z) {
            const rayOrigin = new THREE.Vector3(x, 200, z);
            const raycaster = new THREE.Raycaster(rayOrigin, new THREE.Vector3(0, -1, 0), 0, 250);
            const intersects = raycaster.intersectObjects(worldObjects);
            if (intersects.length > 0) {
                return intersects[0].point.y;
            }
            return 0;
        }

        // --- GAME LOGIC ---
        function updatePlayer(dt) {
            if (player.isDead) return;
            camera.position.y -= player.cameraHeightOffset;

            if (teleportMode === 'AIM' && player.teleportActive) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                raycaster.far = CONFIG.teleportRange;
                const intersects = raycaster.intersectObjects(worldObjects);
                if (intersects.length > 0) {
                    teleportMarker.position.copy(intersects[0].point);
                    player.teleportTarget = intersects[0].point;
                } else {
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    const target = camera.position.clone().addScaledVector(dir, CONFIG.teleportRange);
                    teleportMarker.position.copy(target);
                    player.teleportTarget = target;
                }
                teleportMarker.visible = true;
                teleportMarker.userData.core.rotation.y += dt * 2;
                teleportMarker.userData.core.position.y = 2.0 + Math.sin(performance.now() * 0.005) * 0.2;
                teleportMarker.userData.ring.rotation.z -= dt;
                document.getElementById('icon-q').classList.add('active');
            } else {
                teleportMarker.visible = false;
                document.getElementById('icon-q').classList.remove('active');
            }

            // Handle Crosshair Visibility
            const ch = document.getElementById('crosshair');
            if (slashActive || (teleportMode === 'AIM' && player.teleportActive)) {
                ch.style.opacity = 0;
            } else {
                ch.style.opacity = 1;
            }

            const now = performance.now();
            if (now - player.lastDamageTime > CONFIG.regenDelay && player.health < 100) {
                player.health += CONFIG.regenRate * dt;
                if (player.health > 100) player.health = 100;
            }

            const isMoving = (keys.w || keys.a || keys.s || keys.d);
            player.isSprinting = keys.shift && player.stamina > 0 && isMoving && !player.isCrouching;
            if (player.isSprinting) {
                player.stamina -= CONFIG.staminaDrain * dt;
                if (player.stamina < 0) player.stamina = 0;
            } else {
                player.stamina += CONFIG.staminaRegen * dt;
                if (player.stamina > 100) player.stamina = 100;
            }

            if (keys.c) {
                if (player.onGround) {
                    const speed = new THREE.Vector2(player.velocity.x, player.velocity.z).length();
                    if ((player.isSprinting || player.isSliding || speed > CONFIG.baseSpeed) && !player.isCrouching) {
                        if (!player.isSliding) {
                            player.isSliding = true;
                            player.lastSlideTime = performance.now(); // Mark slide time
                            const forward = new THREE.Vector3();
                            camera.getWorldDirection(forward);
                            forward.y = 0; forward.normalize();
                            player.velocity.addScaledVector(forward, CONFIG.slideBoost);
                        }
                    } else if (!player.isSliding) {
                        player.isCrouching = true;
                    }
                }
            } else {
                player.isSliding = false;
                player.isCrouching = false;
            }
            
            AudioSys.toggleSlideSound(player.isSliding && new THREE.Vector2(player.velocity.x, player.velocity.z).length() > 5);
            const targetHeight = (player.isSliding || player.isCrouching) ? -0.8 : 0;
            player.cameraHeightOffset = THREE.MathUtils.lerp(player.cameraHeightOffset, targetHeight, dt * 15);

            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0; forward.normalize();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

            const inputDir = new THREE.Vector3();
            if (keys.w) inputDir.add(forward);
            if (keys.s) inputDir.sub(forward);
            if (keys.a) inputDir.sub(right);
            if (keys.d) inputDir.add(right);
            if (inputDir.length() > 0) inputDir.normalize();

            let targetSpeed = CONFIG.baseSpeed;
            if (player.isCrouching) targetSpeed = CONFIG.crouchSpeed;
            if (player.isSprinting) targetSpeed = CONFIG.sprintSpeed;
            let friction = player.onGround ? CONFIG.frictionGround : CONFIG.frictionAir;
            let drive = friction; 
            if (!player.onGround) { friction = CONFIG.frictionAir; drive = CONFIG.airControl; }
            if (player.isSliding) { friction = CONFIG.frictionSlide; drive = 0; targetSpeed = 0; }

            if (inputDir.length() > 0 && !player.isSliding) {
                player.velocity.addScaledVector(inputDir, targetSpeed * drive * dt);
            }

            const damping = Math.exp(-friction * dt);
            player.velocity.x *= damping;
            player.velocity.z *= damping;
            player.velocity.y -= CONFIG.gravity * dt;

            const nextPos = camera.position.clone().addScaledVector(player.velocity, dt);
            const playerBox = new THREE.Box3();
            const radius = 0.4;
            playerBox.min.set(nextPos.x - radius, nextPos.y - 1.5, nextPos.z - radius);
            playerBox.max.set(nextPos.x + radius, nextPos.y + 0.5, nextPos.z + radius);

            for (const wall of walls) {
                const box = wall.geometry.boundingBox.clone();
                box.applyMatrix4(wall.matrixWorld);
                
                if (playerBox.intersectsBox(box)) {
                    const xOverlap = Math.min(playerBox.max.x - box.min.x, box.max.x - playerBox.min.x);
                    const zOverlap = Math.min(playerBox.max.z - box.min.z, box.max.z - playerBox.min.z);
                    
                    if (xOverlap < zOverlap) {
                        const sign = (playerBox.getCenter(new THREE.Vector3()).x < box.getCenter(new THREE.Vector3()).x) ? -1 : 1;
                        nextPos.x += xOverlap * sign;
                        player.velocity.x = 0;
                    } else {
                        const sign = (playerBox.getCenter(new THREE.Vector3()).z < box.getCenter(new THREE.Vector3()).z) ? -1 : 1;
                        nextPos.z += zOverlap * sign;
                        player.velocity.z = 0;
                    }
                    playerBox.min.set(nextPos.x - radius, nextPos.y - 1.5, nextPos.z - radius);
                    playerBox.max.set(nextPos.x + radius, nextPos.y + 0.5, nextPos.z + radius);
                }
            }

            const rayOrigin = nextPos.clone();
            const raycaster = new THREE.Raycaster(rayOrigin, new THREE.Vector3(0, -1, 0), 0, 5); 
            const intersects = raycaster.intersectObjects(worldObjects);
            const wasOnGround = player.onGround;
            player.onGround = false;
            if (intersects.length > 0) {
                const dist = intersects[0].distance;
                const desiredHeight = 1.6; 
                if (dist < desiredHeight + 0.2 && player.velocity.y <= 0) {
                    nextPos.y = intersects[0].point.y + desiredHeight;
                    player.velocity.y = 0;
                    player.onGround = true;
                    player.jumpsRemaining = 2; 
                }
            }

            // Air time tracking
            if (wasOnGround && !player.onGround) {
                player.airTimeStart = performance.now();
            }
            // Safe reset on landing
            if (player.onGround) {
                 player.airTimeStart = performance.now(); // Reset clock while on ground so airDuration is 0
            }

            camera.position.copy(nextPos);
            camera.position.y += player.cameraHeightOffset;
            
            // Rabbit Hole Logic
            if (camera.position.y < -20) {
                GameStats.addAchievement("DOWN THE RABBIT HOLE", "#ff00ff");
                damagePlayer(20);
                camera.position.set(0, 2, 0);
                player.velocity.set(0,0,0);
            }
        }

        function executeTeleport(target) {
             let yOffset = 0;
             
             // FIXED: Ground-to-ground detection
             const currentGroundY = getGroundHeight(camera.position.x, camera.position.z);
             const startInAir = (camera.position.y - currentGroundY) > 1.0; // 1.0 tolerance

             const ray = new THREE.Raycaster(target.clone().add(new THREE.Vector3(0,1,0)), new THREE.Vector3(0,-1,0), 0, 2);
             const hits = ray.intersectObjects(worldObjects);
             if(hits.length > 0) yOffset = 1.6;

             // Check if end position is aerial (target Y significantly above ground)
             const groundAtTarget = getGroundHeight(target.x, target.z);
             const endInAir = (target.y - groundAtTarget) > 0.5;

             // Phase Strike Logic: If Start OR End is air, it's an aerial teleport
             player.lastTeleportWasAerial = startInAir || endInAir;
             player.hasPhaseStruck = false; // Reset phase strike capability

             spawnParticles(camera.position, 0x00ffaa, 10); 
             camera.position.set(target.x, target.y + yOffset, target.z);
             player.velocity.y = 2; 
             player.jumpsRemaining = 1; 
             player.onGround = false; // Force airborne state
             
             player.airTimeStart = performance.now();
             
             player.lastTeleportTime = performance.now(); // Mark TP time
             AudioSys.playTeleport();
             spawnParticles(target, 0x00ffaa, 15);
        }

        function tryAimTeleport() {
            if (player.teleportTarget) {
                executeTeleport(player.teleportTarget);
                player.teleportActive = false; 
            }
        }

        function tryInstantTeleport() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            raycaster.far = CONFIG.teleportRange;
            const intersects = raycaster.intersectObjects(worldObjects);
            let target;
            if (intersects.length > 0) {
                 target = intersects[0].point;
            } else {
                 const dir = new THREE.Vector3();
                 camera.getWorldDirection(dir);
                 target = camera.position.clone().addScaledVector(dir, CONFIG.teleportRange);
            }
            executeTeleport(target);
            document.getElementById('icon-q').classList.add('active');
            setTimeout(() => document.getElementById('icon-q').classList.remove('active'), 200);
        }

        function updateComboUI() {
            const el = document.getElementById('combo-display');
            if(comboCount < 2) {
                el.style.display = 'none';
            } else {
                el.style.display = 'block';
                el.innerText = comboCount + " HITS";
                
                el.style.transform = "translateX(-50%) scale(1) rotate(0deg)";
                
                let fontSize = "2rem";
                let color = "#ffcc00";
                if(comboCount >= 5) fontSize = "4rem";
                if(comboCount >= 10) { fontSize = "5rem"; color = "#ff0000"; }
                
                // 100 Hits Logic
                if (comboCount % 100 === 0) {
                    fontSize = "8rem"; 
                    color = "#ff00ff";
                    spawnFirework(camera.position.clone().add(new THREE.Vector3(0,0,-5)));
                    GameStats.addAchievement(comboCount + " HITS LEGEND", "#ff00ff");
                }

                el.style.fontSize = fontSize;
                el.style.color = color;

                requestAnimationFrame(() => {
                     el.style.transform = `translateX(-50%) scale(1.3) rotate(${Math.random()*10-5}deg)`;
                     setTimeout(() => {
                         el.style.transform = "translateX(-50%) scale(1) rotate(0deg)";
                     }, 100);
                });
            }
            if(comboCount > GameStats.highestCombo) GameStats.highestCombo = comboCount;
        }

        function slash() {
            const now = performance.now();
            if (now - lastAttackTime < CONFIG.attackCooldown) return;
            lastAttackTime = now;

            AudioSys.playSlash();
            const slashMesh = spawnSlash(camera);
            
            const uniqueHitEnemies = new Set();
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);

            // 1. Raycast Check
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); 
            raycaster.far = CONFIG.attackRange;
            
            const hitObjects = [];
            enemies.forEach(e => { 
                if (!e.isDeadCorpse) e.mesh.traverse(c => hitObjects.push(c)); 
            });
            
            const hitIntersects = raycaster.intersectObjects(hitObjects);
            hitIntersects.forEach(hit => {
                let hitObj = hit.object;
                while(hitObj.parent && !enemies.some(e => e.mesh === hitObj)) {
                    hitObj = hitObj.parent;
                }
                const enemy = enemies.find(e => e.mesh === hitObj);
                if(enemy) uniqueHitEnemies.add(enemy);
            });

            // 2. Cone Check
            enemies.forEach(e => {
                if(e.isDeadCorpse) return;
                const toEnemy = e.mesh.position.clone().sub(camera.position);
                const dist = toEnemy.length();
                if (dist < CONFIG.attackRange) {
                    toEnemy.normalize();
                    const angle = camDir.angleTo(toEnemy);
                    if (angle < 0.5) { // Approx 30 degrees
                        uniqueHitEnemies.add(e);
                    }
                }
            });

            if (uniqueHitEnemies.size > 0) {
                // Check for Multi-Hit Achievements
                const hitCount = uniqueHitEnemies.size;
                if (hitCount >= 10) GameStats.addAchievement("SLAUGHTERHOUSE", "#ff0000");
                else if (hitCount >= 5) GameStats.addAchievement("CROWD CONTROL", "#ff8800");
                else if (hitCount >= 3) GameStats.addAchievement("TRIPLE THREAT", "#ffff00");

                // --- SCORING SYSTEM REWORK ---
                // Base Hit: 10
                // Additive Bonuses: Flat points instead of %
                let hitScore = 10;
                let addedScore = 0;
                let comboNames = [];

                const COMBO_WINDOW = 1000; // 1s tolerance
                const STREAK_WINDOW = 1500; // 1.5s to maintain streak

                const recentSlide = (now - player.lastSlideTime < COMBO_WINDOW) || player.isSliding;
                const recentTeleport = (now - player.lastTeleportTime < COMBO_WINDOW);
                const recentWallJump = (now - player.lastWallJumpTime < COMBO_WINDOW);

                // --- STREAK HELPER ---
                function updateStreak(type, baseBonus) {
                    if (now - moveStreaks[type].lastTime < STREAK_WINDOW) {
                        moveStreaks[type].count++;
                    } else {
                        moveStreaks[type].count = 0;
                    }
                    moveStreaks[type].lastTime = now;
                    return baseBonus + moveStreaks[type].count;
                }

                // Slide Bonus
                if (recentSlide) {
                    const bonus = updateStreak('slide', 25);
                    addedScore += bonus;
                    comboNames.push("SLIDE");
                    GameStats.moves.slideHit++;
                    GameStats.checkMoveMilestone('slideHit', "SLIDE", "#00ffff");
                }
                
                // Aerial Logic
                let isAerial = !player.onGround;
                // Fix: Teleport must have been aerial to count as aerial strike
                if (recentTeleport && player.lastTeleportWasAerial) {
                    isAerial = true;
                }

                if (isAerial) {
                     const airDuration = (now - player.airTimeStart) / 1000;
                     if (airDuration > 1.0) {
                        // Long Aerial: > 1.0s
                        const extraTime = airDuration - 1.0;
                        const extraTicks = Math.floor(extraTime / 0.1);
                        let longAirBonus = 50 + (extraTicks * 10);
                        
                        longAirBonus = updateStreak('longAerial', longAirBonus);
                        
                        addedScore += longAirBonus;
                        comboNames.push("LONG AERIAL");
                        GameStats.moves.longAirHit++;
                        GameStats.checkMoveMilestone('longAirHit', "SKY ASSASSIN", "#ff00aa");
                     } else {
                        // Standard Aerial
                        const bonus = updateStreak('aerial', 25);
                        addedScore += bonus;
                        comboNames.push("AERIAL");
                        GameStats.moves.midAirHit++;
                        GameStats.checkMoveMilestone('midAirHit', "AERIAL", "#ff00aa");
                     }
                }

                // Wall Jump Bonus
                if (recentWallJump) {
                    const bonus = updateStreak('wall', 30);
                    addedScore += bonus;
                    comboNames.push("WALL");
                    GameStats.moves.wallJumpHit++;
                    GameStats.checkMoveMilestone('wallJumpHit', "WALL RUNNER", "#00ffaa");
                }
                
                // Phase (Teleport) Bonus - Single Hit Only
                if (recentTeleport && !player.hasPhaseStruck) {
                     const bonus = updateStreak('phase', 50);
                     addedScore += bonus;
                     comboNames.push("PHASE");
                     player.hasPhaseStruck = true; // Consume phase bonus
                     GameStats.moves.teleportHit++;
                     GameStats.checkMoveMilestone('teleportHit', "VOID WALKER", "#aa00ff");
                }

                hitScore += addedScore;
                
                if (comboNames.length > 0) {
                    // Check total streak points
                    let totalStreak = 0;
                    for(let k in moveStreaks) {
                        if(now - moveStreaks[k].lastTime < STREAK_WINDOW) totalStreak += moveStreaks[k].count;
                    }
                    
                    let msg = comboNames.join(" ") + " +" + addedScore;
                    if(totalStreak > 0) msg += ` (+${totalStreak} streak)`;
                    
                    showKillMessage(msg, "combo");
                }
                
                // Multi-Hit Damage Falloff
                const hitList = Array.from(uniqueHitEnemies).map(e => ({
                    enemy: e,
                    dist: e.mesh.position.distanceTo(camera.position)
                }));
                hitList.sort((a, b) => a.dist - b.dist);

                hitList.forEach((h, index) => {
                    if (h.enemy.state === 'CONFUSED') {
                        GameStats.addAchievement("NO REST FOR THE WICKED", "#aa00ff");
                    }
                    const damageMult = Math.max(0.1, 1.0 - (index * 0.1));
                    addScore(hitScore); 
                    h.enemy.takeHit(CONFIG.playerDamage * damageMult);
                    spawnParticles(h.enemy.mesh.position, 0x00ffff, 10);
                    spawnImpact(h.enemy.mesh.position);
                });
                
                AudioSys.playHit();

                comboCount += uniqueHitEnemies.size;
                comboTimer = 3.0; 
                updateComboUI();

                if(slashMesh) {
                    slashMesh.material.color.setHex(0xffffff); 
                    slashMesh.material.opacity = 1; 
                    slashMesh.scale.setScalar(1.2); 
                    slashMesh.userData.fadeSpeed = 0.06; 
                    slashMesh.userData.isHit = true; 
                }
            }
        }

        // --- ENEMY AI ---
        const BOT_TYPES = {
            NORMAL: { scale: 1, hp: 100, speedMod: 1, dmgRed: 1, skill: 1, name: "NORMAL", color: 0x2F4F4F, eye: 0xffffff },   
            BRUTE: { scale: 2, hp: 300, speedMod: 0.7, dmgRed: 1, skill: 2, name: "BRUTE", color: 0x191970, eye: 0xffff00 },    
            TITAN: { scale: 3, hp: 600, speedMod: 0.5, dmgRed: 1, skill: 2, name: "TITAN", color: 0x4B0082, eye: 0xff8c00 },    
            COLOSSUS: { scale: 5, hp: 2000, speedMod: 0.3, dmgRed: 0.5, skill: 1, name: "COLOSSUS", color: 0x800000, eye: 0xff0000 }
        };

        class Enemy {
            constructor(posOverride = null, typeOverride = null, initialState = 'ROAM', aggroDelay = 0) {
                this.mesh = new THREE.Group();
                this.id = Math.random(); 
                
                let spawnY = 0;
                
                if (posOverride) {
                    this.mesh.position.copy(posOverride);
                    this.mesh.position.x += (Math.random()-0.5)*2;
                    this.mesh.position.z += (Math.random()-0.5)*2;
                    spawnY = this.mesh.position.y;
                    
                    if (typeOverride) {
                        this.type = typeOverride;
                    } else {
                        this.type = BOT_TYPES.NORMAL;
                    }
                } else {
                    // Height-Based Spawn
                    let x, z;
                    do {
                        x = (Math.random() - 0.5) * 200;
                        z = (Math.random() - 0.5) * 200;
                    } while (Math.abs(x) < 20 && Math.abs(z) < 20);
                    
                    const groundY = getGroundHeight(x, z);
                    spawnY = groundY;
                    
                    let r = Math.random();
                    let type = 'NORMAL';
                    
                    if (groundY > 35) {
                        if (r < 0.4) type = 'COLOSSUS';
                        else if (r < 0.9) type = 'TITAN';
                        else type = 'BRUTE';
                    } else if (groundY > 5) {
                        if (r < 0.05) type = 'COLOSSUS';
                        else if (r < 0.4) type = 'TITAN';
                        else if (r < 0.8) type = 'BRUTE';
                        else type = 'NORMAL';
                    } else {
                        if (r < 0.01) type = 'COLOSSUS';
                        else if (r < 0.05) type = 'TITAN';
                        else if (r < 0.20) type = 'BRUTE';
                        else type = 'NORMAL';
                    }
                    
                    this.type = BOT_TYPES[type];
                    this.mesh.position.set(x, spawnY + this.type.scale, z);
                }
                
                const bodyGeo = new THREE.BoxGeometry(1, 2, 1);
                const bodyMat = new THREE.MeshStandardMaterial({ color: this.type.color });
                this.body = new THREE.Mesh(bodyGeo, bodyMat);
                this.mesh.add(this.body);

                const outlineGeo = new THREE.BoxGeometry(1, 2, 1);
                const outlineMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide });
                this.outline = new THREE.Mesh(outlineGeo, outlineMat);
                this.outline.scale.setScalar(1.05); 
                this.mesh.add(this.outline);
                
                const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
                this.eyeMat = new THREE.MeshBasicMaterial({ color: this.type.eye });
                const leftEye = new THREE.Mesh(eyeGeo, this.eyeMat);
                leftEye.position.set(-0.2, 0.5, 0.5); 
                const rightEye = new THREE.Mesh(eyeGeo, this.eyeMat);
                rightEye.position.set(0.2, 0.5, 0.5);
                this.mesh.add(leftEye); this.mesh.add(rightEye);
                this.mesh.scale.setScalar(this.type.scale);

                this.healthBarGroup = new THREE.Group();
                const barGeo = new THREE.PlaneGeometry(1.2, 0.15);
                const barMat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
                this.healthBar = new THREE.Mesh(barGeo, barMat);
                this.healthBar.position.z = 0.01; 
                this.healthBarGroup.add(this.healthBar);
                const bgGeo = new THREE.PlaneGeometry(1.3, 0.25);
                const bgMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
                const bg = new THREE.Mesh(bgGeo, bgMat);
                this.healthBarGroup.add(bg);
                const uiScale = 1 + (this.type.scale - 1) * 0.5;
                this.healthBarGroup.scale.setScalar(uiScale);
                this.healthBarGroup.visible = false;
                scene.add(this.healthBarGroup); 

                this.maxHealth = this.type.hp;
                this.health = this.maxHealth;
                this.velocity = new THREE.Vector3();
                this.jumps = 0;
                this.state = initialState; 
                this.hasAggroed = initialState === 'AGGRO'; 
                this.reactionTimer = aggroDelay > 0 ? aggroDelay * 1000 : 0;
                
                this.targetPos = new THREE.Vector3();
                this.lastKnownPos = new THREE.Vector3();
                this.searchTimer = 0;
                this.pickRoamTarget();
                
                this.lastAttack = performance.now();
                this.actionTimer = 0; 
                this.isSprinting = false;
                this.isSliding = false;
                this.isDeadCorpse = false; 
                this.corpseTimer = 0;
                this.confusedTimer = 0; 
                
                scene.add(this.mesh);
                enemies.push(this);
            }

            pickRoamTarget() {
                // Reverted "Follow Leader" logic to pure random roam
                this.targetPos.set(
                    (Math.random() - 0.5) * 150,
                    this.mesh.position.y,
                    (Math.random() - 0.5) * 150
                );
            }

            canSeePlayer(playerPos) {
                if (this.isDeadCorpse || this.state === 'CONFUSED') return false;
                if (this.mesh.position.distanceTo(playerPos) > 50) return false;
                const toPlayer = playerPos.clone().sub(this.mesh.position).normalize();
                const facing = new THREE.Vector3(0,0,1);
                facing.applyQuaternion(this.mesh.quaternion);
                const dot = facing.dot(toPlayer);
                if (dot > 0.5) { 
                    const ray = new THREE.Raycaster(this.mesh.position, toPlayer, 0, 50);
                    const hits = ray.intersectObjects(walls);
                    if (hits.length > 0 && hits[0].distance < this.mesh.position.distanceTo(playerPos)) {
                        return false; 
                    }
                    return true;
                }
                return false;
            }

            update(dt, playerPos) {
                if (this.isDeadCorpse) {
                    this.corpseTimer -= dt;
                    this.mesh.rotation.x = Math.PI / 2; 
                    this.mesh.position.y = getGroundHeight(this.mesh.position.x, this.mesh.position.z) + 0.5; 
                    this.body.material.opacity = this.corpseTimer / 3.0;
                    this.body.material.transparent = true;
                    this.eyeMat.opacity = this.corpseTimer / 3.0;
                    this.eyeMat.transparent = true;
                    if (this.corpseTimer <= 0) {
                        this.remove();
                    }
                    return;
                }
                
                if (this.state === 'CONFUSED') {
                    this.confusedTimer -= dt;
                    this.mesh.rotation.x = -Math.PI / 2; 
                    this.mesh.position.y = getGroundHeight(this.mesh.position.x, this.mesh.position.z) + 0.5;
                    if (this.confusedTimer <= 0) {
                        this.state = this.hasAggroed ? 'AGGRO' : 'ROAM';
                        this.mesh.rotation.x = 0;
                    }
                    return;
                }

                // GRAVITY & GROUND DETECTION
                const groundY = getGroundHeight(this.mesh.position.x, this.mesh.position.z);
                const currentY = this.mesh.position.y;
                const floorThreshold = groundY + (1 * this.type.scale);

                if (currentY > floorThreshold + 0.1) {
                    this.velocity.y -= CONFIG.gravity * dt;
                } else {
                    if (this.velocity.y < -15) { 
                        this.state = 'CONFUSED';
                        const impactSpeed = Math.abs(this.velocity.y);
                        this.confusedTimer = 3.0 + Math.min(2.0, (impactSpeed - 15) / 5.0); // 3s to 5s duration
                        this.velocity.y = 0;
                        return;
                    }
                    
                    this.velocity.y = 0;
                    this.mesh.position.y = floorThreshold;
                    this.jumps = 0;
                }
                this.mesh.position.y += this.velocity.y * dt;

                this.healthBarGroup.position.copy(this.mesh.position).add(new THREE.Vector3(0, 1.8 * this.type.scale, 0));
                this.healthBarGroup.lookAt(camera.position);

                if (this.hasAggroed) {
                    this.healthBarGroup.visible = true;
                    this.healthBar.scale.x = Math.max(0, this.health / this.maxHealth);
                }
                
                if (this.state === 'AGGRO') this.eyeMat.color.setHex(0xff0000);
                else if (this.state === 'SEARCH') this.eyeMat.color.setHex(0xffaa00);
                else this.eyeMat.color.setHex(this.type.eye);

                if (this.reactionTimer > 0) {
                    this.reactionTimer -= dt * 1000;
                    return; 
                }

                let dest = this.targetPos;
                let speed = (this.isSprinting ? CONFIG.botSprintSpeed : CONFIG.botSpeed) * this.type.speedMod;
                if (this.state === 'ROAM') {
                    speed = CONFIG.botRoamSpeed * this.type.speedMod;
                    if (new THREE.Vector2(this.mesh.position.x - dest.x, this.mesh.position.z - dest.z).length() < 3) {
                        this.pickRoamTarget();
                    }
                } else if (this.state === 'AGGRO') {
                    if (this.canSeePlayer(playerPos)) {
                        this.lastKnownPos.copy(playerPos);
                        dest = playerPos;
                        const dist = this.mesh.position.distanceTo(playerPos);
                        if (dist < 4 * this.type.scale) {
                            const now = performance.now();
                            if (now - this.lastAttack > CONFIG.botAttackCooldown) {
                                this.lastAttack = now;
                                spawnSlash(this.mesh); 
                                AudioSys.playSlash();
                                if (Math.random() < 0.3) {
                                    const dmg = Math.min(CONFIG.botDamage * this.type.scale, 30);
                                    damagePlayer(dmg); 
                                }
                                else AudioSys.playMiss();
                            }
                        }
                    } else {
                        dest = this.lastKnownPos;
                        if (this.mesh.position.distanceTo(dest) < 3) {
                            this.state = 'SEARCH';
                            this.searchTimer = 3000; 
                            this.body.material.color.setHex(0xffaa00); 
                        }
                    }
                } else if (this.state === 'SEARCH') {
                    speed = 0; 
                    this.searchTimer -= dt * 1000;
                    this.mesh.rotation.y += Math.sin(performance.now() * 0.01) * 0.1; 
                    if (this.canSeePlayer(playerPos)) {
                        this.state = 'AGGRO';
                        this.body.material.color.setHex(0x8b0000);
                    } else if (this.searchTimer <= 0) {
                        this.state = 'ROAM';
                        this.body.material.color.setHex(this.type.color);
                        this.pickRoamTarget();
                    }
                }

                this.actionTimer -= dt;
                if (this.actionTimer <= 0) {
                    this.actionTimer = 0.5 + Math.random() * 1.5; 
                    this.isSprinting = Math.random() < (this.type.skill >= 2 ? 0.7 : 0.3);
                    this.isSliding = this.isSprinting && Math.random() < (this.type.skill >= 2 ? 0.4 : 0.1);
                    
                    // Jump Logic (Normal & Double Jump)
                    if (this.type.skill >= 1) {
                        if (this.onGroundSafe(groundY)) {
                            if (Math.random() < 0.5) { // Increased jump chance
                                this.velocity.y = 18; 
                                this.jumps = 1;
                            }
                        } else if (this.jumps === 1 && this.type.skill >= 2 && Math.random() < 0.4) {
                             // Double Jump
                             this.velocity.y = 18;
                             this.jumps = 2;
                             spawnParticles(this.mesh.position, 0xffffff, 5);
                        }
                    }
                }

                if(this.type.speedMod === 0) {
                     this.velocity.y = 0; 
                } else {
                    if (this.state !== 'SEARCH') {
                        const dir = new THREE.Vector3().subVectors(dest, this.mesh.position);
                        dir.y = 0; dir.normalize();
                        
                        if (this.state === 'AGGRO' && this.canSeePlayer(playerPos)) {
                            const perp = new THREE.Vector3(-dir.z, 0, dir.x);
                            const noise = Math.sin(performance.now() * 0.005 + this.id * 10) * 0.8;
                            dir.addScaledVector(perp, noise).normalize();
                        }
                        
                        if (this.onGroundSafe(groundY)) {
                             const nextPos = this.mesh.position.clone().addScaledVector(dir, 2);
                             const nextGroundY = getGroundHeight(nextPos.x, nextPos.z);
                             if (nextGroundY < groundY - 5) {
                                 if (Math.random() < 0.95) {
                                     speed = 0;
                                     if(this.state === 'ROAM') this.pickRoamTarget();
                                 }
                             }
                        }

                        if (this.isSliding) speed *= 1.5;
                        this.mesh.position.addScaledVector(dir, speed * dt);
                        this.mesh.lookAt(dest.x, this.mesh.position.y, dest.z);
                    }
                    
                    if (this.isSliding) this.mesh.rotation.x = 0.5;
                    else this.mesh.rotation.x = 0;
                }

                const botBox = new THREE.Box3().setFromObject(this.body);
                for(const wall of walls) {
                    const wb = wall.geometry.boundingBox.clone().applyMatrix4(wall.matrixWorld);
                    if(botBox.intersectsBox(wb)) {
                         const xOverlap = Math.min(botBox.max.x - wb.min.x, wb.max.x - botBox.min.x);
                         const zOverlap = Math.min(botBox.max.z - wb.min.z, wb.max.z - botBox.min.z);
                         if(xOverlap < zOverlap) {
                             const sign = (this.mesh.position.x < wall.matrixWorld.elements[12]) ? -1 : 1;
                             this.mesh.position.x += xOverlap * sign;
                         } else {
                             const sign = (this.mesh.position.z < wall.matrixWorld.elements[14]) ? -1 : 1;
                             this.mesh.position.z += zOverlap * sign;
                         }
                    }
                }
            }

            onGroundSafe(groundY) {
                 return Math.abs(this.mesh.position.y - (groundY + this.type.scale)) < 0.2;
            }

            takeHit(amt) {
                if(this.isDeadCorpse || this.state === 'CONFUSED') {
                    if(this.state === 'CONFUSED') amt *= 2;
                }
                
                amt *= this.type.dmgRed;
                this.health -= amt;
                this.body.material.color.setHex(0xffffff); 
                const toPlayer = camera.position.clone().sub(this.mesh.position);
                toPlayer.y = 0;
                this.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), toPlayer.normalize());

                setTimeout(() => { 
                    if(!this.isDeadCorpse && this.state !== 'CONFUSED') {
                        if(this.state === 'SEARCH') this.body.material.color.setHex(0xffaa00);
                        else if(this.state === 'AGGRO') this.body.material.color.setHex(0x8b0000);
                        else this.body.material.color.setHex(this.type.color);
                    }
                }, 100);

                if (this.state !== 'AGGRO' && this.state !== 'CONFUSED') {
                    this.state = 'AGGRO'; 
                    this.reactionTimer = CONFIG.botReactionDelay; 
                    this.hasAggroed = true;
                }

                if (this.health <= 0) {
                    addScore(100 * this.type.scale);
                    spawnParticles(this.mesh.position, 0x8b0000, 20 * this.type.scale);
                    AudioSys.playHit();
                    
                    let shouldSplit = false;
                    let nextType = BOT_TYPES.NORMAL;
                    let roll = Math.random();

                    if (this.type.name === "COLOSSUS") {
                        if (roll < 0.90) { shouldSplit = true; nextType = BOT_TYPES.TITAN; }
                    } else if (this.type.name === "TITAN") {
                        if (roll < 0.70) { shouldSplit = true; nextType = BOT_TYPES.BRUTE; }
                    } else if (this.type.name === "BRUTE") {
                        if (roll < 0.40) { shouldSplit = true; nextType = BOT_TYPES.NORMAL; }
                    }

                    if (!shouldSplit) {
                        this.isDeadCorpse = true;
                        this.corpseTimer = 3.0;
                        this.healthBarGroup.visible = false;
                        this.outline.visible = false;
                        showKillMessage("THREAT NEUTRALIZED");
                    } else {
                        const count = Math.random() > 0.5 ? 2 : 1;
                        const delays = [0.2, 0.5];
                        for(let i=0; i<count; i++) {
                            new Enemy(this.mesh.position, nextType, 'AGGRO', delays[i]);
                        }
                        showKillMessage(this.type.name + " SPLIT!");
                        this.remove();
                    }
                }
            }

            remove() {
                scene.remove(this.mesh);
                scene.remove(this.healthBarGroup);
                const idx = enemies.indexOf(this);
                if(idx > -1) enemies.splice(idx, 1);
            }
        }

        function spawnParticles(pos, col, count) {
            for(let i=0; i<count; i++) {
                const m = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color: col}));
                m.position.copy(pos);
                scene.add(m);
                particles.push({
                    mesh: m, 
                    vel: new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10),
                    life: 0.5
                });
            }
        }

        function damagePlayer(amt) {
            player.health -= amt;
            player.lastDamageTime = performance.now();
            
            const overlay = document.getElementById('damage-overlay');
            overlay.style.background = "radial-gradient(circle, transparent 20%, rgba(255,0,0,0.6) 100%)";
            setTimeout(() => {
                overlay.style.background = "radial-gradient(circle, transparent 50%, rgba(255,0,0,0.0) 100%)";
            }, 200);
            
            if(player.health <= 0) {
                player.health = 0;
                player.isDead = true;
                document.exitPointerLock();
                showKillMessage("TERMINATED", "achievement");
            }
        }
        
        function addScore(amt) {
            player.score += amt;
            document.getElementById('score-display').innerText = "SCORE: " + player.score;
        }

        function resetGame() {
            player.health = 100;
            player.stamina = 100;
            player.score = 0;
            player.isDead = false;
            player.isSliding = false;
            player.isCrouching = false;
            player.velocity.set(0,0,0);
            camera.position.set(0, 2, 0);
            
            // Clear entities
            for(let i=enemies.length-1; i>=0; i--) enemies[i].remove();
            enemies.length = 0;
            
            // Clear particles
            particles.forEach(p => {
                scene.remove(p.mesh);
                p.mesh.geometry.dispose();
                p.mesh.material.dispose();
            });
            particles.length = 0;
            
            GameStats.reset();
            comboCount = 0;
            updateComboUI();
            document.getElementById('score-display').innerText = "SCORE: 0";
        }
        
        function showKillMessage(text, type="", color=null) {
            const feed = document.getElementById('kill-feed');
            const msg = document.createElement('div');
            msg.className = "kill-msg " + type;
            msg.innerText = text;
            if(color) {
                msg.style.color = color;
                msg.style.borderLeftColor = color;
            }
            feed.prepend(msg);
            if(feed.children.length > 6) feed.removeChild(feed.lastChild);
        }

        function onKeyDown(e) {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = true; break;
                case 'a': keys.a = true; break;
                case 's': keys.s = true; break;
                case 'd': keys.d = true; break;
                case ' ': 
                    if(!keys.space && !isLocked) return;
                    keys.space = true; 
                    if(player.onGround) {
                        player.velocity.y = CONFIG.jumpForce;
                        if(player.isSliding) {
                             player.velocity.y = 15; 
                             const forward = new THREE.Vector3();
                             camera.getWorldDirection(forward);
                             forward.y=0; forward.normalize();
                             player.velocity.addScaledVector(forward, CONFIG.bunnyHopBoost);
                        }
                        player.onGround = false;
                        player.lastJumpTime = performance.now(); // Mark Jump
                        AudioSys.playJump();
                    } else if(player.jumpsRemaining > 0) {
                        // Wall Jump Check
                        const ray = new THREE.Raycaster(camera.position, new THREE.Vector3(0,0,0), 0, 1.5);
                        const dirs = [
                            new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0),
                            new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)
                        ];
                        let hitWall = false;
                        for(let d of dirs) {
                            d.applyQuaternion(camera.quaternion);
                            ray.set(camera.position, d);
                            if(ray.intersectObjects(walls).length > 0) {
                                hitWall = true;
                                player.velocity.addScaledVector(d, -CONFIG.wallPushForce);
                                break;
                            }
                        }
                        
                        player.velocity.y = hitWall ? CONFIG.wallJumpForce : CONFIG.jumpForce;
                        player.jumpsRemaining--;
                        player.lastJumpTime = performance.now();
                        if(hitWall) {
                            player.lastWallJumpTime = performance.now(); // Mark Wall Jump
                            AudioSys.playWallJump();
                        } else {
                            AudioSys.playJump();
                        }
                    }
                    break;
                case 'shift': keys.shift = true; break;
                case 'c': keys.c = true; break;
                case 'q': 
                    if(!keys.q) {
                        keys.q = true;
                        if(isLocked && !player.isDead) {
                            if(teleportMode === 'INSTANT') tryInstantTeleport();
                            else if(teleportMode === 'AIM') player.teleportActive = !player.teleportActive;
                        }
                    }
                    break;
                case 't': if(!e.repeat) toggleTheme(); break;
            }
        }

        function onKeyUp(e) {
            switch(e.key.toLowerCase()) {
                case 'w': keys.w = false; break;
                case 'a': keys.a = false; break;
                case 's': keys.s = false; break;
                case 'd': keys.d = false; break;
                case ' ': keys.space = false; break;
                case 'shift': keys.shift = false; break;
                case 'c': keys.c = false; break;
                case 'q': keys.q = false; break;
            }
        }

        function onMouseMove(e) {
            if (!isLocked || player.isDead) return;
            camera.rotation.y -= e.movementX * 0.002;
            camera.rotation.x -= e.movementY * 0.002;
            camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const now = performance.now();
            const dt = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;
            
            if (isLocked && !player.isDead) {
                // SPAWN LOGIC (Rate: 0.05)
                if (Math.random() < 0.05 && enemies.length < 60) {
                    new Enemy();
                }
                
                // AUTO STRIKE
                if (mouseDown) {
                     if (teleportMode === 'AIM' && player.teleportActive) {
                        // Wait for explicit click
                     } else {
                        slash();
                     }
                }
                
                // Update Entities
                updatePlayer(dt);
                updateWeather(dt);
                
                for (let i = enemies.length - 1; i >= 0; i--) {
                    enemies[i].update(dt, camera.position);
                }

                // Particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.life -= dt;
                    p.mesh.position.addScaledVector(p.vel, dt);
                    p.mesh.scale.setScalar(p.life * 2); 
                    if (p.life <= 0) {
                        scene.remove(p.mesh);
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                        particles.splice(i, 1);
                    }
                }
                
                // Combo Decay
                if (comboCount > 0) {
                    comboTimer -= dt;
                    if (comboTimer <= 0) {
                        comboCount = 0;
                        updateComboUI();
                    }
                }
                
                // Health/Stamina Bar UI
                const hpPct = Math.max(0, player.health);
                const stPct = Math.max(0, player.stamina);
                document.getElementById('health-fill').style.width = hpPct + '%';
                document.getElementById('stamina-fill').style.width = stPct + '%';
                
                // Breathe Effect Reset if user successfully enters
                const btn = document.getElementById('start-btn');
                if (btn.innerText === "b r e a t h e" && isLocked) {
                     btn.innerText = "ENTER ARENA";
                     btn.style.opacity = 1;
                     btn.style.letterSpacing = "2px";
                }
            }

            renderer.render(scene, camera);
        }

        // START
        init();
    </script>
</body>
</html>