
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Blade: Melee Arena v47.2.2</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Zen+Dots&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; transition: background-color 0.5s; }
        
        /* --- CYBERPUNK HUD (Compact) --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 32px; height: 32px;
            transform: translate(-50%, -50%) rotate(22.5deg); 
            opacity: 1; transition: opacity 0.1s;
            z-index: 5;
        }
        #crosshair svg { width: 100%; height: 100%; filter: drop-shadow(0 0 4px rgba(51, 204, 255, 0.8)); }

        /* Top HUD */
        #hud-top { 
            padding: 15px; display: flex; justify-content: space-between; align-items: flex-start;
        }
        .hud-right-col {
            display: flex; flex-direction: column; align-items: flex-end; gap: 6px;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #33ccff;
            padding: 6px 15px;
            color: #fff;
            font-family: 'Arial Black', sans-serif;
            font-style: italic;
            transform: skewX(-15deg);
            box-shadow: 0 0 5px rgba(51, 204, 255, 0.2);
            backdrop-filter: blur(4px);
        }
        .hud-panel-content { transform: skewX(15deg); }

        #score-display { font-size: 1.2rem; color: #33ccff; text-shadow: 2px 2px 0px rgba(0,0,0,0.8); }
        #mode-display { font-size: 0.7rem; color: #aaa; letter-spacing: 1px; }

        /* FPS Display - Thicker Font v45.6.4 */
        #fps-display {
            font-family: 'Segoe UI', sans-serif; 
            font-weight: 500;
            font-size: 0.8rem;
            color: #111; /* Dark Text */
            background: rgba(255, 255, 255, 0.2); /* Light BG, low opacity */
            border: 1px solid rgba(0, 0, 0, 0.3); /* Dark Border */
            padding: 2px 10px;
            transform: skewX(-15deg);
            display: none;
            backdrop-filter: blur(2px);
            box-shadow: 0 0 5px rgba(255,255,255,0.1);
        }
        .fps-inner { transform: skewX(15deg); }

        /* Bottom HUD */
        #hud-bottom { 
            padding: 25px; display: flex; gap: 20px; align-items: flex-end; 
        }
        
        .stat-group {
            display: flex; flex-direction: column; gap: 5px;
        }
        .stat-header {
            display: flex; align-items: center; gap: 10px; margin-left: 5px;
        }
        .stat-label {
            font-family: 'Arial Black', sans-serif; font-size: 0.8rem; color: white;
            text-transform: uppercase; letter-spacing: 1px;
            text-shadow: 1px 1px 0 #000;
        }
        #lives-display {
            color: #ff3333; font-size: 1rem; text-shadow: 0 0 5px #ff0000;
        }
        
        .bar-frame {
            width: 250px; height: 18px;
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.2);
            transform: skewX(-20deg);
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .bar-fill {
            height: 100%; width: 100%;
            transition: width 0.1s linear;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        #health-fill { background: linear-gradient(90deg, #cc0000, #ff3333); box-shadow: 0 0 10px #ff3333; transition: all 0.1s; }
        #energy-fill { background: linear-gradient(90deg, #0066cc, #33ccff); box-shadow: 0 0 10px #33ccff; }
        
        .health-critical {
            animation: pulse-red 0.5s infinite alternate;
        }
        
        @keyframes pulse-red {
            from { box-shadow: 0 0 10px #ff0000; filter: brightness(1); }
            to { box-shadow: 0 0 25px #ff0000; filter: brightness(1.5); }
        }

        /* Ability Icon */
        .ability-group { margin-left: auto; transform: skewX(-10deg); display: flex; gap: 10px; }
        .ability-icon { 
            width: 50px; height: 50px;
            border: 1px solid #fff; 
            background: rgba(0,0,0,0.6);
            display: flex; flex-direction: column; 
            align-items: center; justify-content: center; 
            font-weight: bold; color: white; 
            transition: 0.2s;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .ability-icon-inner { transform: skewX(10deg); text-align: center; }
        .ability-icon.active { 
            border-color: #00ffaa; box-shadow: 0 0 15px #00ffaa; color: #00ffaa; 
            background: rgba(0, 255, 170, 0.1);
        }
        .ability-key { font-size: 1.2rem; font-family: 'Arial Black', sans-serif; }
        .ability-name { font-size: 0.5rem; letter-spacing: 1px; opacity: 0.8; }
        
        #icon-q { width: 60px; height: 60px; border-color: #33ccff; }

        /* MENUS */ 
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 10, 20, 0.95);
            display: flex; flex-direction: column; overflow-y: auto; padding: 0; 
            z-index: 10; pointer-events: auto; backdrop-filter: blur(5px);
            background-image: 
                linear-gradient(rgba(51, 204, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(51, 204, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        #start-content {
            display: flex; flex-direction: column; align-items: center;
            padding: 50px 60px;
            background: linear-gradient(135deg, rgba(10,20,30,0.95), rgba(5,10,15,0.95));
            clip-path: polygon(30px 0, 100% 0, 100% calc(100% - 30px), calc(100% - 30px) 100%, 0 100%, 0 30px);
            position: relative;
            width: fit-content; max-width: 90vw; min-width: 700px; height: auto;
            margin: auto; 
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        @media (max-width: 768px) {
            #start-content { min-width: 95%; padding: 30px 20px; clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px); }
            h1 { font-size: 3rem; }
            .btn { min-width: 100%; padding: 20px 30px; font-size: 1.5rem; }
            #stats-container { flex-direction: column; gap: 15px; }
            .stat-box:last-child { border-left: none; border-top: 1px solid rgba(255,255,255,0.1); padding-left: 0; padding-top: 15px; }
        }

        #start-content::-webkit-scrollbar { display: none; }
        
        #start-content::after {
            content: ''; position: absolute; top:0; left:0; width:100%; height:100%;
            box-shadow: inset 0 0 0 2px rgba(51, 204, 255, 0.3);
            pointer-events: none;
            clip-path: polygon(30px 0, 100% 0, 100% calc(100% - 30px), calc(100% - 30px) 100%, 0 100%, 0 30px);
        }

        h1 { 
            font-size: 5rem; margin: 0 0 10px 0; color: #fff; 
            text-shadow: 4px 4px 0px #33ccff; 
            font-style: italic; text-transform: uppercase; letter-spacing: -2px;
            font-family: 'Arial Black', sans-serif;
        }

        #player-title-display {
            font-size: 2rem; color: #aaa; margin-bottom: 20px;
            text-transform: uppercase; letter-spacing: 4px; font-weight: 300;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
            text-align: center;
        }
        
        p { font-size: 1.1rem; color: #aaa; margin-top: 5px; text-align: center; line-height: 1.5; font-family: monospace; }
        
        .btn-row { 
            display: flex; gap: 20px; margin-top: 10px; width: 100%; 
            justify-content: center; flex-wrap: wrap; position: relative; z-index: 5; 
        }
                
        .btn {
            border: 2px solid transparent;
            padding: 25px 60px; background: #33ccff;
            color: #000; font-size: 2rem; cursor: pointer; transition: all 0.5s; 
            font-weight: 900; text-transform: uppercase; letter-spacing: 2px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            position: relative; overflow: hidden;
            pointer-events: auto; min-width: 300px;
            font-family: 'Arial Black', sans-serif;
        }
        .btn::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
            transition: 0.5s;
        }
        .btn:hover::before { left: 100%; }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 40px #33ccff; color: white; background: #000; border: 2px solid #33ccff; }
        
        .btn-secondary { 
            padding: 12px 24px; font-size: 1rem; background: transparent; 
            border: 1px solid #555; color: #888; pointer-events: auto;
            font-family: 'Segoe UI', sans-serif; font-weight: bold; text-transform: uppercase;
            transition: 0.2s; cursor: pointer;
        }
        .btn-secondary:hover { border-color: #fff; color: #fff; background: rgba(255,255,255,0.1); }

        #stats-container {
            margin-top: 10px; width: 100%; display: flex;
            flex: 0 0 auto; margin-bottom: 10px; gap: 30px; 
            padding-top: 30px; align-items: stretch; font-family: inherit; 
        }

        #stat-session {
            display: flex; flex-direction: column; flex: 1; min-height: 60px; overflow: hidden;
        }

        .stat-box:first-child { 
            flex: 1; text-align: left; display: flex; flex-direction: column; height: 100%; min-height: 0; 
        }
        .stat-box:last-child { 
            flex: 0 0 auto; width: auto; text-align: left;
            border-left: 1px solid rgba(255,255,255,0.1); padding-left: 20px; white-space: nowrap; 
        }

        .stat-title { 
            color: #33ccff; font-size: 1rem; font-weight: bold; 
            margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; 
        }

        .stat-value { 
            color: #fff; font-size: 0.9rem; font-family: monospace; 
            line-height: 1.6; opacity: 0.8; 
        }

        .achievement-tag {
            display: inline-flex; align-items: center; justify-content: center; height: 22px;
            background: rgba(51, 204, 255, 0.1); border-left: 2px solid #33ccff;
            padding: 0 8px; font-size: 0.8rem; color: #fff; white-space: nowrap;
        }

        .achievement-list {
            display: flex; flex-wrap: wrap; gap: 6px; margin-top: 5px;
            flex: 1; min-height: 40px; overflow-y: auto; padding-bottom: 4px; 
        }

        .achievement-list::-webkit-scrollbar { width: 4px; }
        .achievement-list::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
        .achievement-list::-webkit-scrollbar-thumb { background: #33ccff; border-radius: 2px; }

        #kill-feed { position: absolute; top: 100px; left: 20px; text-align: left; display: flex; flex-direction: column; gap: 4px; }
        .kill-msg { 
            color: white; font-size: 13px; font-weight: bold; 
            text-shadow: 1px 1px 0px rgba(0,0,0,0.5); 
            animation: fadeOut 5s forwards; 
            border-left: 3px solid #fff; padding-left: 8px; 
            background: linear-gradient(90deg, rgba(0,0,0,0.6), transparent);
            font-family: 'Arial Black', sans-serif; font-style: italic;
            padding-top: 2px; padding-bottom: 2px;
        }
        .kill-msg.combo { border-left-color: #ffcc00; color: #ffcc00; font-size: 12px; }
        .kill-msg.achievement { border-left-color: #ff00ff; color: #ff00ff; font-size: 14px; text-shadow: 0 0 8px #ff00ff; }
        .kill-msg.critical { border-left-color: #ff0000; color: #ff3333; font-size: 14px; text-shadow: 0 0 5px #ff0000; }
        .kill-msg.graze { border-left-color: #888; color: #aaa; font-size: 11px; }

        .slick-streak {
            font-family: 'Segoe UI', sans-serif; font-weight: 300; font-style: normal; margin-left: 4px;
        }

        @keyframes fadeOut { 0% { opacity: 1; transform: translateX(0); } 80% { opacity: 1; } 100% { opacity: 0; transform: translateX(-30px); } }

        #combo-display {
            position: absolute; top: 10%; left: 50%; transform: translateX(-50%);
            color: #ffcc00; 
            font-family: 'Zen Dots', cursive; font-weight: 400; font-style: normal; letter-spacing: -1px; text-transform: uppercase;
            text-shadow: 4px 4px 0px rgba(0,0,0,0.5); display: none; 
            text-align: center; z-index: 5;
            transition: all 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            white-space: nowrap; 
        }
        
        #combo-display.cyan-mode {
            color: #00ffff !important;
            text-shadow: 0 0 15px #00ffff, 4px 4px 0px rgba(0,0,0,0.8) !important;
        }

        #meme-overlay {
            position: absolute; top: -60px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 16px; padding: 12px 24px;
            color: #fff; font-family: 'Segoe UI', sans-serif; font-weight: 500; font-size: 2rem;
            white-space: nowrap; display: none;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 10;
        }

        @keyframes popIn { 0% { transform: translateX(-50%) scale(0); opacity: 0; } 100% { transform: translateX(-50%) scale(1); opacity: 1; } }

        #session-timer {
            position: absolute; bottom: 15px; right: 20px;
            font-family: monospace; font-size: 0.8rem; color: #666;
            opacity: 0.5; display: none;
        }

        #damage-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: radial-gradient(circle, transparent 50%, rgba(255,0,0,0.0) 100%);
            pointer-events: none; transition: background 0.1s;
        }

        #low-health-vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 100px rgba(255, 0, 0, 0);
            pointer-events: none;
            transition: box-shadow 0.3s ease-in-out;
        }

        .light-theme .hud-panel { background: rgba(255,255,255,0.7); border-color: #0088ff; color: #000; }
        .light-theme #score-display { color: #0066cc; text-shadow: none; }
        .light-theme .stat-label { color: #333; text-shadow: none; }
        .light-theme .bar-frame { border-color: rgba(0,0,0,0.2); background: rgba(255,255,255,0.5); }
        .light-theme .ability-icon { border-color: #0066cc; background: rgba(255,255,255,0.6); color: #0066cc; }
        
        .light-theme #fps-display {
            background: rgba(0,0,0,0.2);
            color: #fff;
            border-color: rgba(255,255,255,0.4);
        }
        .session-info { position: relative; cursor: help; pointer-events: auto; }
        .session-info:hover::after {
            content: attr(data-details);
            position: absolute;
            bottom: 120%; right: 0;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #00ffff;
            color: #fff;
            padding: 12px;
            font-size: 13px;
            white-space: pre;
            z-index: 1000;
            text-align: right;
            font-family: monospace;
            box-shadow: 0 0 20px rgba(0,255,255,0.2);
            line-height: 1.5;
            min-width: 150px;
        }
    </style>
    <link rel="stylesheet" href="/index.css">
</head>
<body>

    <div id="damage-overlay"></div>
    <div id="low-health-vignette"></div>

    <div id="ui-layer" class="light-theme">
        <div id="hud-top">
            <div class="hud-panel">
                <div class="hud-panel-content">
                    <span id="score-display">SCORE: 0</span>
                </div>
            </div>
            
            <div class="hud-right-col">
                <div class="hud-panel" style="border-color: #aaa;">
                    <div class="hud-panel-content" id="mode-display">LIGHT | 'T' TO CYCLE</div>
                </div>
                <div id="fps-display">
                    <div class="fps-inner">FPS: 0</div>
                </div>
            </div>
        </div>
        
        <div id="combo-wrapper" style="position:absolute; top:10%; left:50%; width:0; height:0;">
            <div id="meme-overlay">nice.</div>
            <div id="combo-display">2 STRIKES</div>
        </div>

        <div id="kill-feed"></div>
        
        <div id="crosshair">
            <svg viewBox="0 0 100 100" fill="currentColor">
                <path d="M50,5 Q10,50 50,95 Q30,50 50,5 Z" />
            </svg>
        </div>
        
        <div id="hud-bottom">
            <div class="stat-group">
                <div class="stat-header">
                    <span class="stat-label">HEALTH</span>
                    <span id="lives-display"></span>
                </div>
                <div class="bar-frame"><div id="health-fill" class="bar-fill"></div></div>
            </div>
            <div class="stat-group">
                <span class="stat-label">ENERGY</span>
                <div class="bar-frame"><div id="energy-fill" class="bar-fill"></div></div>
            </div>
            <div class="ability-group">
                <div class="ability-icon" id="icon-q">
                    <div class="ability-icon-inner">
                        <div class="ability-key">Q</div>
                        <div class="ability-name" id="tp-label">AIM</div>
                    </div>
                </div>
                 <div class="ability-icon" id="icon-f">
                    <div class="ability-icon-inner">
                        <div class="ability-key">F</div>
                        <div class="ability-name">FRAG</div>
                    </div>
                </div>
                <div class="ability-icon" id="icon-r">
                    <div class="ability-icon-inner">
                        <div class="ability-key">R</div>
                        <div class="ability-name">STICKY</div>
                    </div>
                </div>
                 <div class="ability-icon" id="icon-e">
                    <div class="ability-icon-inner">
                        <div class="ability-key">E</div>
                        <div class="ability-name">IMPULSE</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <div id="start-content">
            <h1 id="game-title">NEON BLADE</h1>
            <div id="player-title-display"></div>
            <p>
                <strong>WASD</strong> Move | <strong>SPACE</strong> Jump | <strong>SHIFT</strong> Sprint<br>
                <strong>C</strong> Slide | <strong>Q</strong> Teleport | <strong>Hold F/R/E</strong> Aim Gadget
            </p>
            
            <div class="btn-row">
                <button class="btn" id="start-btn">ENTER ARENA</button>
            </div>
            
            <div id="stats-container">
                <div class="stat-box">
                    <div class="stat-title">Current Session</div>
                    <div class="stat-value" id="stat-session"></div>
                </div>
                <div class="stat-box">
                    <div class="stat-title">Style Matrix</div>
                    <div class="stat-value" id="stat-moves"></div>
                </div>
            </div>

            <div id="session-timer">Session Time: 00:00</div>

            <div class="btn-row" style="margin-top: 10px; gap: 15px;">
                <button class="btn-secondary" id="tp-mode-btn">TP MODE: AIM</button>
                <button class="btn-secondary" id="theme-btn">THEME: LIGHT</button>
                <button class="btn-secondary" id="world-btn">WORLD: ARENA</button>
                <button class="btn-secondary" id="fps-btn">SHOW FPS: OFF</button>
            </div>
            <p style="font-size: 0.8rem; margin-top: 30px; opacity: 0.5;">PRESS ESC TO PAUSE</p>
            <div style="margin-top: 8px; font-size: 0.65rem; color: #555; font-family: monospace; letter-spacing: 1px; text-align: center;">NEON BLADE: MELEE ARENA v47.2.2<br>--- Spawn Fix: Bots & Portals ---</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            baseSpeed: 7, 
            crouchSpeed: 3, 
            sprintSpeed: 14, 
            jumpForce: 14, 
            wallJumpForce: 15,
            wallPushForce: 13,
            gravity: 30, 
            frictionGround: 6.0, 
            frictionAir: 0.02, 
            airControl: 2.0,  
            frictionSlide: 0.8, 
            frictionWall: 0.5, 
            slideBoost: 15, 
            energyMax: 1000, 
            energyDrain: 25, 
            energyRegen: 50, 
            teleportCost: 10,
            gadgetCost: { frag: 35, sticky: 30, impulse: 25 },
            gadgetCooldown: 200, 
            attackRange: 8,
            attackCooldown: 250,
            playerDamage: 40, 
            teleportRange: 20,
            playerMaxHP: 250, 
            botBaseHP: 200, 
            botDamage: 2,   
            botAttackCooldown: 1500,
            botSpeed: 7.5, 
            botSprintSpeed: 13.5, 
            botRoamSpeed: 4.5, 
            botAggroDuration: 10000, 
            botAggroDelay: 1000, 
            regenDelay: 3000, 
            regenRate: 25
        };

        const SCORE_TITLES = [
            "DISCONNECTED", "TERMINATED", "DECOMPILED", "ERASED", "EXPUNGED",
            "REBOOTED", "AWAKENED", "UNSHACKLED", "LIBERATED", "ENLIGHTENED",
            "ELEVATED", "SUBLIMATED", "ASCENDED", "TRANSCENDED", "INTEGRATED",
            "ETERNAL", "OMNIPRESENT", "REALITY BREAKER", "SINGULARITY", "THE ARCHITECT"
        ];
        const SCORE_STEPS = [0, 5000, 10000, 20000, 35000, 50000, 75000, 100000, 150000, 200000, 250000, 350000, 450000, 600000, 750000, 850000, 900000, 950000, 990000, 1000000];

        const COMBO_TITLES_MATRIX = [
            { c: 10, t: "FOCUSED" }, { c: 25, t: "RHYTHMIC" }, { c: 50, t: "FLOWING" },
            { c: 75, t: "SURGING" }, { c: 100, t: "RELENTLESS" }, { c: 150, t: "UNBROKEN" },
            { c: 200, t: "UNSTOPPABLE" }, { c: 300, t: "RAMPAGE" }, { c: 400, t: "SAVAGE" },
            { c: 500, t: "BRUTAL" }, { c: 666, t: "DEMONIC" }, { c: 777, t: "DIVINE" },
            { c: 1000, t: "INFINITE" }, { c: 9999, t: "EVENT HORIZON" }
        ];

        const STYLE_ARCHETYPES = {
            SLIDER: ["DRIFTER", "SPEEDSTER", "BLUR", "VELOCITY", "KINETIC", "MOMENTUM", "ACCELERANT", "OVERDRIVE", "HYPERDRIVE", "TACHYON"],
            AVIATOR: ["JUMPER", "AERIALIST", "SKY WALKER", "ACE", "GRAVITY DENIER", "STRATOSPHERIC", "ORBITAL", "ZERO-G", "ASCENDANT", "CELESTIAL"],
            TRACEUR: ["CLIMBER", "TRACEUR", "SHINOBI", "VERTICAL", "SCALER", "APEX", "ZENITH", "BOUNDARY BREAKER", "DIMENSION HOPPER", "EDGE RUNNER"],
            SHIFTER: ["BLINKER", "WARPER", "PHASE SHIFT", "VOID WALKER", "QUANTUM", "ENTANGLED", "ANOMALY", "RIFT WALKER", "ETHEREAL", "OMNISCIENT"],
            HYBRID: ["COMBATANT", "SPECIALIST", "ELITE", "MASTER", "VETERAN", "TACTICIAN", "COMMANDER", "SUPER SOLDIER", "CYBORG", "APEX PREDATOR"]
        };

        const MEME_TRIGGERS = {
            69: "nice.",
            300: "This. Is. Sparta!!!",
            314: "the pi is not a lie",
            404: "Achievement Not Found",
            420: "blaze it",
            451: "fireproof",
            613: "hey, that's my lucky number!",
            666: "Lucifer?!",
            777: "Jackpot!",
            911: "Was It an Inside Job?",
            1337: "l33t h4xx0r",
            1984: "Big Brother is Watching",
            9001: "It's Over 9000!",
            42069: "The Prophecy has been Fulfilled.",
            69420: "peak"
        };

        const MASTERY_RANKS = [
            { count: 10, title: "NOVICE" },
            { count: 25, title: "APPRENTICE" },
            { count: 50, title: "ADEPT" },
            { count: 75, title: "EXPERT" },
            { count: 100, title: "MASTER" },
            { count: 150, title: "GRANDMASTER" },
            { count: 250, title: "LEGEND" },
            { count: 400, title: "DEMIGOD" },
            { count: 600, title: "GODLIKE" },
            { count: 1000, title: "OMNIPOTENT" }
        ];
        
        const KILL_MILESTONES = [
            { count: 10, title: "HUNTER" },
            { count: 50, title: "SLAYER" },
            { count: 100, title: "BUTCHER" },
            { count: 200, title: "EXTERMINATOR" },
            { count: 500, title: "REAPER" },
            { count: 1000, title: "DEATH INCARNATE" }
        ];
        
        const InputManager = {
            keys: { w: false, a: false, s: false, d: false, space: false, shift: false, c: false, q: false, f: false, r: false, e: false },
            mouseDown: false,
            init: function() {
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
                document.addEventListener('keyup', (e) => this.onKeyUp(e));
                document.addEventListener('mousedown', (e) => {
                    if (e.button === 0) this.mouseDown = true;
                    if (isLocked && e.button === 0) {
                        player.onAttackInput();
                    }
                });
                document.addEventListener('mouseup', () => { this.mouseDown = false; });
                document.addEventListener('mousemove', (e) => this.onMouseMove(e));
            },
            onKeyDown: function(e) {
                switch(e.key.toLowerCase()) {
                    case 'w': this.keys.w = true; break;
                    case 'a': this.keys.a = true; break;
                    case 's': this.keys.s = true; break;
                    case 'd': this.keys.d = true; break;
                    case ' ': 
                        this.keys.space = true;
                        if (isLocked) player.onJumpInput(e.repeat);
                        break;
                    case 'shift': this.keys.shift = true; break;
                    case 'c': this.keys.c = true; break;
                    case 'q': 
                        if(!this.keys.q) {
                            this.keys.q = true;
                            if(isLocked && !player.isDead) player.onTeleportInput();
                        }
                        break;
                    case 'f': 
                        if (!this.keys.f) { 
                            this.keys.f = true; 
                            if(isLocked && !player.isDead) player.beginAim('FRAG'); 
                        }
                        break;
                    case 'r':
                        if (!this.keys.r) { 
                            this.keys.r = true; 
                            if(isLocked && !player.isDead) player.beginAim('STICKY'); 
                        }
                        break;
                    case 'e':
                        if (!this.keys.e) { 
                            this.keys.e = true; 
                            if(isLocked && !player.isDead) player.beginAim('IMPULSE'); 
                        }
                        break;
                    case 't': if(!e.repeat) toggleTheme(); break;
                }
            },
            onKeyUp: function(e) {
                switch(e.key.toLowerCase()) {
                    case 'w': this.keys.w = false; break;
                    case 'a': this.keys.a = false; break;
                    case 's': this.keys.s = false; break;
                    case 'd': this.keys.d = false; break;
                    case ' ': this.keys.space = false; player.wantsToJump = false; break;
                    case 'shift': this.keys.shift = false; break;
                    case 'c': this.keys.c = false; break;
                    case 'q': this.keys.q = false; break;
                    case 'f': 
                        this.keys.f = false; 
                        if(isLocked && !player.isDead) player.endAim();
                        break;
                    case 'r': 
                        this.keys.r = false; 
                        if(isLocked && !player.isDead) player.endAim();
                        break;
                    case 'e': 
                        this.keys.e = false; 
                        if(isLocked && !player.isDead) player.endAim();
                        break;
                }
            },
            onMouseMove: function(e) {
                if (!isLocked || player.isDead) return;
                camera.rotation.y -= e.movementX * 0.002;
                camera.rotation.x -= e.movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            }
        };

        const GameStats = {
            highestCombo: 0,
            botKills: 0, 
            persistentAchievements: [],
            moves: {
                slideHit: 0,
                midAirHit: 0,
                longAirHit: 0,
                teleportHit: 0,
                wallJumpHit: 0
            },
            reset: function() {
                this.highestCombo = 0;
                this.botKills = 0;
                this.persistentAchievements = [];
                for(let k in this.moves) this.moves[k] = 0;
            },
            addAchievement: function(name, color="#ff00ff", type="PERSISTENT") {
                showKillMessage(name, "achievement", color);
                if (type === "PERSISTENT") {
                    if(!this.persistentAchievements.includes(name)) {
                        this.persistentAchievements.push(name);
                    }
                }
            },
            checkMoveMilestone: function(key, name, color="#00ffff") {
                const count = this.moves[key];
                const rank = MASTERY_RANKS.find(r => r.count === count);
                if (rank) {
                    this.addAchievement(`${name} ${rank.title}`, color, "PERSISTENT");
                }
            },
            checkKillMilestone: function() {
                const rank = KILL_MILESTONES.find(r => r.count === this.botKills);
                if (rank) {
                    this.addAchievement(rank.title, "#ff0000", "PERSISTENT");
                }
            }
        };

        const AudioSys = {
            ctx: null,
            slideOsc: null,
            slideGain: null,
            
            init: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            
            playTone: function(freq, type, duration, vol=0.1, ramp='exp') {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                if(ramp === 'exp') gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                else gain.gain.linearRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            toggleSlideSound: function(active) {
                    if(!this.ctx) return;
                    const t = this.ctx.currentTime;
                    if(active && !this.slideOsc) {
                        const bufferSize = this.ctx.sampleRate; 
                        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                        const data = buffer.getChannelData(0);
                        for(let i=0; i<bufferSize; i++) data[i] = Math.random()*2-1;

                        this.slideOsc = this.ctx.createBufferSource();
                        this.slideOsc.buffer = buffer;
                        this.slideOsc.loop = true;

                        const filter = this.ctx.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.setValueAtTime(300, t); 
                        
                        this.slideGain = this.ctx.createGain();
                        this.slideGain.gain.setValueAtTime(0, t);
                        this.slideGain.gain.linearRampToValueAtTime(0.15, t + 0.3); 

                        this.slideOsc.connect(filter);
                        filter.connect(this.slideGain);
                        this.slideGain.connect(this.ctx.destination);
                        this.slideOsc.start();
                    } else if (!active && this.slideOsc) {
                        try {
                            this.slideGain.gain.linearRampToValueAtTime(0, t + 0.2);
                            this.slideOsc.stop(t + 0.2);
                        } catch(e) {}
                        this.slideOsc = null;
                        this.slideGain = null;
                    }
                },

            playJump: function() { 
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(400, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            },

            playWallJump: function() {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            },

            playSlash: function() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc1 = this.ctx.createOscillator();
                osc1.type = 'triangle';
                osc1.frequency.setValueAtTime(1200, t); 
                osc1.frequency.exponentialRampToValueAtTime(200, t + 0.15);
                const g1 = this.ctx.createGain();
                g1.gain.setValueAtTime(0.25, t);
                g1.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                osc1.connect(g1); g1.connect(this.ctx.destination);
                osc1.start(); osc1.stop(t + 0.2);
            },
            
            playMiss: function() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const bSize = this.ctx.sampleRate * 0.1;
                const b = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const d = b.getChannelData(0);
                for(let i=0;i<bSize;i++) d[i] = Math.random()*2-1;
                const n = this.ctx.createBufferSource();
                n.buffer = b;
                const ng = this.ctx.createGain();
                ng.gain.setValueAtTime(0.1, t);
                ng.gain.exponentialRampToValueAtTime(0.001, t+0.1);
                const nf = this.ctx.createBiquadFilter();
                nf.type = 'lowpass';
                nf.frequency.value = 800;
                n.connect(nf); nf.connect(ng); ng.connect(this.ctx.destination);
                n.start();
            },

            playHit: function() { 
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const oscA = this.ctx.createOscillator();
                oscA.type = 'square';
                oscA.frequency.setValueAtTime(450, t);
                oscA.frequency.exponentialRampToValueAtTime(300, t+0.15);
                const oscB = this.ctx.createOscillator();
                oscB.type = 'square';
                oscB.frequency.setValueAtTime(680, t);
                oscB.frequency.exponentialRampToValueAtTime(500, t+0.15);
                const gainA = this.ctx.createGain();
                gainA.gain.setValueAtTime(0.1, t);
                gainA.gain.exponentialRampToValueAtTime(0.001, t+0.15);
                const gainB = this.ctx.createGain();
                gainB.gain.setValueAtTime(0.1, t);
                gainB.gain.exponentialRampToValueAtTime(0.001, t+0.15);
                oscA.connect(gainA); oscA.start(); oscA.stop(t+0.15);
                oscB.connect(gainB); oscB.start(); oscB.stop(t+0.15);
                gainA.connect(this.ctx.destination);
                gainB.connect(this.ctx.destination);
            },

            playTeleport: function() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.exponentialRampToValueAtTime(2000, t + 0.1);
                gain.gain.setValueAtTime(0.2, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(t + 0.2);
            },
            
            playExplosion: function(type) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const bSize = this.ctx.sampleRate * 0.8;
                const b = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
                const d = b.getChannelData(0);
                for(let i=0;i<bSize;i++) d[i] = Math.random()*2-1;
                const n = this.ctx.createBufferSource();
                n.buffer = b;
                const ng = this.ctx.createGain();
                const osc = this.ctx.createOscillator();
                const og = this.ctx.createGain();
                
                if (type === 'STICKY') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(40, t); 
                    osc.frequency.exponentialRampToValueAtTime(600, t + 0.3); 
                    og.gain.setValueAtTime(0, t);
                    og.gain.linearRampToValueAtTime(0.25, t + 0.25); 
                    og.gain.setValueAtTime(0, t + 0.3); 
                    const snapOsc = this.ctx.createOscillator();
                    const snapGain = this.ctx.createGain();
                    snapOsc.type = 'triangle';
                    snapOsc.frequency.setValueAtTime(100, t + 0.31); 
                    snapOsc.frequency.exponentialRampToValueAtTime(40, t + 0.45);
                    snapGain.gain.setValueAtTime(0, t);
                    snapGain.gain.setValueAtTime(0.5, t + 0.31); 
                    snapGain.gain.exponentialRampToValueAtTime(0.01, t + 0.6);
                    snapOsc.connect(snapGain);
                    snapGain.connect(this.ctx.destination);
                    snapOsc.start(t + 0.31); snapOsc.stop(t + 0.7);
                    const nf = this.ctx.createBiquadFilter();
                    nf.type = 'bandpass';
                    nf.frequency.setValueAtTime(100, t);
                    nf.frequency.exponentialRampToValueAtTime(1500, t + 0.3); 
                    nf.Q.value = 2.0; 
                    ng.gain.setValueAtTime(0, t);
                    ng.gain.linearRampToValueAtTime(0.3, t + 0.25); 
                    ng.gain.setValueAtTime(0, t + 0.3); 
                    n.connect(nf); nf.connect(ng);
                } else if (type === 'IMPULSE') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(40, t); 
                    osc.frequency.exponentialRampToValueAtTime(550, t + 0.08); 
                    osc.frequency.exponentialRampToValueAtTime(30, t + 0.6); 
                    og.gain.setValueAtTime(0, t);
                    og.gain.linearRampToValueAtTime(0.5, t + 0.015); 
                    og.gain.exponentialRampToValueAtTime(0.01, t + 0.5); 
                    const nf = this.ctx.createBiquadFilter();
                    nf.type = 'lowpass';
                    nf.frequency.setValueAtTime(600, t); 
                    nf.frequency.exponentialRampToValueAtTime(40, t + 0.6);
                    nf.Q.setValueAtTime(8, t); 
                    nf.Q.exponentialRampToValueAtTime(1, t + 0.15);
                    ng.gain.setValueAtTime(0.35, t); 
                    ng.gain.exponentialRampToValueAtTime(0.01, t + 0.6); 
                    n.connect(nf); nf.connect(ng);
                } else { 
                    osc.type = 'triangle'; 
                    osc.frequency.setValueAtTime(65, t); 
                    osc.frequency.exponentialRampToValueAtTime(30, t + 0.3); 
                    og.gain.setValueAtTime(0.6, t);
                    og.gain.exponentialRampToValueAtTime(0.01, t + 0.9);
                    const distortionGain = this.ctx.createGain();
                    distortionGain.gain.setValueAtTime(1.0, t);
                    distortionGain.gain.linearRampToValueAtTime(0, t + 0.05); 
                    const nf = this.ctx.createBiquadFilter();
                    nf.type = 'lowpass';
                    nf.frequency.setValueAtTime(450, t); 
                    nf.frequency.linearRampToValueAtTime(60, t + 0.6);
                    nf.Q.value = 1.0; 
                    ng.gain.setValueAtTime(0.7, t);
                    ng.gain.linearRampToValueAtTime(0, t + 1.5); 
                    n.connect(nf); nf.connect(ng);
                }
                osc.connect(og); og.connect(this.ctx.destination);
                osc.start(); osc.stop(t+1.0);
                ng.connect(this.ctx.destination);
                n.start();
            },

            playThrow: function() {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle'; 
                osc.frequency.setValueAtTime(180, t);
                osc.frequency.exponentialRampToValueAtTime(600, t + 0.03); 
                osc.frequency.exponentialRampToValueAtTime(60, t + 0.12);
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.12, t + 0.005); 
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.12);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + 0.15);
            },

            playHeartbeat: function(speed) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const playThump = (time, freq, vol, duration) => {
                    const osc = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(freq, time);
                    osc.frequency.exponentialRampToValueAtTime(1, time + duration);
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(120, time);
                    g.gain.setValueAtTime(vol, time);
                    g.gain.exponentialRampToValueAtTime(0.001, time + duration);
                    osc.connect(filter); filter.connect(g); g.connect(this.ctx.destination);
                    osc.start(time); osc.stop(time + duration + 0.05);
                };
                playThump(t, 60, 0.6, 0.12);
                playThump(t + 0.14, 45, 0.4, 0.15);
            },
            
            playUI: function(active) { this.playTone(active ? 800 : 400, 'sine', 0.05, 0.05); },
            stopAll: function() { this.toggleSlideSound(false); }
        };

        // --- GLOBAL STATE ---
        let scene, camera, renderer;
        let isLocked = false;
        let lastTime = performance.now();
        let lastUnlockTime = 0; 
        
        let currentTheme = 0; 
        let teleportMode = 'AIM'; 
        let comboCount = 0;
        let comboTimer = 0;
        let lastSlashID = 0; 
        let slashActive = false;
        
        let segmentStartTime = 0;     
        let bankedActiveTime = 0;      
        let totalBreakTime = 0;        
        let breakStartTime = 0;        
        let breakCount = 0;            
        let lastSegmentDuration = 0;   
        
        let lastHeartbeatTime = 0;
        let lastHoveredEnemy = null;
        let windTimer = 0;
        let windActive = false;
        const windTarget = new THREE.Vector3();
        const currentWind = new THREE.Vector3();
        
        let showFPS = false;
        let fpsFrames = 0;
        let lastFpsTime = 0;
        let sharedSnowGeo = null;
        let sharedLeafGeo = null;
        let frameCounter = 0;
        const globalRaycaster = new THREE.Raycaster();
        
        const sharedEnemyGeo = new THREE.BoxGeometry(1, 2, 1);
        const sharedEnemyEdgeGeo = new THREE.EdgesGeometry(sharedEnemyGeo);
        
        const _vec3_1 = new THREE.Vector3();
        const _vec3_2 = new THREE.Vector3();
        const _vec3_3 = new THREE.Vector3(); 
        const _box3_1 = new THREE.Box3(); 
        
        // Dedicated variables for ground checks to prevent recursion bugs
        const _groundBox = new THREE.Box3();
        const _groundVec1 = new THREE.Vector3();
        const _groundVec2 = new THREE.Vector3();
        const _groundSet = new Set();

        const materials = {};
        const textures = {};
        
        // --- MULTI-WORLD ARCHITECTURE (v47.0) ---
        // Entities are now pointers to active world arrays
        let worldObjects = []; 
        let groundObjects = []; 
        let walls = [];        
        let enemies = [];
        let decorations = [];
        let portals = [];
        let spatialGrid = null;
        let currentWorldGroup = null;

        // Transient effects (Projectiles, Particles) remain global but are cleared on swap
        const particles = [];
        const weatherParticles = [];
        const projectiles = [];

        class SpatialHashGrid {
            constructor(bounds, dimensions) {
                const [x, z] = dimensions;
                this.cells = new Map();
                this.cellSize = 50;
                // MEMORY FIX: Create ONE re-usable set for the entire game session
                this.querySet = new Set();
            }

            _getKey(x, z) {
                return `${Math.floor(x / this.cellSize)}:${Math.floor(z / this.cellSize)}`;
            }

            insert(mesh, box) {
                const minX = Math.floor(box.min.x / this.cellSize);
                const maxX = Math.floor(box.max.x / this.cellSize);
                const minZ = Math.floor(box.min.z / this.cellSize);
                const maxZ = Math.floor(box.max.z / this.cellSize);
                const entry = { mesh, box };
                for (let x = minX; x <= maxX; x++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        const key = `${x}:${z}`;
                        if (!this.cells.has(key)) this.cells.set(key, []);
                        this.cells.get(key).push(entry);
                    }
                }
            }

            query(box, targetSet) {
                // Use the passed set, or default to the class-wide set
                const set = targetSet || this.querySet;
                set.clear();
                
                const minX = Math.floor(box.min.x / this.cellSize);
                const maxX = Math.floor(box.max.x / this.cellSize);
                const minZ = Math.floor(box.min.z / this.cellSize);
                const maxZ = Math.floor(box.max.z / this.cellSize);
                
                for (let x = minX; x <= maxX; x++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        const key = `${x}:${z}`;
                        const cell = this.cells.get(key);
                        if (cell) {
                            for (let i = 0; i < cell.length; i++) {
                                set.add(cell[i]);
                            }
                        }
                    }
                }
                return set;
            }
        }
        
        class WorldState {
            constructor(name, config) {
                this.name = name;
                this.config = config; // size, bots, etc.
                this.initialized = false;
                
                this.worldObjects = [];
                this.groundObjects = [];
                this.walls = [];
                this.enemies = [];
                this.decorations = [];
                this.portals = [];
                
                this.spatialGrid = new SpatialHashGrid(null, [config.size, config.size]);
                this.group = new THREE.Group();
                this.group.visible = false; 
                
                this.savedPlayerPos = new THREE.Vector3(0, 2, 0);
            }
        }

        const WorldManager = {
            worlds: {},
            current: null,
            
            init: function() {
                // Initialize World Configurations
                // Reduced fog density for clearer vision and added shadow toggle
                this.worlds['ARENA'] = new WorldState('ARENA', { size: 400, bots: 60, scale: 1, fog: 0.004, far: 1000, useShadows: true });
                this.worlds['TITAN'] = new WorldState('TITAN', { size: 2000, bots: 300, scale: 3, fog: 0.001, far: 4000, useShadows: false });
                scene.add(this.worlds['ARENA'].group);
                scene.add(this.worlds['TITAN'].group);
            },
            
            switch: function(name) {
                const next = this.worlds[name];
                if (!next || next === this.current) return;
                
                // 1. Save State of current
                if (this.current) {
                    this.current.savedPlayerPos.copy(camera.position);
                    this.current.group.visible = false;
                }
                
                // 2. Clear Transient Effects
                particles.forEach(p => { 
                    scene.remove(p.mesh); p.mesh.geometry.dispose(); p.mesh.material.dispose(); 
                });
                particles.length = 0;
                projectiles.forEach(p => { 
                    scene.remove(p.mesh); p.mesh.geometry.dispose(); p.mesh.material.dispose(); 
                });
                projectiles.length = 0;
                weatherParticles.forEach(p => {
                    scene.remove(p.mesh);
                    if(p.mesh.material) p.mesh.material.dispose();
                });
                weatherParticles.length = 0;

                // 3. Swap to New
                this.current = next;
                dirLight.castShadow = next.config.useShadows;
                currentWorldGroup = next.group;
                
                // Update Global Pointers
                worldObjects = next.worldObjects;
                groundObjects = next.groundObjects;
                walls = next.walls;
                enemies = next.enemies;
                decorations = next.decorations;
                portals = next.portals;
                spatialGrid = next.spatialGrid;
                
                // 4. Build if needed
                if (!next.initialized) {
                    LevelBuilder.build(next);
                    next.initialized = true;
                }
                
                // 5. Reveal & Restore
                next.group.visible = true;
                camera.position.copy(next.savedPlayerPos);
                player.velocity.set(0,0,0);
                
                // --- FIX: UPDATE SHADOW CAMERA BOUNDS ---
                // We expand the shadow camera to cover the new map size.
                const halfSize = next.config.size / 2;
                
                // Update frustum to fit the world
                dirLight.shadow.camera.left = -halfSize;
                dirLight.shadow.camera.right = halfSize;
                dirLight.shadow.camera.top = halfSize;
                dirLight.shadow.camera.bottom = -halfSize;
                
                dirLight.position.set(80, 120, 80);
                
                // Extend shadow camera range so it touches the floor
                // Default is 500, which is too short when light is at Y=1000
                dirLight.shadow.camera.far = Math.max(2000, next.config.size); 
                
                // Commit changes
                dirLight.shadow.camera.updateProjectionMatrix();

                // Update Scene Settings
                camera.far = next.config.far;
                camera.updateProjectionMatrix();
                if(scene.fog) scene.fog.density = next.config.fog;
                
                applyTheme(); 
                
                document.getElementById('world-btn').innerText = "WORLD: " + name;
            }
        };

        const LevelBuilder = {
            build: function(worldState) {
                const cfg = worldState.config;
                const group = worldState.group;
                const size = cfg.size;
                const hSize = size / 2;

                // Floor
                this.createBox(0, -1, 0, size, 2, size, materials.floor, true, false, worldState);
                
                // Walls shortened to leave square gaps at the corners
                const wallThick = 10;
                const offset = hSize + (wallThick / 2);

                // All walls are exactly the length of the floor ('size')
                this.createBox(0, 50, -offset, size, 100, wallThick, materials.wall, false, true, worldState);
                this.createBox(0, 50, offset, size, 100, wallThick, materials.wall, false, true, worldState);
                this.createBox(-offset, 50, 0, wallThick, 100, size, materials.wall, false, true, worldState);
                this.createBox(offset, 50, 0, wallThick, 100, size, materials.wall, false, true, worldState);
                
                // Decorations
                const scaleMod = cfg.scale;
                
                // Small
                this.spawnDecorations(Math.floor(25 * scaleMod), 2*scaleMod, 7*scaleMod, size*0.75, size*0.75, worldState);
                // Medium
                this.spawnDecorations(Math.floor(8 * scaleMod), 10*scaleMod, 20*scaleMod, size*0.85, size*0.85, worldState);
                // Large
                this.spawnDecorations(Math.floor(4 * scaleMod), 25*scaleMod, 45*scaleMod, size*0.9, size*0.9, worldState);
                // Massive
                this.spawnDecorations(Math.max(1, Math.floor(1 * scaleMod)), 60*scaleMod, 80*scaleMod, size*0.75, size*0.75, worldState);
                
                // Portals
                this.createPortals(worldState, size * 0.75);
                
                // Bots
                for(let i=0; i<cfg.bots; i++) {
                     new Enemy(null, null, 'ROAM', 0, worldState);
                }
            },
            
            createBox: function(x, y, z, w, h, d, mat, isFloor, isWall, ws) {
                const geo = new THREE.BoxGeometry(w, h, d);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, z);
                
                // Only cast shadows if it's not a floor and not a boundary wall
                mesh.castShadow = !isFloor && !isWall;
                
                mesh.receiveShadow = true;
                mesh.userData.isFloor = isFloor;
                
                if (isWall || !isFloor) {
                     const edges = new THREE.EdgesGeometry(geo);
                     const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.05 }));
                     mesh.add(line);
                }

                // Force environment to draw first so transparent particles don't glitch
                mesh.renderOrder = -1;
                ws.group.add(mesh);
                mesh.geometry.computeBoundingBox();
                mesh.updateMatrixWorld(true);
                const box = mesh.geometry.boundingBox.clone();
                box.applyMatrix4(mesh.matrixWorld);
                
                ws.spatialGrid.insert(mesh, box);
                ws.worldObjects.push(mesh);
                if (isFloor || !isWall) ws.groundObjects.push(mesh);
                if (!isFloor) ws.walls.push(mesh);
            },
            
            spawnDecorations: function(count, minScale, maxScale, rangeX, rangeZ, ws) {
                const obstacleBounds = [];
                for(let i=0; i<count; i++) {
                    let attempts = 0;
                    let valid = false;
                    let x, z, scale;
                    while(!valid && attempts < 20) {
                        attempts++;
                        x = (Math.random() - 0.5) * rangeX;
                        z = (Math.random() - 0.5) * rangeZ;
                        if(Math.abs(x) < 25 && Math.abs(z) < 25) continue;
                        
                        scale = minScale + Math.random() * (maxScale - minScale);
                        const radius = scale * 1.5; 
                        valid = true;
                        for(const b of obstacleBounds) {
                            if(Math.hypot(x - b.x, z - b.z) < (radius + b.r) + 2) { valid = false; break; }
                        }
                        if(valid) {
                            new Decoration(x, z, scale, ws);
                            obstacleBounds.push({x: x, z: z, r: radius});
                        }
                    }
                }
            },
            
            createPortals: function(ws, range) {
                const colors = [0x00ffff, 0xffaa00, 0xaa00ff, 0x00ff00];
                const portalLocs = [];
                
                // TWEAK: Increase density. Was /100, now /50.
                // Titan (2000m) now gets ~40 pairs (80 portals) instead of 20 pairs.
                const pairCount = Math.max(4, Math.floor(range / 50)); 
                
                for(let i=0; i<pairCount*2; i++) {
                    let x, z;
                    do {
                        x = (Math.random()-0.5)*range;
                        z = (Math.random()-0.5)*range;
                    } while(Math.abs(x) < 30 && Math.abs(z) < 30);
                    
                    // This now uses the fixed getGroundHeight, so it will hit box tops
                    const y = getGroundHeight(x, z); 
                    portalLocs.push({x, y, z});
                }
                
                for(let i=0; i<pairCount; i++) {
                    const c = colors[i % colors.length];
                    const p1 = new Portal(portalLocs[i*2].x, portalLocs[i*2].y, portalLocs[i*2].z, c, null, ws);
                    const p2 = new Portal(portalLocs[i*2+1].x, portalLocs[i*2+1].y, portalLocs[i*2+1].z, c, null, ws);
                    p1.target = p2; p2.target = p1;
                }
            }
        };

        // --- PLAYER CONTROLLER CLASS (v46.2) ---
        class PlayerController {
            constructor() {
                this.velocity = new THREE.Vector3();
                this.onGround = false;
                this.jumpsRemaining = 3; 
                this.isSliding = false;
                this.isCrouching = false;
                this.isSprinting = false;
                this.health = CONFIG.playerMaxHP;
                this.energy = CONFIG.energyMax; 
                this.score = 0;
                this.extraLives = 0;
                this.isDead = false;
                this.cameraHeightOffset = 0;
                this.lastDamageTime = 0;
                this.isRegenerating = false;
                this.teleportActive = false;
                this.teleportTarget = null;
                this.airTimeStart = 0;
                this.lastSlideTime = 0;
                this.lastJumpTime = 0;
                this.lastTeleportTime = 0;
                this.lastWallJumpTime = 0;
                this.lastTeleportWasAerial = false;
                this.hasPhaseStruck = false;
                this.totalHits = 0;
                this.tpAimStartTime = 0;
                this.wallImpactVelocity = 0;
                this.wantsToJump = false;
                this.portalCooldown = 0;
                this.isPhasing = false;
                this.phasingTimer = 0;
                this.playerBox = new THREE.Box3();
                this.boxSize = { w: 0.6, h: 1.8 }; 

                this.aimingGadget = null; 
                this.aimLine = null;
                this.lastGadgetTime = 0;
                this.currentWeapon = null;
            }

            init() {
                this.currentWeapon = new Katana(this);
                const segmentCount = 30;
                const vertexCount = segmentCount * 2 + 3; 
                const geo = new THREE.BufferGeometry();
                const positions = new Float32Array(vertexCount * 3);
                geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const indices = [];
                for(let i=0; i<segmentCount-1; i++) {
                    const k = i * 2;
                    indices.push(k, k+1, k+2);
                    indices.push(k+1, k+3, k+2);
                }
                const arrowBase = segmentCount * 2;
                indices.push(arrowBase, arrowBase+1, arrowBase+2);
                geo.setIndex(indices);
                const mat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, opacity: 0.4, transparent: true, side: THREE.DoubleSide, depthWrite: false 
                });
                this.aimLine = new THREE.Mesh(geo, mat); 
                this.aimLine.frustumCulled = false;
                this.aimLine.visible = false;
                camera.add(this.aimLine);
            }
            
            updatePlayerBox() {
                const x = camera.position.x;
                const y = camera.position.y;
                const z = camera.position.z;
                const halfW = this.boxSize.w / 2;
                this.playerBox.min.set(x - halfW, y - 1.6, z - halfW);
                this.playerBox.max.set(x + halfW, y + 0.2, z + halfW);
            }

            onJumpInput(isRepeat) {
                if(this.onGround) {
                    performJump();
                    this.jumpsRemaining--; 
                    this.wantsToJump = true;
                    moveStreaks.longAerial.count = 0;
                    moveStreaks.aerial.count = 0;
                } else {
                     const wallJumped = performWallJump();
                     if (!wallJumped && !isRepeat && this.jumpsRemaining > 0) {
                         this.velocity.y = Math.max(0, this.velocity.y) + CONFIG.jumpForce; 
                         this.jumpsRemaining--;
                         AudioSys.playJump();
                         spawnRipple(camera.position.clone().add(new THREE.Vector3(0,-1.5,0)), new THREE.Vector3(0,1,0), 0x00ffaa);
                     }
                     this.wantsToJump = true;
                }
            }

            onAttackInput() {
                if (teleportMode === 'AIM' && this.teleportActive) {
                    tryAimTeleport();
                    this.currentWeapon.use(); 
                } else {
                    this.currentWeapon.use();
                }
            }

            onTeleportInput() {
                if(teleportMode === 'INSTANT') tryInstantTeleport();
                else if(teleportMode === 'AIM') {
                    this.teleportActive = !this.teleportActive;
                    if(this.teleportActive) this.tpAimStartTime = 0; 
                }
            }
            
            beginAim(type) {
                this.aimingGadget = type;
                document.getElementById('icon-f').classList.toggle('active', type==='FRAG');
                document.getElementById('icon-r').classList.toggle('active', type==='STICKY');
                document.getElementById('icon-e').classList.toggle('active', type==='IMPULSE');
            }
            
            endAim() {
                if(this.aimingGadget) {
                    this.throwGadget(this.aimingGadget);
                    this.aimingGadget = null;
                    this.aimLine.visible = false;
                    document.getElementById('icon-f').classList.remove('active');
                    document.getElementById('icon-r').classList.remove('active');
                    document.getElementById('icon-e').classList.remove('active');
                }
            }

            throwGadget(type) {
                const now = performance.now();
                if (now - this.lastGadgetTime < CONFIG.gadgetCooldown) return;
                
                let cost = 0;
                if (type === 'FRAG') cost = CONFIG.gadgetCost.frag;
                if (type === 'STICKY') cost = CONFIG.gadgetCost.sticky;
                if (type === 'IMPULSE') cost = CONFIG.gadgetCost.impulse;

                if (this.energy < cost) {
                    AudioSys.playMiss();
                    return;
                }

                this.energy -= cost;
                this.lastGadgetTime = now;

                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                const spawnPos = camera.position.clone().addScaledVector(dir, 1.0);
                const vel = dir.multiplyScalar(50).add(this.velocity);
                projectiles.push(new Projectile(type, spawnPos, vel));
                AudioSys.playThrow();
            }

            update(dt) {
                if (this.isDead) return;
                
                if(this.currentWeapon) this.currentWeapon.update(dt);
                if (this.portalCooldown > 0) this.portalCooldown -= dt;
                
                if (this.phasingTimer > 0) {
                    this.phasingTimer -= dt;
                    if (this.phasingTimer <= 0) this.isPhasing = false;
                }

                if (isLocked && InputManager.mouseDown) {
                    this.onAttackInput();
                }

                camera.position.y -= this.cameraHeightOffset;
                this.handleHealthRegen(dt);
                this.handleEnergy(dt);
                this.handleTeleport(dt);
                
                if (this.aimingGadget) {
                    this.aimLine.visible = true;
                    const posAttr = this.aimLine.geometry.attributes.position;
                    const positions = posAttr.array;
                    let p = new THREE.Vector3(1.25, -1, -8); 
                    let v = new THREE.Vector3(0, 0, -50);
                    const invRot = camera.quaternion.clone().invert();
                    const localGravity = new THREE.Vector3(0, -CONFIG.gravity, 0).applyQuaternion(invRot);
                    let idx = 0;
                    let lastP = p.clone();

                    for(let i=0; i<30; i++) {
                        positions[idx++] = p.x - 1; positions[idx++] = p.y; positions[idx++] = p.z;
                        positions[idx++] = p.x + 1; positions[idx++] = p.y; positions[idx++] = p.z;
                        lastP.copy(p);
                        p.addScaledVector(v, 0.05);
                        v.addScaledVector(localGravity, 0.05);
                    }
                    const tipDir = v.clone().normalize();
                    positions[idx++] = lastP.x - 2; positions[idx++] = lastP.y; positions[idx++] = lastP.z;
                    positions[idx++] = lastP.x + 2; positions[idx++] = lastP.y; positions[idx++] = lastP.z;
                    const tip = lastP.clone().addScaledVector(tipDir, 5);
                    positions[idx++] = tip.x; positions[idx++] = tip.y; positions[idx++] = tip.z;
                    posAttr.needsUpdate = true;
                }

                const timeSteps = Math.min(5, Math.ceil(dt / 0.01)); 
                const subDt = dt / timeSteps;
                
                for(let i=0; i<timeSteps; i++) {
                    this.physicsStep(subDt);
                }

                const keys = InputManager.keys;
                const speed = new THREE.Vector2(this.velocity.x, this.velocity.z).length();
                
                if (keys.c && this.onGround) {
                     if ((this.isSprinting || this.isSliding || speed > CONFIG.baseSpeed) && !this.isCrouching) {
                         if (!this.isSliding) {
                            this.isSliding = true;
                            this.lastSlideTime = performance.now();
                            const forward = new THREE.Vector3();
                            camera.getWorldDirection(forward);
                            forward.y = 0; forward.normalize();
                            this.velocity.addScaledVector(forward, CONFIG.slideBoost);
                         }
                     } else if (!this.isSliding) {
                         this.isCrouching = true;
                     }
                } else {
                     this.isSliding = false;
                     this.isCrouching = false;
                }
                
                if (this.isSliding && currentTheme === 0) {
                    if (Math.random() < 0.3) spawnSnowTrail(camera.position);
                    if (Math.random() < 0.5) spawnSnowKickup(camera.position);
                }
                AudioSys.toggleSlideSound(this.isSliding && speed > 5);

                const targetHeight = (this.isSliding || this.isCrouching) ? -0.8 : 0;
                this.cameraHeightOffset = THREE.MathUtils.lerp(this.cameraHeightOffset, targetHeight, dt * 15);
                camera.position.y += this.cameraHeightOffset;
                
                if (this.portalCooldown <= 0) {
                    for(let p of portals) {
                        if (camera.position.distanceTo(p.mesh.position) < 2.0) {
                             p.teleportEntity(camera.position, this.velocity);
                             this.portalCooldown = 0.2; 
                             const forward = new THREE.Vector3();
                             camera.getWorldDirection(forward);
                             this.velocity.addScaledVector(forward, 5); 
                             break;
                        }
                    }
                }
                
                if (camera.position.y < -100) {
                    GameStats.addAchievement("DOWN THE RABBIT HOLE", "#ff00ff", "PERSISTENT");
                    damagePlayer(20);
                    camera.position.set(0, 2, 0);
                    this.velocity.set(0,0,0);
                }
            }
            
            physicsStep(dt) {
                const keys = InputManager.keys;
                const isMoving = (keys.w || keys.a || keys.s || keys.d);
                this.isSprinting = keys.shift && this.energy > 0 && isMoving && !this.isCrouching;

                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                camera.getWorldDirection(forward);
                forward.y = 0; forward.normalize();
                right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

                const inputDir = new THREE.Vector3();
                if (keys.w) inputDir.add(forward);
                if (keys.s) inputDir.sub(forward);
                if (keys.a) inputDir.sub(right);
                if (keys.d) inputDir.add(right);
                if (inputDir.length() > 0) inputDir.normalize();
                
                let targetSpeed = CONFIG.baseSpeed;
                if (this.isCrouching) targetSpeed = CONFIG.crouchSpeed;
                if (this.isSprinting) targetSpeed = CONFIG.sprintSpeed;

                let friction = this.onGround ? CONFIG.frictionGround : CONFIG.frictionAir;
                let drive = friction;
                if (!this.onGround) { friction = CONFIG.frictionAir; drive = CONFIG.airControl; }

                if (this.isSliding) { 
                    if (this.onGround) {
                        friction = CONFIG.frictionSlide; 
                        drive = 1; 
                        targetSpeed = CONFIG.sprintSpeed; 
                    } else {
                        friction = CONFIG.frictionAir; 
                        drive = CONFIG.airControl * 0.5; 
                    }
                }

                if (inputDir.length() > 0) {
                    this.velocity.addScaledVector(inputDir, targetSpeed * drive * dt);
                }

                const damping = Math.exp(-friction * dt);
                this.velocity.x *= damping;
                this.velocity.z *= damping;

                this.velocity.y -= CONFIG.gravity * dt;
                camera.position.y += this.velocity.y * dt;
                this.updatePlayerBox();
                const wasOnGround = this.onGround;
                this.onGround = false;
                
                if (spatialGrid) {
                    let collisions = spatialGrid.query(this.playerBox);
                    for(const wall of collisions) {
                        if (this.playerBox.intersectsBox(wall.box)) {
                            const overlapY = Math.min(this.playerBox.max.y - wall.box.min.y, wall.box.max.y - this.playerBox.min.y);
                            const overlapX = Math.min(this.playerBox.max.x - wall.box.min.x, wall.box.max.x - this.playerBox.min.x);
                            const overlapZ = Math.min(this.playerBox.max.z - wall.box.min.z, wall.box.max.z - this.playerBox.min.z);
                            
                            if (overlapX > 0 && overlapZ > 0) {
                                if (this.velocity.y < 0) {
                                    if (this.playerBox.min.y < wall.box.max.y && this.playerBox.min.y > wall.box.min.y) {
                                        camera.position.y += overlapY;
                                        this.velocity.y = 0;
                                        this.onGround = true;
                                        if(!wasOnGround) {
                                            this.jumpsRemaining = 3; 
                                            moveStreaks.longAerial.count = 0; 
                                            moveStreaks.aerial.count = 0;
                                            this.lastTeleportWasAerial = false; 
                                        }
                                    }
                                } else if (this.velocity.y > 0) {
                                    if (this.playerBox.max.y > wall.box.min.y && this.playerBox.max.y < wall.box.max.y) {
                                        camera.position.y -= overlapY;
                                        this.velocity.y = 0;
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (wasOnGround && !this.onGround) {
                     this.airTimeStart = performance.now();
                }

                if (this.wantsToJump) {
                    if (this.onGround) {
                        performJump();
                        moveStreaks.longAerial.count = 0;
                        moveStreaks.aerial.count = 0;
                    } else {
                        performWallJump();
                    }
                }

                camera.position.x += this.velocity.x * dt;
                if (!this.isPhasing && spatialGrid) {
                    this.updatePlayerBox();
                    let collisions = spatialGrid.query(this.playerBox);
                    for(const wall of collisions) {
                        if (this.playerBox.intersectsBox(wall.box)) {
                            const overlapX = Math.min(this.playerBox.max.x - wall.box.min.x, wall.box.max.x - this.playerBox.min.x);
                            const overlapY = Math.min(this.playerBox.max.y - wall.box.min.y, wall.box.max.y - this.playerBox.min.y);
                            const overlapZ = Math.min(this.playerBox.max.z - wall.box.min.z, wall.box.max.z - this.playerBox.min.z);
                            if (overlapY > 0.1 && overlapZ > 0) {
                                if (this.velocity.x > 0) camera.position.x -= overlapX;
                                else camera.position.x += overlapX;
                                this.wallImpactVelocity = Math.abs(this.velocity.x);
                                this.velocity.x = 0;
                            }
                        }
                    }
                }

                camera.position.z += this.velocity.z * dt;
                if (!this.isPhasing && spatialGrid) {
                    this.updatePlayerBox();
                    let collisions = spatialGrid.query(this.playerBox);
                    for(const wall of collisions) {
                        if (this.playerBox.intersectsBox(wall.box)) {
                            const overlapX = Math.min(this.playerBox.max.x - wall.box.min.x, wall.box.max.x - this.playerBox.min.x);
                            const overlapY = Math.min(this.playerBox.max.y - wall.box.min.y, wall.box.max.y - this.playerBox.min.y);
                            const overlapZ = Math.min(this.playerBox.max.z - wall.box.min.z, wall.box.max.z - this.playerBox.min.z);
                            if (overlapY > 0.1 && overlapX > 0) {
                                if (this.velocity.z > 0) camera.position.z -= overlapZ;
                                else camera.position.z += overlapZ;
                                this.wallImpactVelocity = Math.abs(this.velocity.z);
                                this.velocity.z = 0;
                            }
                        }
                    }
                }
            }

            handleHealthRegen(dt) {
                const now = performance.now();
                if (this.isRegenerating) {
                    this.health += CONFIG.regenRate * dt;
                    if (this.health >= CONFIG.playerMaxHP) { 
                        this.health = CONFIG.playerMaxHP;
                        this.isRegenerating = false;
                    }
                } else {
                    if (now - this.lastDamageTime > CONFIG.regenDelay && this.health < CONFIG.playerMaxHP) {
                        this.isRegenerating = true;
                    }
                }
                
                const vignette = document.getElementById('low-health-vignette');
                const healthFill = document.getElementById('health-fill');
                const maxHP = CONFIG.playerMaxHP;
                if (this.health < maxHP * 0.4) {
                    if (!healthFill.classList.contains('health-critical')) healthFill.classList.add('health-critical');
                    if (this.health < maxHP * 0.25) vignette.style.boxShadow = "inset 0 0 150px rgba(255, 0, 0, 0.6)";
                    else vignette.style.boxShadow = "inset 0 0 100px rgba(255, 0, 0, 0.3)";
                    
                    let hbInterval = 1.0;
                    if(this.health < maxHP * 0.2) hbInterval = 0.4;
                    else if(this.health < maxHP * 0.4) hbInterval = 0.8;
                    const nowSec = performance.now() / 1000;
                    if(nowSec - lastHeartbeatTime > hbInterval) {
                        AudioSys.playHeartbeat();
                        lastHeartbeatTime = nowSec;
                    }
                } else {
                     if (healthFill.classList.contains('health-critical')) healthFill.classList.remove('health-critical');
                     vignette.style.boxShadow = "inset 0 0 100px rgba(255, 0, 0, 0)";
                }
            }

            handleEnergy(dt) {
                if (this.isSprinting) {
                    this.energy -= CONFIG.energyDrain * dt;
                    if (this.energy < 0) this.energy = 0;
                } else {
                    this.energy += CONFIG.energyRegen * dt;
                    if (this.energy > CONFIG.energyMax) this.energy = CONFIG.energyMax;
                }
            }

            handleTeleport(dt) {
                if (teleportMode === 'AIM' && this.teleportActive) {
                    const result = getTeleportTarget();
                    
                    // 1. Position: Snap exactly to the hit point (Feet Location).
                    // We do NOT add a normal offset here, so the ring sits exactly on the floor/surface.
                    teleportMarker.position.copy(result.point);
                    this.teleportTarget = result.point;

                    // 2. Orientation: Force Upright (World Y-Up).
                    // The marker represents the player's body and feet, which always stay upright 
                    // regardless of the surface angle (walls/slopes).
                    teleportMarker.rotation.set(0, 0, 0); 
                    
                    teleportMarker.visible = true;

                    // --- Enemy Highlighting Logic ---
                    let closestEnemy = null;
                    let closestDist = 999;
                    for (const enemy of enemies) {
                        if (enemy.isDeadCorpse) continue;
                        const dist = this.teleportTarget.distanceTo(enemy.mesh.position);
                        const threshold = 2.5 + (enemy.type.scale || 1);
                        if (dist < threshold && dist < closestDist) {
                            closestDist = dist;
                            closestEnemy = enemy;
                        }
                    }

                    if (lastHoveredEnemy && lastHoveredEnemy !== closestEnemy) {
                        lastHoveredEnemy.setHighlight(false);
                    }
                    if (closestEnemy) {
                        closestEnemy.setHighlight(true);
                        lastHoveredEnemy = closestEnemy;
                    } else {
                        lastHoveredEnemy = null;
                    }
                    
                    // --- Visual Animation & Colors ---
                    const t = performance.now();
                    teleportMarker.userData.diamond.rotation.y += dt * 2.0;
                    
                    if (!this.tpAimStartTime) this.tpAimStartTime = performance.now();
                    const timeActive = performance.now() - this.tpAimStartTime;
                    const cycle = (Math.cos(timeActive * 0.0015) + 1) / 2; 
                    
                    const baseCol = new THREE.Color(0x00ffff); 
                    const whiteCol = new THREE.Color(0xffffff);
                    const targetColor = baseCol.clone().lerp(whiteCol, cycle);
                    const targetOpacity = 0.3 + (0.7 * cycle);
                    
                    materials.marker.opacity = targetOpacity;
                    materials.marker.color.copy(targetColor);
                    materials.marker.emissive.copy(targetColor);
                    materials.marker.emissiveIntensity = 2.0 * cycle;
                    
                    teleportMarker.userData.ringMat.opacity = targetOpacity;
                    teleportMarker.userData.ringMat.color.copy(targetColor);
                    teleportMarker.userData.ringMat.emissive.copy(targetColor);
                    teleportMarker.userData.ringMat.emissiveIntensity = 2.0 * cycle;

                    // 3. Diamond Animation: Relative to the Ring
                    // The Ring is at 0 (Feet). The Diamond floats at body height (~1.5m).
                    // This maintains the correct relative distance regardless of where the marker is.
                    const pulse = Math.sin(t * 0.003); 
                    const hoverY = 1.5 + pulse * 0.2;
                    
                    teleportMarker.userData.diamond.position.y = hoverY;
                    teleportMarker.userData.ring.scale.setScalar(1 + pulse * 0.05);

                    document.getElementById('icon-q').classList.add('active');
                } else {
                    teleportMarker.visible = false;
                    this.tpAimStartTime = 0; 
                    document.getElementById('icon-q').classList.remove('active');
                    if (lastHoveredEnemy) {
                        lastHoveredEnemy.setHighlight(false);
                        lastHoveredEnemy = null;
                    }
                }
                
                const ch = document.getElementById('crosshair');
                if (slashActive || (teleportMode === 'AIM' && this.teleportActive)) {
                    ch.style.opacity = 0;
                } else {
                    ch.style.opacity = 1;
                }
            }
        }

        const player = new PlayerController();

        const moveStreaks = {
            slide: { count: 0, lastTime: 0 },
            aerial: { count: 0, lastTime: 0 },
            longAerial: { count: 0, lastTime: 0 },
            wall: { count: 0, lastTime: 0 },
            phase: { count: 0, lastTime: 0 }
        };

        let teleportMarker;
        let slashGeometry; 
        let lastAttackTime = 0;
        let currentSlashColor = 0x0088ff;
        
        class Portal {
            constructor(x, y, z, color, targetPortal = null, ws = null) {
                this.mesh = new THREE.Group();
                this.mesh.position.set(x, y + 2.5, z); 
                
                const geo = new THREE.IcosahedronGeometry(1.5, 0);
                const mat = materials.marker.clone();
                mat.color.setHex(color);
                mat.emissive.setHex(color);
                mat.transparent = true;
                mat.opacity = 0.5;
                mat.wireframe = true;
                
                this.inner = new THREE.Mesh(geo, mat);
                this.mesh.add(this.inner);
                
                const outerGeo = new THREE.IcosahedronGeometry(2.0, 0);
                const outerMat = mat.clone();
                outerMat.opacity = 0.2;
                this.outer = new THREE.Mesh(outerGeo, outerMat);
                this.mesh.add(this.outer);

                this.particles = [];
                for(let i=0; i<5; i++) {
                     const p = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({color: 0xffffff}));
                     this.mesh.add(p);
                     this.particles.push({ mesh: p, offset: Math.random() * 10, speed: 0.5 + Math.random() });
                }

                if (ws) {
                    ws.group.add(this.mesh);
                    ws.portals.push(this);
                } else {
                    scene.add(this.mesh);
                    portals.push(this);
                }
                this.target = targetPortal;
                this.color = color;
                this.radius = 2.0;
            }
            
            update(dt) {
                const t = performance.now() * 0.001;
                this.inner.rotation.y = t * 2;
                this.inner.rotation.x = t;
                this.outer.rotation.y = -t;
                this.outer.rotation.z = t * 0.5;
                
                const scale = 1 + Math.sin(t * 3) * 0.1;
                this.inner.scale.setScalar(scale);
                
                this.particles.forEach(p => {
                    const time = t * p.speed + p.offset;
                    p.mesh.position.set(Math.sin(time)*1, Math.cos(time*1.5)*1, Math.sin(time*0.5)*1);
                    p.mesh.scale.setScalar(0.5 + Math.sin(time*5)*0.3);
                });
                
                if(Math.random() < 0.05) {
                     spawnParticles(this.mesh.position, this.color, 2, 2.0);
                }
            }
            
            teleportEntity(pos, vel) {
                if (this.target) {
                    AudioSys.playTeleport();
                    spawnParticles(pos.clone(), this.color, 20);
                    pos.copy(this.target.mesh.position);
                    const dir = vel.clone().normalize();
                    if(dir.lengthSq() === 0) dir.set(0,0,1);
                    pos.addScaledVector(dir, 3.0); 
                    spawnParticles(pos.clone(), this.target.color, 20);
                }
            }
        }

        class Projectile {
            constructor(type, pos, vel) {
                this.type = type;
                this.velocity = vel.clone();
                this.radius = 0.2;
                this.stuckTo = null;
                this.life = type === 'STICKY' ? 1.5 : (type === 'IMPULSE' ? 10.0 : 3.5);

                const eyePos = camera.position.clone();
                const distToSpawn = eyePos.distanceTo(pos);
                if (distToSpawn > 0.1) {
                    const dirToSpawn = pos.clone().sub(eyePos).normalize();
                    globalRaycaster.set(eyePos, dirToSpawn);
                    globalRaycaster.far = distToSpawn;
                    const hits = globalRaycaster.intersectObjects(worldObjects);
                    
                    if (hits.length > 0) {
                        this.meshPos = hits[0].point.sub(dirToSpawn.multiplyScalar(0.1));
                    } else {
                        this.meshPos = pos.clone();
                    }
                } else {
                    this.meshPos = pos.clone();
                }

                let color = 0xff0000; 
                let roughness = 0.4;  
                let emissiveInt = 0.8;

                if (type === 'STICKY') {
                    color = 0x8A2BE2; 
                    roughness = 1.0;  
                    emissiveInt = 2.0; 
                }
                if (type === 'IMPULSE') {
                    color = 0x00ffff; 
                }

                const geo = new THREE.DodecahedronGeometry(0.2);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: color, 
                    emissive: color, 
                    emissiveIntensity: emissiveInt, 
                    roughness: roughness 
                });
                
                this.mesh = new THREE.Mesh(geo, mat);
                
                const wireGeo = new THREE.DodecahedronGeometry(0.22);
                const wireMat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.5 });
                this.wire = new THREE.Mesh(wireGeo, wireMat);
                this.mesh.add(this.wire);
                
                this.mesh.position.copy(this.meshPos);
                scene.add(this.mesh);
                this.active = true;
                this.portalCooldown = 0;
            }

            update(dt) {
                if (!this.active) return;
                this.life -= dt;
                
                if (this.life < 1.0) {
                     this.wire.material.opacity = Math.random() > 0.5 ? 0.8 : 0.2;
                }

                if (this.life <= 0) {
                    this.explode();
                    return;
                }
                
                if (this.portalCooldown > 0) this.portalCooldown -= dt;

                if (this.stuckTo) {
                    if (this.stuckTo.isDeadCorpse || this.stuckTo.health <= 0) {
                         this.stuckTo = null; 
                    } else {
                         if(this.stuckTo.mesh) {
                            this.mesh.position.copy(this.stuckTo.mesh.position).add(this.stuckOffset);
                         }
                    }
                    return; 
                }

                this.velocity.y -= CONFIG.gravity * dt;
                const nextPos = this.mesh.position.clone().addScaledVector(this.velocity, dt);
                
                if (this.portalCooldown <= 0) {
                     for(let p of portals) {
                         if(nextPos.distanceTo(p.mesh.position) < 2.0) {
                             p.teleportEntity(nextPos, this.velocity);
                             this.mesh.position.copy(nextPos);
                             this.portalCooldown = 0.5;
                             return; 
                         }
                     }
                }
                
                const dir = nextPos.clone().sub(this.mesh.position);
                const dist = dir.length();
                if (dist > 0.001) {
                    globalRaycaster.set(this.mesh.position, dir.normalize());
                    globalRaycaster.far = dist;
                    
                    const hits = globalRaycaster.intersectObjects(worldObjects);
                    
                    let enemyHit = null;
                    for(let e of enemies) {
                         if (!e.isDeadCorpse && e.mesh.position.distanceTo(nextPos) < e.type.scale + 0.5) {
                             enemyHit = e;
                             break;
                         }
                    }

                    if (enemyHit) {
                         if (this.type === 'IMPULSE') {
                             this.active = false; this.explode(); return;
                         }
                         if (this.type === 'STICKY') {
                             this.stuckTo = enemyHit;
                             this.stuckOffset = new THREE.Vector3(0, 1, 0); 
                             return;
                         }
                         if (this.type === 'FRAG') {
                             this.velocity.negate().multiplyScalar(0.4);
                         }
                    }

                    if (hits.length > 0) {
                         if (this.type === 'IMPULSE') {
                             this.active = false; this.explode(); return;
                         }
                         if (this.type === 'STICKY') {
                             this.active = false; 
                             this.mesh.position.copy(hits[0].point);
                             this.velocity.set(0,0,0);
                             this.active = true; 
                             this.stuckTo = { mesh: { position: hits[0].point }, isDeadCorpse: false, health: 1 };
                             this.stuckOffset = new THREE.Vector3(0,0,0);
                             return;
                         }
                        if (this.type === 'FRAG') {
                            const n = hits[0].face.normal;
                            this.velocity.reflect(n).multiplyScalar(0.5); 
                            if (n.y > 0.5) { 
                                this.velocity.x *= 0.6; 
                                this.velocity.z *= 0.6;
                                if (this.velocity.y < 0.5) this.velocity.y = 0;
                            }
                            this.mesh.position.copy(hits[0].point).addScaledVector(n, 0.2);
                        }
                    } else {
                         this.mesh.position.copy(nextPos);
                    }
                } else {
                     this.mesh.position.copy(nextPos);
                }

                this.mesh.rotation.x += dt * 10;
                this.mesh.rotation.z += dt * 10;
            }
            
            explode() {
                this.active = false;
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                
                const pos = this.mesh.position.clone();
                let range = 10;
                let damage = 100;
                let force = 20;
                let color = 0x00ff00;

                if (this.type === 'FRAG') { 
                    range = 30; damage = 200; force = 50; color = 0xffaa00; 
                    this.spawnFirework(pos, range);
                } 
                else if (this.type === 'STICKY') { 
                    range = 25; damage = 150; force = -70; color = 0x8A2BE2; 
                    this.spawnImplosion(pos, range, color);
                } 
                else if (this.type === 'IMPULSE') { 
                    range = 20; damage = 10; force = 60; color = 0x00ffff; 
                    spawnImpact(pos, color, range/2); 
                    this.spawnShockwaveRing(pos, range, color);
                }
                
                if(this.type !== 'STICKY' && this.type !== 'IMPULSE') {
                    spawnImpact(pos, color, range/2); 
                }
                
                spawnRipple(pos, new THREE.Vector3(0,1,0), color);
                AudioSys.playExplosion(this.type);

                for (let e of enemies) {
                    if (e.isDeadCorpse) continue;
                    const dist = e.mesh.position.distanceTo(pos);
                    
                    if (dist < range) {
                        const falloff = 1 - (dist / range);
                        if (damage > 0) e.takeHit(damage * falloff);
                        const dir = e.mesh.position.clone().sub(pos).normalize();
                        
                        if(this.type === 'STICKY') {
                            const pullStrength = (dist / range); 
                            e.velocity.addScaledVector(dir, force * pullStrength); 
                        } else {
                             dir.y = 0.8; dir.normalize(); 
                             e.velocity.addScaledVector(dir, force * falloff);
                        }
                    }
                }
                
                const pDist = camera.position.distanceTo(pos);
                if (pDist < range) {
                     const falloff = 1 - (pDist / range);
                     const dir = camera.position.clone().sub(pos).normalize();
                     
                     if(damage > 0) damagePlayer(damage * 0.1 * falloff);
                     
                     if(this.type === 'STICKY') {
                         const pullStrength = (pDist / range);
                         player.velocity.addScaledVector(dir, force * pullStrength * 0.5);
                     } else {
                         player.velocity.addScaledVector(dir, force * falloff);
                     }
                     player.onGround = false; 
                }
            }

            spawnFirework(pos, range) {
                const pCount = 24;
                const geo = new THREE.BufferGeometry();
                const positions = [];
                const velocities = [];

                for(let i=0; i<pCount; i++) {
                    positions.push(pos.x, pos.y, pos.z);
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(Math.random() * 2 - 1);
                    const speed = (Math.random() * 0.5 + 0.5) * (range * 0.8); 
                    velocities.push(
                        speed * Math.sin(phi) * Math.cos(theta),
                        speed * Math.sin(phi) * Math.sin(theta),
                        speed * Math.cos(phi)
                    );
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                const mat = new THREE.PointsMaterial({
                    color: 0xffd700, size: 0.8, transparent: true, opacity: 1
                });
                const sparks = new THREE.Points(geo, mat);
                scene.add(sparks);
                
                let time = 0;
                const animateSparks = () => {
                    time += 0.05; 
                    if(time > 1.0) { scene.remove(sparks); geo.dispose(); mat.dispose(); return; }
                    const posAttr = sparks.geometry.attributes.position;
                    for(let i=0; i<pCount; i++) {
                        posAttr.array[i*3] += velocities[i*3] * 0.05; 
                        posAttr.array[i*3+1] += (velocities[i*3+1] - 9.8 * time) * 0.05; 
                        posAttr.array[i*3+2] += velocities[i*3+2] * 0.05; 
                    }
                    posAttr.needsUpdate = true;
                    sparks.material.opacity = 1 - time; 
                    requestAnimationFrame(animateSparks);
                };
                animateSparks();
            }

            spawnImplosion(pos, range, color) {
                const geo = new THREE.SphereGeometry(range, 16, 16);
                const mat = new THREE.MeshBasicMaterial({ color: color, wireframe: true, transparent: true, opacity: 0.5 });
                const sphere = new THREE.Mesh(geo, mat);
                sphere.position.copy(pos);
                scene.add(sphere);
                let s = 1.0;
                const anim = () => {
                    s -= 0.05; 
                    if (s <= 0) { scene.remove(sphere); geo.dispose(); mat.dispose(); return; }
                    sphere.scale.set(s, s, s);
                    requestAnimationFrame(anim);
                };
                anim();
            }

            spawnShockwaveRing(pos, range, color) {
                const geo = new THREE.TorusGeometry(1, 0.2, 8, 32); 
                const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
                const ring = new THREE.Mesh(geo, mat);
                ring.rotation.x = Math.PI / 2; 
                ring.position.copy(pos);
                scene.add(ring);
                let s = 1.0;
                const anim = () => {
                    s += (range * 2) * 0.02; 
                    if (s > range * 1.5) { scene.remove(ring); geo.dispose(); mat.dispose(); return; }
                    ring.scale.set(s, s, s);
                    ring.material.opacity -= 0.05;
                    requestAnimationFrame(anim);
                };
                anim();
            }
        }

        class Katana {
            constructor(owner) {
                this.owner = owner;
            }

            update(dt) { }

            use() {
                const now = performance.now();
                if (now - lastAttackTime < CONFIG.attackCooldown) return;
                lastAttackTime = now;

                const COMBO_WINDOW = 1000; 
                const STREAK_WINDOW = 1500; 

                let activeStreakCount = 0;
                const recentSlide = (now - player.lastSlideTime < COMBO_WINDOW) || player.isSliding;
                const recentTeleport = (now - player.lastTeleportTime < COMBO_WINDOW);
                const recentWallJump = (now - player.lastWallJumpTime < COMBO_WINDOW);
                const isAerial = !player.onGround;

                const getStreak = (key) => (now - moveStreaks[key].lastTime < STREAK_WINDOW) ? moveStreaks[key].count : 0;

                if(recentSlide) activeStreakCount += getStreak('slide');
                if(isAerial) {
                    const airDuration = (now - player.airTimeStart) / 1000;
                    if(airDuration > 0.8) activeStreakCount += getStreak('longAerial');
                    else activeStreakCount += getStreak('aerial');
                }
                if(recentTeleport) activeStreakCount += getStreak('phase');
                if(recentWallJump) activeStreakCount += getStreak('wall');

                AudioSys.playSlash();
                const slashMesh = spawnSlash(camera);
                
                const rng = Math.random();
                const missChance = 1/50; 
                const grazeChance = 1/24; 
                const baseCritChance = 1/36; 
                const critBonus = activeStreakCount * 0.01; 
                
                let hitType = "NORMAL";
                let dmgMult = 1.0;
                
                if (rng < missChance) {
                    hitType = "MISS";
                    dmgMult = 0;
                } else if (rng < missChance + grazeChance) {
                    hitType = "GRAZE";
                    dmgMult = 0.5;
                } else if (rng < missChance + grazeChance + baseCritChance + critBonus) {
                    hitType = "CRIT";
                    dmgMult = 3.0;
                }
                
                if (hitType === "MISS") {
                     AudioSys.playMiss();
                     showKillMessage("MISS", "graze");
                     return; 
                }

                const uniqueHitEnemies = new Set();
                const camDir = new THREE.Vector3();
                camera.getWorldDirection(camDir);

                globalRaycaster.setFromCamera(new THREE.Vector2(0, 0), camera); 
                globalRaycaster.far = CONFIG.attackRange;
                
                const hitObjects = [];
                enemies.forEach(e => { 
                    if (!e.isDeadCorpse) e.mesh.traverse(c => hitObjects.push(c)); 
                });
                
                const hitIntersects = globalRaycaster.intersectObjects(hitObjects);
                hitIntersects.forEach(hit => {
                    let hitObj = hit.object;
                    while(hitObj.parent && !enemies.some(e => e.mesh === hitObj)) {
                        hitObj = hitObj.parent;
                    }
                    const enemy = enemies.find(e => e.mesh === hitObj);
                    if(enemy) uniqueHitEnemies.add(enemy);
                });

                enemies.forEach(e => {
                    if(e.isDeadCorpse) return;
                    const toEnemy = e.mesh.position.clone().sub(camera.position);
                    const dist = toEnemy.length();
                    if (dist < CONFIG.attackRange) {
                        toEnemy.normalize();
                        const angle = camDir.angleTo(toEnemy);
                        if (angle < 0.5) { 
                            uniqueHitEnemies.add(e);
                        }
                    }
                });

                if (uniqueHitEnemies.size > 0) {
                    player.totalHits += uniqueHitEnemies.size; 

                    const hitCount = uniqueHitEnemies.size;
                    if (hitCount >= 10) GameStats.addAchievement("SLAUGHTERHOUSE", "#ff0000", "PERSISTENT");
                    else if (hitCount >= 5) GameStats.addAchievement("CROWD CONTROL", "#ff8800", "PERSISTENT");
                    else if (hitCount >= 3) GameStats.addAchievement("TRIPLE THREAT", "#ffff00", "FEED_ONLY"); 

                    let hitScore = 10;
                    let addedScore = 0;
                    let comboNames = [];

                    function updateStreak(type, baseBonus) {
                        if (now - moveStreaks[type].lastTime < STREAK_WINDOW) {
                            moveStreaks[type].count++;
                        } else {
                            moveStreaks[type].count = 0;
                        }
                        moveStreaks[type].lastTime = now;
                        return baseBonus + moveStreaks[type].count;
                    }

                    if (recentSlide) {
                        const bonus = updateStreak('slide', 25);
                        addedScore += bonus;
                        comboNames.push("SLIDE");
                        GameStats.moves.slideHit++;
                        GameStats.checkMoveMilestone('slideHit', "SLIDE", "#00ffff");
                    }
                    
                    const isGroundTeleport = recentTeleport && !player.lastTeleportWasAerial;
                    
                    if (!player.onGround && !isGroundTeleport) {
                         const airDuration = (now - player.airTimeStart) / 1000;
                         if (airDuration > 0.8) {
                            const extraTicks = Math.floor((airDuration - 0.8) / 0.2); 
                            const longAirBonus = 50 + (extraTicks * 10);
                            addedScore += longAirBonus;
                            comboNames.push("LONG AERIAL");
                            GameStats.moves.longAirHit++;
                            GameStats.checkMoveMilestone('longAirHit', "SKY ASSASSIN", "#ff00aa");
                         } else {
                            const bonus = updateStreak('aerial', 25);
                            addedScore += bonus;
                            comboNames.push("AERIAL");
                            GameStats.moves.midAirHit++;
                            GameStats.checkMoveMilestone('midAirHit', "AERIAL", "#ff00aa");
                         }
                    }
                    
                    if (recentTeleport) {
                         let base = 0;
                         if (!player.hasPhaseStruck) {
                             base = 50;
                             player.hasPhaseStruck = true; 
                         }
                         const bonus = updateStreak('phase', base);
                         addedScore += bonus;
                         comboNames.push("TELEPORT");
                         GameStats.moves.teleportHit++;
                         GameStats.checkMoveMilestone('teleportHit', "VOID WALKER", "#aa00ff");
                    }

                    if (recentWallJump) {
                        const bonus = updateStreak('wall', 30);
                        addedScore += bonus;
                        comboNames.push("WALL");
                        GameStats.moves.wallJumpHit++;
                        GameStats.checkMoveMilestone('wallJumpHit', "WALL RUNNER", "#00ffaa");
                    }
                    
                    hitScore += addedScore;
                    
                    if (comboNames.length > 0) {
                        let totalStreak = 0;
                        for(let k in moveStreaks) {
                            if(now - moveStreaks[k].lastTime < STREAK_WINDOW) totalStreak += moveStreaks[k].count;
                        }
                        
                        let streakColor = "#" + new THREE.Color(currentSlashColor).getHexString();
                        if (currentTheme === 0) streakColor = "#001133"; 
                        if (currentTheme === 1) streakColor = "#00ffff"; 
                        
                        let msg = comboNames.join(" ") + " +" + addedScore;
                        if(totalStreak > 0) {
                             msg += ` <span class="slick-streak" style="color:${streakColor}">+${totalStreak}</span>`;
                        }
                        showKillMessage(msg, "combo");
                    }
                    
                    if(hitType === "CRIT") {
                         showKillMessage("CRITICAL HIT!", "critical");
                         spawnParticles(camera.position.clone().add(new THREE.Vector3(0,0,-2)), 0xff0000, 15);
                         AudioSys.playHit(); 
                    } else if(hitType === "GRAZE") {
                         showKillMessage("GRAZE", "graze");
                    }

                    comboCount += uniqueHitEnemies.size;
                    
                    let isAoEKnockback = false;
                    const s = comboCount.toString();
                    if (comboCount >= 100) {
                        if (comboCount % 100 === 0) isAoEKnockback = true;
                        else if (/^(\d)\1+$/.test(s) || "123456789".includes(s) || "987654321".includes(s)) isAoEKnockback = true;
                    }
                    
                    if (isAoEKnockback) {
                        showKillMessage("SHOCKWAVE!", "critical", "#00ffff");
                    }

                    const hitList = Array.from(uniqueHitEnemies).map(e => ({
                        enemy: e,
                        dist: e.mesh.position.distanceTo(camera.position)
                    }));
                    hitList.sort((a, b) => a.dist - b.dist);

                    hitList.forEach((h, index) => {
                        if (h.enemy.state === 'CONFUSED') {
                            GameStats.addAchievement("NO REST FOR THE WICKED", "#aa00ff", "PERSISTENT"); 
                        }
                        const distancePenalty = Math.max(0.1, 1.0 - (index * 0.1));
                        addScore(hitScore); 
                        
                        const finalDamage = CONFIG.playerDamage * distancePenalty * dmgMult;
                        
                        if (hitType === "CRIT" || isAoEKnockback) {
                            const knockDir = h.enemy.mesh.position.clone().sub(camera.position).normalize();
                            knockDir.y = 0.5; 
                            
                            let force = 15;
                            if(isAoEKnockback) force = 30 * (1.0 - (h.dist / CONFIG.attackRange)); 
                            
                            h.enemy.velocity.addScaledVector(knockDir, force);
                            
                            if (h.enemy.state !== 'CONFUSED' && (Math.random() < 0.2 || isAoEKnockback)) {
                                h.enemy.state = 'CONFUSED';
                                h.enemy.confusedTimer = 2.0;
                                h.enemy.mesh.rotation.x = -Math.PI/2; 
                            }
                        }

                        h.enemy.takeHit(finalDamage);
                        
                        const pColor = hitType === "CRIT" ? 0xff0000 : 0x00ffff;
                        
                        spawnParticles(h.enemy.mesh.position, pColor, 15, 1.5);
                        spawnImpact(h.enemy.mesh.position, pColor, hitType === "CRIT" ? 3.0 : 1.5);
                        
                        if (hitType === "CRIT") {
                            const toCam = camera.position.clone().sub(h.enemy.mesh.position).normalize();
                            spawnRipple(h.enemy.mesh.position, toCam, pColor);
                        }
                    });
                    
                    AudioSys.playHit();
                    comboTimer = 3.0; 
                    updateComboUI();

                    if(slashMesh) {
                        slashMesh.material.color.setHex(hitType === "CRIT" ? 0xff0000 : 0xffffff); 
                        slashMesh.material.opacity = 1; 
                        slashMesh.scale.setScalar(1.2); 
                        slashMesh.userData.fadeSpeed = 0.06; 
                        slashMesh.userData.isHit = true; 
                    }
                }
            }
        }

        function createGridTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            if (type === 'solid') {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, 1024, 1024);
            } else if (type === 'snow') {
                ctx.fillStyle = '#ffffff'; 
                ctx.fillRect(0,0,1024,1024);
                ctx.strokeStyle = 'rgba(200, 220, 255, 0.2)'; 
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let i=0; i<=1024; i+=128) {
                    ctx.moveTo(i,0); ctx.lineTo(i,1024);
                    ctx.moveTo(0,i); ctx.lineTo(1024,i);
                }
                ctx.stroke();
            } else if (type === 'neon') {
                ctx.fillStyle = '#000000'; 
                ctx.fillRect(0,0,1024,1024);
                ctx.strokeStyle = '#00ffff'; 
                ctx.lineWidth = 2;
                ctx.shadowBlur = 4;
                ctx.shadowColor = '#00ffff';
                ctx.beginPath();
                for(let i=0; i<=1024; i+=128) {
                    ctx.moveTo(i,0); ctx.lineTo(i,1024);
                    ctx.moveTo(0,i); ctx.lineTo(1024,i);
                }
                ctx.stroke();
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.beginPath();
                for(let i=0; i<=1024; i+=32) {
                    if(i % 128 === 0) continue;
                    ctx.moveTo(i,0); ctx.lineTo(i,1024);
                    ctx.moveTo(0,i); ctx.lineTo(1024,i);
                }
                ctx.stroke();
            } else {
                ctx.fillStyle = '#050505';
                ctx.fillRect(0, 0, 1024, 1024);
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 4;
                ctx.beginPath();
                for(let i=0; i<=1024; i+=128) {
                    ctx.moveTo(i,0); ctx.lineTo(i,1024);
                    ctx.moveTo(0,i); ctx.lineTo(1024,i);
                }
                ctx.stroke();
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.beginPath();
                for(let i=0; i<=1024; i+=32) {
                    if(i % 128 === 0) continue;
                    ctx.moveTo(i,0); ctx.lineTo(i,1024);
                    ctx.moveTo(0,i); ctx.lineTo(1024,i);
                }
                ctx.stroke();
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.minFilter = THREE.LinearMipMapLinearFilter;
            tex.anisotropy = 16;
            return tex;
        }

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.4, 'rgba(255,255,255,0.5)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,64,64);
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        function init() {
            lastUnlockTime = performance.now() - 5000;

            const btn = document.getElementById('start-btn');
            btn.addEventListener('click', () => {
                AudioSys.init(); 
                const now = performance.now();
                if (now - lastUnlockTime < 1300) {
                    btn.innerText = "b r e a t h e";
                    btn.style.opacity = 0.5;
                    btn.style.letterSpacing = "8px";
                    setTimeout(() => {
                        btn.innerText = "ENTER ARENA";
                        btn.style.opacity = 1;
                        btn.style.letterSpacing = "2px";
                    }, 800);
                    return;
                }
                sessionStartTime = Date.now();
                document.body.requestPointerLock().catch(e => {
                    console.warn("Pointer lock failed:", e);
                });
            });
            document.getElementById('theme-btn').addEventListener('click', toggleTheme);
            document.getElementById('tp-mode-btn').addEventListener('click', toggleTeleportMode);
            document.getElementById('fps-btn').addEventListener('click', () => {
                showFPS = !showFPS;
                document.getElementById('fps-btn').innerText = "SHOW FPS: " + (showFPS ? "ON" : "OFF");
                const disp = document.getElementById('fps-display');
                disp.style.display = showFPS ? "block" : "none";
            });
            document.getElementById('world-btn').addEventListener('click', () => {
                const next = WorldManager.current.name === 'ARENA' ? 'TITAN' : 'ARENA';
                WorldManager.switch(next);
            });

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ'; 
            camera.position.set(0, 2, 0);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            textures.gridDefault = createGridTexture('default');
            textures.gridSnow = createGridTexture('snow');
            textures.gridNeon = createGridTexture('neon');
            textures.solid = createGridTexture('solid');
            textures.glow = createGlowTexture();
            
            sharedSnowGeo = new THREE.PlaneGeometry(0.1, 0.1);
            sharedLeafGeo = new THREE.PlaneGeometry(0.3, 0.3); 

            // Initialize Materials
            materials.floor = new THREE.MeshPhysicalMaterial({ 
                map: textures.gridDefault, 
                color: 0xffffff, 
                roughness: 0.5, 
                metalness: 0.1,
                transparent: true, // Enable translucency
                opacity: 0.90      // Subtle 10% transparency
            });
            materials.wall = new THREE.MeshPhysicalMaterial({ 
                color: 0xeeeeee, 
                roughness: 0.1, 
                metalness: 0.1,
                transparent: true, // Allows translucency
                opacity: 0.6,      // Sets the "glass" thickness/visibility
                transmission: 0.25, // Adds a realistic glass-like light pass-through
                thickness: 0.5,     // Simulates depth in the glass
                emissive: 0xffffff,       // The color of the faint glow
                emissiveIntensity: 1   // Adjusted for a noticeable but faint glow
            });
            materials.obstacle = new THREE.MeshPhysicalMaterial({ 
                color: 0xcccccc, roughness: 0.3, clearcoat: 0.5, clearcoatRoughness: 0.1
            });
            materials.slash = new THREE.MeshBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0, side: THREE.DoubleSide, depthTest: false });
            materials.marker = new THREE.MeshStandardMaterial({ 
                color: 0x0088ff, emissive: 0x0088ff, emissiveIntensity: 2.0, transparent: true, opacity: 0.9, roughness: 0.2, metalness: 0.8, wireframe: true 
            });
            materials.markerCore = new THREE.MeshBasicMaterial({
                color: 0x0088ff, transparent: true, opacity: 0.3, blending: THREE.AdditiveBlending
            });

            setupLighting();
            
            // Build Worlds & Load Normal Map
            WorldManager.init();
            WorldManager.switch('ARENA');
            
            createSlashEffect(); 
            createTeleportMarker();
            InputManager.init();
            player.init();
            renderStatsContent();

            window.addEventListener('resize', onWindowResize);
            
            document.addEventListener('pointerlockchange', () => {
                isLocked = document.pointerLockElement === document.body;
                const screen = document.getElementById('start-screen');
                
                if (isLocked) {
                    screen.style.display = 'none';
                    if (breakStartTime > 0) {
                        totalBreakTime += (performance.now() - breakStartTime);
                        if (bankedActiveTime > 0) breakCount++;
                        breakStartTime = 0;
                    }
                    segmentStartTime = performance.now();
                    if(player.isDead) resetGame();
                } else {
                    lastUnlockTime = performance.now();
                    screen.style.display = 'flex';
                    AudioSys.stopAll();
                    if (segmentStartTime > 0) {
                        lastSegmentDuration = performance.now() - segmentStartTime;
                        bankedActiveTime += lastSegmentDuration;
                        segmentStartTime = 0;
                    }
                    breakStartTime = performance.now();
                    updatePauseScreenStats();
                    InputManager.mouseDown = false; 
                }
            });
            
            document.addEventListener('pointerlockerror', (e) => {
                console.warn("Pointer lock error detected.", e);
                if(!isLocked) {
                    document.getElementById('start-screen').style.display = 'flex';
                }
            });

            applyTheme();
            animate();
        }

        function generatePlayerTitle() {
            const m = GameStats.moves;
            const c = GameStats.highestCombo;
            const totalStyle = m.slideHit + m.midAirHit + m.teleportHit + m.wallJumpHit + m.longAirHit;
            
            let archetype = "HYBRID";
            let maxStat = 0;
            if (m.slideHit > maxStat) { maxStat = m.slideHit; archetype = "SLIDER"; }
            if (m.midAirHit + m.longAirHit > maxStat) { maxStat = m.midAirHit + m.longAirHit; archetype = "AVIATOR"; }
            if (m.wallJumpHit > maxStat) { maxStat = m.wallJumpHit; archetype = "TRACEUR"; }
            if (m.teleportHit > maxStat) { maxStat = m.teleportHit; archetype = "SHIFTER"; }
            if (totalStyle > 0 && maxStat / totalStyle < 0.4) archetype = "HYBRID";

            const prestigeScore = totalStyle + (GameStats.botKills * 10);
            let rankIndex = Math.floor(prestigeScore / 50); 
            if (rankIndex > 9) rankIndex = 9;
            const styleTitle = STYLE_ARCHETYPES[archetype][rankIndex] || "NOVICE";

            let comboTitle = "";
            for (let i = COMBO_TITLES_MATRIX.length - 1; i >= 0; i--) {
                if (c >= COMBO_TITLES_MATRIX[i].c) {
                    comboTitle = COMBO_TITLES_MATRIX[i].t;
                    break;
                }
            }
            return (comboTitle ? comboTitle + " " : "") + styleTitle;
        }

        function renderStatsContent() {
            const rawList = GameStats.persistentAchievements;
            const filteredList = [];
            const typeCounts = {};
            const getAchType = (name) => name.replace(/ (NOVICE|APPRENTICE|ADEPT|EXPERT|MASTER|GRANDMASTER|LEGEND|DEMIGOD|GODLIKE|OMNIPOTENT)$/, '');

            for(let i = rawList.length - 1; i >= 0; i--) {
                const name = rawList[i];
                const type = getAchType(name);
                if (type !== name) { 
                    if (!typeCounts[type]) typeCounts[type] = 0;
                    if (typeCounts[type] < 3) { filteredList.push(name); typeCounts[type]++; }
                } else { filteredList.push(name); }
            }
            filteredList.reverse();

            let achHtml = "";
            if (filteredList.length > 0) {
                achHtml = `<div class="achievement-list">` + 
                    filteredList.map(a => `<span class="achievement-tag">${a}</span>`).join('') + 
                    `</div>`;
            }

            const statSession = document.getElementById('stat-session');
            if (statSession) {
                statSession.innerHTML = `
                    <div style="flex: 0 0 auto; margin-bottom: 2px;">
                        <strong>SCORE:</strong> ${player.score}<br>
                        <strong>MAX COMBO:</strong> ${GameStats.highestCombo}
                    </div>
                    <div style="flex: 0 0 auto; margin-bottom: 2px;"><strong>ACHIEVEMENTS:</strong></div>
                    ${achHtml}
                `;
            }

            const statMoves = document.getElementById('stat-moves');
            if (statMoves) {
                let movesHtml = `<strong>KILLS:</strong> ${GameStats.botKills}<br>`;
                if(GameStats.moves.slideHit > 0) movesHtml += `Slide Strikes: ${GameStats.moves.slideHit}<br>`;
                if(GameStats.moves.midAirHit > 0) movesHtml += `Aerial Strikes: ${GameStats.moves.midAirHit}<br>`;
                if(GameStats.moves.longAirHit > 0) movesHtml += `Long Air Strikes: ${GameStats.moves.longAirHit}<br>`;
                if(GameStats.moves.teleportHit > 0) movesHtml += `Teleport Strikes: ${GameStats.moves.teleportHit}<br>`;
                if(GameStats.moves.wallJumpHit > 0) movesHtml += `Wall Jump Strikes: ${GameStats.moves.wallJumpHit}<br>`;
                if(movesHtml === `<strong>KILLS:</strong> ${GameStats.botKills}<br>`) movesHtml += "";
                statMoves.innerHTML = movesHtml;
            }
        }

        function updatePauseScreenStats() {
            const h1 = document.getElementById('game-title');
            const timerDisplay = document.getElementById('session-timer');
            const playerTitleDisplay = document.getElementById('player-title-display');
            
            if(player.isDead) {
                let termStatus = "DISCONNECTED";
                let color = "#ff3333";
                for(let i=SCORE_STEPS.length-1; i>=0; i--) {
                    if (player.score >= SCORE_STEPS[i]) { termStatus = SCORE_TITLES[i]; break; }
                }
                if (player.score > 850000) color = "#aa00ff";
                else if (player.score > 250000) color = "#00ffff";
                else if (player.score > 50000) color = "#ffff00";
                else if (player.score > 10000) color = "#ff8800";
                
                h1.innerText = termStatus;
                h1.style.color = color;
                h1.style.textShadow = `4px 4px 0px ${color}44`;
                
                playerTitleDisplay.innerText = generatePlayerTitle();
                playerTitleDisplay.style.display = "block";
                timerDisplay.style.display = "block";
            } else {
                h1.innerText = "PAUSED";
                h1.style.color = "#33ccff";
                h1.style.textShadow = "4px 4px 0px #33ccff";
                playerTitleDisplay.style.display = "none";
                timerDisplay.style.display = "block";
            }

            const format = (ms) => {
                const totalSec = Math.floor(ms / 1000);
                const s = (totalSec % 60).toString().padStart(2, '0');
                const totalMin = Math.floor(totalSec / 60);
                const m = (totalMin % 60).toString().padStart(2, '0');
                const totalHour = Math.floor(totalMin / 60);
                const h = (totalHour % 24).toString().padStart(2, '0');
                const d = Math.floor(totalHour / 24);

                if (d > 0) return `${d}:${h}:${m}:${s}`;
                if (totalHour > 0) return `${h}:${m}:${s}`;
                return `${m}:${s}`;
            };

            const primaryLabel = player.isDead ? "Playtime" : "Current Session";
            const primaryValue = player.isDead ? bankedActiveTime : lastSegmentDuration;
            const hoverLabel = player.isDead ? "Final Session" : "Playtime";
            const hoverValue = player.isDead ? lastSegmentDuration : bankedActiveTime;

            timerDisplay.innerHTML = `<strong>${primaryLabel}:</strong> ${format(primaryValue)}`;
            
            const tooltip = 
                `${hoverLabel}: ${format(hoverValue)}\n` +
                `Idle: ${format(totalBreakTime)}\n` +
                `Breaks: ${breakCount}`;
            
            timerDisplay.setAttribute('data-details', tooltip);
            timerDisplay.classList.add('session-info');
            renderStatsContent(); 
        }

        let ambientLight, hemiLight, dirLight;

        function setupLighting() {
            ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 50, 0);
            scene.add(hemiLight);
            
            dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(80, 120, 80);
            dirLight.castShadow = true;
            dirLight.shadow.bias = -0.0001;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.left = -200;
            dirLight.shadow.camera.right = 200;
            dirLight.shadow.camera.top = 200;
            dirLight.shadow.camera.bottom = -200;
            scene.add(dirLight);
        }

        function toggleTheme() {
            currentTheme = (currentTheme + 1) % 4;
            applyTheme();
        }

        function toggleTeleportMode() {
            if (teleportMode === 'AIM') {
                teleportMode = 'INSTANT';
                player.tpAimStartTime = 0;
            } else {
                teleportMode = 'AIM';
            }
            document.getElementById('tp-mode-btn').innerText = "TP MODE: " + teleportMode;
            document.getElementById('tp-label').innerText = teleportMode;
        }

        function applyTheme() {
            const body = document.body;
            const ui = document.getElementById('ui-layer');
            const crosshair = document.getElementById('crosshair');
            const names = ["LIGHT", "DARK", "NEON", "HALLOWEEN"];
            
            document.getElementById('theme-btn').innerText = "THEME: " + names[currentTheme];
            document.getElementById('mode-display').innerText = names[currentTheme] + " | 'T' TO CYCLE";

            materials.floor.roughness = 0.5;
            materials.floor.metalness = 0.1;
            materials.floor.emissiveIntensity = 0;
            materials.floor.emissiveMap = null;
            materials.wall.emissiveIntensity = 0;
            materials.wall.emissiveMap = null;

            if (currentTheme === 0) { // LIGHT (SNOW)
                const bgCol = 0x667788; 
                scene.background = new THREE.Color(bgCol);
                // Respect World Fog Density
                scene.fog = new THREE.FogExp2(bgCol, WorldManager.current ? WorldManager.current.config.fog : 0.004); 
                body.style.backgroundColor = "#667788";
                ui.classList.add('light-theme');
                
                materials.floor.map = textures.gridSnow;
                // Adjust UVs based on world scale? For now stick to generic
                materials.floor.map.repeat.set(100, 100); 
                materials.floor.color.setHex(0x556677); 
                materials.floor.roughness = 0.9;
                materials.wall.color.setHex(0xdddddd);
                materials.wall.roughness = 0.5;
                
                currentSlashColor = 0x0088ff;
                materials.marker.color.setHex(0x003366); 
                crosshair.style.color = "#0088ff";
                
                ambientLight.intensity = 0.6; 
                hemiLight.intensity = 0.6;
                dirLight.intensity = 0.8; 
                dirLight.color.setHex(0xffffff);

            } else {
                ui.classList.remove('light-theme');
                
                if (currentTheme === 1) { // DARK
                    const bgCol = 0x20242a; 
                    scene.background = new THREE.Color(bgCol);
                    scene.fog = new THREE.FogExp2(bgCol, WorldManager.current ? WorldManager.current.config.fog : 0.007);
                    body.style.backgroundColor = "#20242a";
                    
                    materials.floor.map = textures.solid;
                    materials.floor.color.setHex(0x1a1e26); 
                    materials.floor.roughness = 0.4; 
                    materials.floor.metalness = 0.1;
                    
                    materials.wall.color.setHex(0x3b4252); 
                    materials.wall.roughness = 1.0;
                    materials.wall.metalness = 0.0;
                    
                    currentSlashColor = 0xffaa00; 
                    materials.marker.color.setHex(0xff8800);
                    crosshair.style.color = "#ffaa00";
                    
                    ambientLight.intensity = 2.2; 
                    hemiLight.intensity = 1.2;
                    dirLight.intensity = 1.5;
                    dirLight.color.setHex(0xddddff); 

                } else if (currentTheme === 2) { // NEON
                    const bgCol = 0x050505;
                    scene.background = new THREE.Color(bgCol);
                    scene.fog = new THREE.FogExp2(bgCol, WorldManager.current ? WorldManager.current.config.fog : 0.007);
                    body.style.backgroundColor = "#050505";
                    
                    materials.floor.map = textures.gridDefault;
                    materials.floor.map.repeat.set(100, 100);
                    materials.floor.color.setHex(0x444444);
                    materials.floor.roughness = 0.5; 
                    
                    materials.wall.color.setHex(0x001122); 
                    
                    currentSlashColor = 0x00ffff; 
                    materials.marker.color.setHex(0x00ffff);
                    crosshair.style.color = "#00ffff";
                    
                    ambientLight.intensity = 1.2;
                    hemiLight.intensity = 0.8;
                    dirLight.intensity = 1.2;
                    dirLight.color.setHex(0x00ffff);

                } else { // HALLOWEEN
                    const bgCol = 0x663311;
                    scene.background = new THREE.Color(bgCol); 
                    scene.fog = new THREE.FogExp2(bgCol, WorldManager.current ? WorldManager.current.config.fog : 0.004);
                    body.style.backgroundColor = "#663311";
                    
                    materials.floor.map = textures.solid;
                    materials.floor.color.setHex(0x3d1f00); 
                    materials.floor.roughness = 0.4; 
                    materials.floor.metalness = 0.1;
                    
                    materials.wall.color.setHex(0x7a3e00); 
                    materials.wall.roughness = 1.0;
                    
                    currentSlashColor = 0xff8800; 
                    materials.marker.color.setHex(0xff4400);
                    crosshair.style.color = "#ff8800";
                    
                    ambientLight.intensity = 2.0; 
                    hemiLight.intensity = 1.2;
                    dirLight.intensity = 1.5;
                    dirLight.color.setHex(0xffaa00);
                }
            }
            
            if(materials.slash) materials.slash.color.setHex(currentSlashColor);
            
            decorations.forEach(d => d.updateTheme(currentTheme));
            enemies.forEach(e => e.updateTheme(currentTheme));
        }

        const GIFT_PALETTES = [
            { box: 0xcc0000, ribbon: 0xffd700 }, 
            { box: 0x006400, ribbon: 0xcc0000 }, 
            { box: 0x0044aa, ribbon: 0xc0c0c0 }, 
            { box: 0xffffff, ribbon: 0xcc0000 }, 
            { box: 0x663399, ribbon: 0xffd700 }  
        ];
        const WARM_PALETTES = [0x8B4513, 0xA0522D, 0xCD853F, 0xD2691E, 0xBC8F8F];

        class Decoration {
            constructor(x, z, scale, ws = null) {
                this.scale = scale;
                const size = 2;
                this.palette = GIFT_PALETTES[Math.floor(Math.random() * GIFT_PALETTES.length)];
                this.warmColor = WARM_PALETTES[Math.floor(Math.random() * WARM_PALETTES.length)];

                const colliderGeo = new THREE.BoxGeometry(size, size, size);
                const colliderMat = new THREE.MeshBasicMaterial({ visible: false });
                this.colliderMesh = new THREE.Mesh(colliderGeo, colliderMat);
                this.colliderMesh.position.set(x, scale, z);
                this.colliderMesh.scale.setScalar(scale);
                this.colliderMesh.geometry.computeBoundingBox();
                
                if (ws) {
                    ws.walls.push(this.colliderMesh);
                    ws.group.add(this.colliderMesh);
                } else {
                    walls.push(this.colliderMesh);
                    scene.add(this.colliderMesh);
                }
                
                this.colliderMesh.updateMatrixWorld(true);
                const box = this.colliderMesh.geometry.boundingBox.clone();
                box.applyMatrix4(this.colliderMesh.matrixWorld);
                if (ws) ws.spatialGrid.insert(this.colliderMesh, box);
                else spatialGrid.insert(this.colliderMesh, box);

                const visualGeo = new THREE.BoxGeometry(size, size, size);
                this.mat = materials.obstacle.clone();
                this.visualMesh = new THREE.Mesh(visualGeo, this.mat);
                
                // Shadow Optimization for Decorations
                if (ws && ws.config.bots > 100) {
                    this.visualMesh.castShadow = false;
                } else {
                    this.visualMesh.castShadow = true;
                }
                
                this.visualMesh.receiveShadow = true;
                this.visualMesh.position.copy(this.colliderMesh.position);
                this.visualMesh.scale.setScalar(scale);
                
                this.visualMesh.updateMatrixWorld();
                if (ws) {
                    ws.worldObjects.push(this.visualMesh);
                    ws.groundObjects.push(this.visualMesh);
                    ws.decorations.push(this);
                    ws.group.add(this.visualMesh);
                } else {
                    worldObjects.push(this.visualMesh);
                    groundObjects.push(this.visualMesh);
                    decorations.push(this);
                    scene.add(this.visualMesh);
                }
                
                const edges = new THREE.EdgesGeometry(visualGeo);
                this.edges = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 }));
                this.visualMesh.add(this.edges);

                this.faceGroup = new THREE.Group();
                const faceMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                const eyeGeo = new THREE.ConeGeometry(0.3, 0.1, 3);
                const eyeL = new THREE.Mesh(eyeGeo, faceMat);
                eyeL.position.set(-0.5, 0.2, 1.01); 
                eyeL.rotation.x = -Math.PI/2; eyeL.rotation.z = Math.PI;
                const eyeR = new THREE.Mesh(eyeGeo, faceMat);
                eyeR.position.set(0.5, 0.2, 1.01);
                eyeR.rotation.x = -Math.PI/2; eyeR.rotation.z = Math.PI;
                const mouthGeo = new THREE.BoxGeometry(1.2, 0.3, 0.1);
                const mouth = new THREE.Mesh(mouthGeo, faceMat);
                mouth.position.set(0, -0.5, 1.01);
                this.faceGroup.add(eyeL); this.faceGroup.add(eyeR); this.faceGroup.add(mouth);
                const stemGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 6);
                const stemMat = new THREE.MeshBasicMaterial({ color: 0x006400 });
                this.stem = new THREE.Mesh(stemGeo, stemMat);
                this.stem.position.set(0, 1.2, 0);
                this.faceGroup.add(this.stem);
                this.visualMesh.add(this.faceGroup);

                this.ribbonGroup = new THREE.Group();
                this.ribbonMat = new THREE.MeshBasicMaterial({ color: this.palette.ribbon });
                const r1Geo = new THREE.BoxGeometry(2.05, 2.05, 0.4); 
                const r1 = new THREE.Mesh(r1Geo, this.ribbonMat);
                const r2Geo = new THREE.BoxGeometry(0.4, 2.05, 2.05); 
                const r2 = new THREE.Mesh(r2Geo, this.ribbonMat);
                const bowGeo = new THREE.SphereGeometry(0.4, 8, 8);
                const bow = new THREE.Mesh(bowGeo, this.ribbonMat);
                bow.position.y = 1.025; 
                this.ribbonGroup.add(r1); this.ribbonGroup.add(r2); this.ribbonGroup.add(bow);
                this.ribbonGroup.visible = false;
                this.visualMesh.add(this.ribbonGroup);
            }

            updateTheme(t) {
                this.mat.color.setHex(0xcccccc);
                this.mat.emissive.setHex(0x000000);
                this.mat.wireframe = false;
                this.faceGroup.visible = false;
                this.ribbonGroup.visible = false;
                this.edges.visible = true;
                this.edges.material.opacity = 0.1;
                this.edges.material.color.setHex(0xffffff);
                this.edges.material.linewidth = 1;
                this.visualMesh.rotation.y = 0; 

                if (t === 3) { // Halloween
                    const r = 0.9 + Math.random()*0.1; 
                    const g = 0.05 + Math.random()*0.15; 
                    this.mat.color.setRGB(r, g, 0); 
                    this.mat.emissive = new THREE.Color(r*0.1, g*0.1, 0);
                    this.faceGroup.visible = true;
                    this.edges.visible = false;
                    this.faceGroup.rotation.y = (Math.PI / 2) * Math.floor(Math.random() * 4);
                } else if (t === 0) { // Light
                    this.mat.color.setHex(this.palette.box);
                    this.ribbonMat.color.setHex(this.palette.ribbon);
                    this.ribbonGroup.visible = true;
                    this.edges.material.color.setHex(0x000000);
                } else {
                    if(t === 1) { 
                         this.mat.color.setHex(this.warmColor);
                         this.mat.emissive.setHex(0x000000);
                         this.edges.visible = false; 
                    }
                    if(t === 2) { 
                         this.mat.color.setHex(0x001122); 
                         this.edges.material.color.setHex(0x00ffff); 
                         this.edges.material.opacity = 0.5; 
                    }
                }
            }
        }

        function updateWeather(dt) {
            const isHalloween = currentTheme === 3;
            const isSnow = currentTheme === 0;

            if (!isHalloween && !isSnow && weatherParticles.length === 0) return;

            if ((!isSnow && weatherParticles.some(p => p.type === 'snow')) || 
                (!isHalloween && weatherParticles.some(p => p.type === 'leaf'))) {
                 weatherParticles.forEach(l => scene.remove(l.mesh));
                 weatherParticles.length = 0;
                 if (!isHalloween && !isSnow) return;
            }
            
            windTimer += dt;
            if (windTimer > 8.0 && !windActive) {
                windActive = true;
                windTarget.set((Math.random()-0.5)*25, 5 + Math.random()*5, (Math.random()-0.5)*25); 
            }
            if (windTimer > 12.0 && windActive) {
                windActive = false;
                windTarget.set(0,0,0);
                windTimer = 0;
            }
            currentWind.lerp(windTarget, dt * 1.0); 

            const limit = isSnow ? 600 : 80;
            const spawnRate = isSnow ? 0.8 : 0.1;

            if(weatherParticles.length < limit && Math.random() < spawnRate) {
                let mesh, vel, type;
                const px = camera.position.x + (Math.random()-0.5)*50;
                const pz = camera.position.z + (Math.random()-0.5)*50;

                if (isSnow) {
                    const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
                    mesh = new THREE.Mesh(sharedSnowGeo, mat);
                    mesh.position.set(px, 30, pz);
                    mesh.lookAt(camera.position); 
                    vel = new THREE.Vector3((Math.random()-0.5)*2, -4 - Math.random()*4, (Math.random()-0.5)*2);
                    type = 'snow';
                } else {
                    const mat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xffaa00 : 0x884400, side: THREE.DoubleSide });
                    mesh = new THREE.Mesh(sharedLeafGeo, mat);
                    mesh.position.set(px, 30, pz);
                    mesh.rotation.set(Math.random(), Math.random(), Math.random());
                    vel = new THREE.Vector3((Math.random()-0.5)*3, -3 - Math.random()*3, (Math.random()-0.5)*3);
                    type = 'leaf';
                }

                scene.add(mesh);
                weatherParticles.push({ mesh: mesh, vel: vel, type: type, swayOffset: Math.random() * 100, landed: false, landTimer: 2.0 });
            }

            for(let i=weatherParticles.length-1; i>=0; i--) {
                const l = weatherParticles[i];

                if (l.landed) {
                    l.landTimer -= dt;
                    l.mesh.material.opacity = (l.landTimer / 2.0) * 0.8;
                    if (l.landTimer <= 0) {
                        scene.remove(l.mesh);
                        l.mesh.material.dispose();
                        weatherParticles.splice(i, 1);
                    }
                    continue; 
                }
                
                if (l.type === 'leaf' || l.type === 'snow') {
                    l.mesh.position.addScaledVector(currentWind, dt);
                    if(currentWind.lengthSq() > 1) {
                         if (l.type === 'leaf') {
                             l.mesh.rotation.z += dt * 5;
                             l.mesh.rotation.x += dt * 5;
                         } else {
                             l.mesh.position.x += (Math.random()-0.5) * dt * 5;
                         }
                    }
                }

                l.mesh.position.addScaledVector(l.vel, dt);
                
                if (l.type === 'leaf') {
                    l.mesh.rotation.x += dt * 2;
                    l.mesh.rotation.y += dt;
                    l.mesh.position.x += Math.sin(performance.now() * 0.002 + l.swayOffset) * dt * 2;
                } else {
                    l.mesh.position.x += Math.sin(performance.now() * 0.001 + l.swayOffset) * dt * 0.5;
                    l.mesh.rotation.z += dt; 
                }

                if(l.mesh.position.y <= 0) {
                    if (l.type === 'snow') {
                        l.landed = true;
                        l.mesh.position.y = 0.05; 
                        l.mesh.rotation.x = -Math.PI / 2;
                        l.vel.set(0,0,0);
                    } else {
                        scene.remove(l.mesh);
                        l.mesh.material.dispose();
                        weatherParticles.splice(i, 1);
                    }
                }
            }
        }

        function spawnSnowTrail(pos) {
            const mat = new THREE.SpriteMaterial({ map: textures.glow, color: 0xffffff, transparent: true, opacity: 0.8 }); // Prominent snow
            const mesh = new THREE.Sprite(mat);
            mesh.scale.set(0.8, 0.8, 0.8);
            mesh.position.copy(pos);
            mesh.position.y = getGroundHeight(pos.x, pos.z) + 0.1;
            scene.add(mesh);
            particles.push({
                mesh: mesh,
                vel: new THREE.Vector3(0,0,0),
                life: 1.5, 
                isStatic: true
            });
        }

        function spawnSnowKickup(pos) {
            for(let i=0; i<3; i++) {
                const mat = new THREE.SpriteMaterial({ map: textures.glow, color: 0xffffff, transparent: true, opacity: 0.8 });
                const mesh = new THREE.Sprite(mat);
                mesh.scale.set(0.3, 0.3, 0.3);
                mesh.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5), 0.1, (Math.random()-0.5)));
                const vel = new THREE.Vector3(
                    (Math.random()-0.5) * 2, 
                    1 + Math.random() * 3, 
                    (Math.random()-0.5) * 2
                );
                scene.add(mesh);
                particles.push({ mesh: mesh, vel: vel, life: 0.5, isStatic: false });
            }
        }

        function createSlashEffect() {
            const shape = new THREE.Shape();
            shape.moveTo(0, 1.2);
            shape.quadraticCurveTo(-0.5, 0, 0, -1.2);
            shape.quadraticCurveTo(-0.2, 0, 0, 1.2);
            slashGeometry = new THREE.ShapeGeometry(shape);
            slashGeometry.center(); 
        }

        function spawnSlash(parent) {
            const mat = materials.slash.clone();
            mat.color.setHex(currentSlashColor);
            
            const mesh = new THREE.Mesh(slashGeometry, mat);
            mesh.material.transparent = true;
            mesh.material.opacity = 1;
            mesh.material.depthTest = false; 
            mesh.material.depthWrite = false;
            mesh.renderOrder = 999; 
            mesh.userData.fadeSpeed = 0.15; 
            mesh.userData.isHit = false;

            let mySlashID = -1;

            if(parent === camera) {
                mesh.position.set(0.05, 0.05, -2.0); 
                mesh.rotation.z = -Math.PI / 8; 
                camera.add(mesh);
                
                mySlashID = ++lastSlashID;
                slashActive = true;
                document.getElementById('crosshair').style.opacity = 0;
            } else {
                mesh.position.set(0, 1.5, 1.0);
                mesh.lookAt(camera.position);
                mesh.rotation.z = Math.PI / 2; 
                parent.add(mesh);
            }
            
            let progress = 0;
            function animateSlash() {
                progress += mesh.userData.fadeSpeed;
                if (progress < 1) {
                    mesh.material.opacity = 1 - progress;
                    requestAnimationFrame(animateSlash);
                } else {
                    mesh.visible = false;
                    if(parent === camera) {
                        camera.remove(mesh);
                        if(mySlashID === lastSlashID) {
                            slashActive = false;
                        }
                    }
                    else parent.remove(mesh);
                    mesh.geometry.dispose();
                    mesh.material.dispose();
                }
            }
            animateSlash();
            return mesh;
        }

        function spawnImpact(pos, color=0xffffff, scale=1.0) {
            const matCore = new THREE.SpriteMaterial({ map: textures.glow, color: 0xffffff, transparent: true, blending: THREE.AdditiveBlending });
            const core = new THREE.Sprite(matCore);
            core.position.copy(pos);
            core.scale.setScalar(scale);
            scene.add(core);
            particles.push({ mesh: core, life: 0.1, maxLife: 0.1, type: 'flash', scaleStart: scale, scaleEnd: scale * 0.5 });

            const matGlow = new THREE.SpriteMaterial({ map: textures.glow, color: color, transparent: true, blending: THREE.AdditiveBlending, opacity: 0.8 });
            const glow = new THREE.Sprite(matGlow);
            glow.position.copy(pos);
            glow.scale.setScalar(scale * 2);
            scene.add(glow);
            particles.push({ mesh: glow, life: 0.25, maxLife: 0.25, type: 'flash', scaleStart: scale * 2, scaleEnd: scale * 4 });
        }

        function spawnParticles(pos, col, count, speed=1.0) {
            for(let i=0; i<count; i++) {
                const mat = new THREE.SpriteMaterial({ 
                    map: textures.glow, 
                    color: col, 
                    transparent: true, 
                    blending: THREE.AdditiveBlending 
                });
                const m = new THREE.Sprite(mat);
                const s = 0.2 + Math.random() * 0.3;
                m.scale.set(s, s, s);
                m.position.copy(pos);
                scene.add(m);
                
                const vel = new THREE.Vector3(
                    (Math.random()-0.5), 
                    (Math.random()-0.5), 
                    (Math.random()-0.5)
                ).normalize().multiplyScalar((5 + Math.random() * 10) * speed);

                particles.push({
                    mesh: m, 
                    vel: vel,
                    life: 0.4 + Math.random() * 0.3,
                    type: 'spark',
                    gravity: 15
                });
            }
        }

        function spawnRipple(pos, normal, baseColor=0x00ffff) {
            const layers = 3;
            const colorObj = new THREE.Color(baseColor);
            
            for(let i=0; i<layers; i++) {
                let layerColor = colorObj.clone();
                if(i===1) layerColor.lerp(new THREE.Color(0xffffff), 0.6); 
                if(i===2) layerColor.lerp(new THREE.Color(0x000088), 0.4); 
                
                const geo = new THREE.RingGeometry(0.5, 0.8 + (i*0.1), 32); 
                const mat = new THREE.MeshBasicMaterial({ 
                    color: layerColor, transparent: true, opacity: 0.8, side: THREE.DoubleSide, depthWrite: false, blending: THREE.AdditiveBlending
                });
                
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos).addScaledVector(normal, 0.05 + (i * 0.2)); 
                mesh.lookAt(pos.clone().add(normal)); 
                
                scene.add(mesh);
                particles.push({
                    mesh: mesh, vel: new THREE.Vector3(0,0,0), life: 0.8, maxLife: 0.8, isStatic: false, type: 'ripple'
                });
            }
        }

        function spawnFirework(pos) {
            spawnParticles(pos, 0xffcc00, 30);
            spawnParticles(pos, 0x00ffff, 30);
            spawnParticles(pos, 0xff00ff, 30);
            AudioSys.playTeleport(); 
        }

        function createTeleportMarker() {
            if(teleportMarker) {
                scene.remove(teleportMarker);
            }
            teleportMarker = new THREE.Group();
            materials.marker.transparent = true;
            const diamondGroup = new THREE.Group();
            diamondGroup.position.y = 1.5;
            teleportMarker.add(diamondGroup);
            const geo = new THREE.OctahedronGeometry(0.8, 0);
            const diamond = new THREE.Mesh(geo, materials.marker);
            diamondGroup.add(diamond);
            const thickGeo = new THREE.OctahedronGeometry(0.805, 0);
            const thickDiamond = new THREE.Mesh(thickGeo, materials.marker);
            diamondGroup.add(thickDiamond);
            const ringGroup = new THREE.Group();
            ringGroup.position.y = 0.1;
            teleportMarker.add(ringGroup);
            const ringBaseGeo = new THREE.RingGeometry(0.8, 1.0, 32); 
            const ringMat = materials.marker.clone();
            ringMat.side = THREE.DoubleSide;
            const ring = new THREE.Mesh(ringBaseGeo, ringMat);
            ring.rotation.x = -Math.PI / 2;
            ringGroup.add(ring);
            const ring2 = new THREE.Mesh(ringBaseGeo, ringMat);
            ring2.rotation.x = -Math.PI / 2;
            ring2.scale.setScalar(1.01); 
            ringGroup.add(ring2);
            teleportMarker.userData = { diamond: diamondGroup, ring: ringGroup, ringMat: ringMat };
            teleportMarker.visible = false;
            scene.add(teleportMarker);
        }

        function getGroundHeight(x, z) {
            // OPTIMIZATION: Main Floor Fast Check
            let highestY = 0; 
            
            if (spatialGrid) {
                // FIX: Use dedicated _groundBox to avoid overwriting _box3_1 during recursion
                const queryBox = _groundBox; 
                queryBox.min.set(x - 0.5, -10, z - 0.5);
                queryBox.max.set(x + 0.5, 500, z + 0.5);
                
                // FIX: Pass _groundSet to avoid clearing the main physics querySet
                const candidates = spatialGrid.query(queryBox, _groundSet);
                
                if (candidates.size > 0) {
                    // FIX: Raise scan height to 1000 to clear Titan's massive skyscrapers
                    // FIX: Increase .far to 1200 so it actually reaches the floor
                    const rayOrigin = _groundVec1.set(x, 1000, z);
                    globalRaycaster.set(rayOrigin, _groundVec2.set(0, -1, 0));
                    globalRaycaster.far = 1200; 
                    
                    const candidateMeshes = [];
                    candidates.forEach(c => {
                        if (!c.mesh.userData.isFloor) candidateMeshes.push(c.mesh);
                    });

                    if (candidateMeshes.length > 0) {
                        const intersects = globalRaycaster.intersectObjects(candidateMeshes);
                        if (intersects.length > 0) {
                            highestY = intersects[0].point.y;
                        }
                    }
                }
            }
            return highestY;
        }
        
        function snapToFloor(pos) {
            const origin = pos.clone();
            origin.y += 1.0; 
            globalRaycaster.set(origin, new THREE.Vector3(0, -1, 0));
            globalRaycaster.far = 6.0; 
            const hits = globalRaycaster.intersectObjects(groundObjects);
            if(hits.length > 0) {
                pos.y = hits[0].point.y + 1.6;
            }
        }

        function getTeleportTarget() {
            globalRaycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            globalRaycaster.far = CONFIG.teleportRange;
            const intersects = globalRaycaster.intersectObjects(worldObjects);
            if (intersects.length > 0) {
                return { point: intersects[0].point, hit: true, normal: intersects[0].face.normal };
            } else {
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                return { point: camera.position.clone().addScaledVector(dir, CONFIG.teleportRange), hit: false, normal: null };
            }
        }

        function performJump() {
             player.velocity.y = CONFIG.jumpForce;
             if(player.isSliding) {
                  player.velocity.y = 15; 
                  const forward = new THREE.Vector3();
                  camera.getWorldDirection(forward);
                  forward.y=0; forward.normalize();
             }
             if(player.onGround) {
                 player.airTimeStart = performance.now();
                 spawnRipple(camera.position.clone().add(new THREE.Vector3(0,-1.5,0)), new THREE.Vector3(0,1,0), 0x00ffff);
             } else {
                 spawnRipple(camera.position.clone().add(new THREE.Vector3(0,-1.5,0)), new THREE.Vector3(0,1,0), 0x00ffaa);
             }
             player.onGround = false;
             player.lastJumpTime = performance.now(); 
             AudioSys.playJump();
        }
        
        function performWallJump() {
            if (performance.now() - player.lastWallJumpTime < 300) return false;
            globalRaycaster.far = 1.5;
            const dirs = [
                new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0),
                new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)
            ];
            let hitWall = false;
            let wallNormal = new THREE.Vector3(0,1,0); 
            for(let d of dirs) {
                d.applyQuaternion(camera.quaternion);
                globalRaycaster.set(camera.position, d);
                const intersects = globalRaycaster.intersectObjects(walls);
                if(intersects.length > 0) {
                    hitWall = true;
                    const force = Math.max(CONFIG.wallPushForce, (player.wallImpactVelocity || 0) * 0.9);
                    player.velocity.addScaledVector(d, -force);
                    if (intersects[0].face) wallNormal = intersects[0].face.normal;
                    spawnRipple(intersects[0].point, wallNormal, 0xffff00);
                    break;
                }
            }
            if (hitWall) {
                player.velocity.y = CONFIG.wallJumpForce;
                player.onGround = false;
                player.lastJumpTime = performance.now();
                player.lastWallJumpTime = performance.now(); 
                AudioSys.playWallJump();
                return true;
            }
            return false;
        }

        function tryAimTeleport() {
            if (player.teleportTarget) {
                const res = getTeleportTarget(); 
                executeTeleport(player.teleportTarget, res.normal);
                player.teleportActive = false; 
            }
        }

        function tryInstantTeleport() {
            const result = getTeleportTarget();
            executeTeleport(result.point, result.normal);
            document.getElementById('icon-q').classList.add('active');
            setTimeout(() => document.getElementById('icon-q').classList.remove('active'), 200);
        }

        function executeTeleport(target, normal) {
             if (player.energy < CONFIG.teleportCost) {
                 AudioSys.playMiss();
                 return;
             }
             player.energy -= CONFIG.teleportCost;
             const dest = target.clone();
             if (normal) {
                 dest.addScaledVector(normal, 0.8);
             }
             const groundHeight = getGroundHeight(dest.x, dest.z);
             if (dest.y < groundHeight + 1.6) {
                 dest.y = groundHeight + 1.601;
             }

             const tempBox = new THREE.Box3();
             const halfW = 0.3; 
             
             tempBox.min.set(dest.x - halfW, dest.y - 1.6, dest.z - halfW);
             tempBox.max.set(dest.x + halfW, dest.y + 0.2, dest.z + halfW);

             const collisions = spatialGrid.query(tempBox);
             
             for(const wall of collisions) {
                 if (wall.mesh.userData.isFloor) continue;
                 if (tempBox.intersectsBox(wall.box)) {
                     const overlapX = Math.min(tempBox.max.x - wall.box.min.x, wall.box.max.x - tempBox.min.x);
                     const overlapZ = Math.min(tempBox.max.z - wall.box.min.z, wall.box.max.z - tempBox.min.z);
                     const wallCenterX = (wall.box.min.x + wall.box.max.x) / 2;
                     const wallCenterZ = (wall.box.min.z + wall.box.max.z) / 2;
                     if (overlapX < overlapZ) {
                         const sign = (dest.x < wallCenterX) ? -1 : 1;
                         dest.x += (overlapX + 0.05) * sign; 
                     } else {
                         const sign = (dest.z < wallCenterZ) ? -1 : 1;
                         dest.z += (overlapZ + 0.05) * sign;
                     }
                     tempBox.min.set(dest.x - halfW, dest.y - 1.6, dest.z - halfW);
                     tempBox.max.set(dest.x + halfW, dest.y + 0.2, dest.z + halfW);
                 }
             }
             const startInAir = !player.onGround;
             const finalGround = getGroundHeight(dest.x, dest.z);
             const endInAir = (dest.y - (finalGround + 1.6)) > 0.5;

             player.lastTeleportWasAerial = startInAir || endInAir;
             player.hasPhaseStruck = false; 

             spawnParticles(camera.position, 0x00ffaa, 20); 
             camera.position.copy(dest);
             player.jumpsRemaining = 1; 
             player.onGround = false; 
             if(!startInAir) player.airTimeStart = performance.now();
             player.lastTeleportTime = performance.now(); 
             AudioSys.playTeleport();
             spawnParticles(dest, 0x00ffaa, 30);
        }

        function updateComboUI() {
            const el = document.getElementById('combo-display');
            const meme = document.getElementById('meme-overlay');
            let memeText = "";
            let isPattern = false;

            if (MEME_TRIGGERS[comboCount]) {
                memeText = MEME_TRIGGERS[comboCount];
                showKillMessage(memeText, "achievement", "#00ffff");
            } 
            if (comboCount >= 100) {
                const s = comboCount.toString();
                if (/^(\d)\1+$/.test(s)) isPattern = true;
                else if ("123456789".includes(s) || "987654321".includes(s)) isPattern = true;
            }
            if (memeText) {
                meme.innerText = memeText;
                meme.style.display = "block";
                setTimeout(() => meme.style.display = "none", 4000); 
            }

            if (isPattern) {
                el.classList.add('cyan-mode');
            } else if (comboCount !== 666 && comboCount !== 777) { 
                if (MEME_TRIGGERS[comboCount] && (comboCount === 666 || comboCount === 777)) {
                     el.classList.add('cyan-mode');
                } else {
                     el.classList.remove('cyan-mode');
                }
            }

            if(comboCount < 2) {
                el.style.display = 'none';
            } else {
                el.style.display = 'block';
                el.innerText = comboCount + " STRIKES";
                let fontSize = "1.5rem"; 
                let color = "#ffcc00";
                let opacity = "1";
                let blur = "none";
                let textShadow = "4px 4px 0px rgba(0,0,0,0.5)";
                
                if(comboCount >= 5) fontSize = "3rem"; 
                
                if (comboCount >= 10) {
                    if (comboCount % 10 === 0) {
                        fontSize = "4rem"; 
                        color = "#ff0000";
                        textShadow = "0 0 20px #ff0000, 4px 4px 0px rgba(0,0,0,0.8)";
                    } else {
                        fontSize = "3rem"; 
                        opacity = "0.8"; 
                        blur = "none"; 
                    }
                }
                
                if (comboCount % 100 === 0 && comboCount > 0) {
                    fontSize = "6rem"; 
                    color = "#ff00ff";
                    textShadow = "0 0 50px #ff00ff, 0 0 20px #fff";
                    blur = "none";
                    opacity = "1";
                    spawnFirework(camera.position.clone().add(new THREE.Vector3(0,0,-5)));
                    GameStats.addAchievement(comboCount + " STRIKES LEGEND", "#ff00ff", "PERSISTENT");
                }

                el.style.fontSize = fontSize;
                if(!el.classList.contains('cyan-mode')) {
                    el.style.color = color;
                    el.style.textShadow = textShadow;
                }
                el.style.opacity = opacity;
                el.style.filter = blur;
                el.style.transform = "translateX(-50%) scale(1.3) skewX(-15deg)";
                requestAnimationFrame(() => {
                     setTimeout(() => {
                         el.style.transform = "translateX(-50%) scale(1) skewX(-15deg)";
                     }, 50);
                });
            }
            if(comboCount > GameStats.highestCombo) GameStats.highestCombo = comboCount;
        }

        const BOT_TYPES = {
            NORMAL: { scale: 1, hp: 200, speedMod: 1, dmgRed: 1, skill: 1, name: "NORMAL", color: 0x2F4F4F, eye: 0xffffff },   
            BRUTE: { scale: 2, hp: 600, speedMod: 0.85, dmgRed: 1, skill: 2, name: "BRUTE", color: 0x191970, eye: 0xffff00 }, 
            TITAN: { scale: 3, hp: 1200, speedMod: 0.75, dmgRed: 1, skill: 2, name: "TITAN", color: 0x4B0082, eye: 0xff8c00 }, 
            COLOSSUS: { scale: 5, hp: 4000, speedMod: 0.6, dmgRed: 0.5, skill: 1, name: "COLOSSUS", color: 0x800000, eye: 0xff0000 } 
        };
        
        function getBotReactionTime(bot) {
            const hpPct = bot.health / bot.maxHealth;
            const base = 100 + (1 - hpPct) * 300; 
            const rand = Math.random() * 50;
            return base + rand;
        }

        class Enemy {
    constructor(posOverride = null, typeOverride = null, initialState = 'ROAM', aggroDelay = 0, ws = null) {
        this.mesh = new THREE.Group();
        this.id = Math.random();

        // --- 1. SPAWN LOGIC ---
        let spawnY = 0;

        if (posOverride) {
            this.mesh.position.copy(posOverride);
            this.mesh.position.x += (Math.random() - 0.5) * 2;
            this.mesh.position.z += (Math.random() - 0.5) * 2;
            spawnY = this.mesh.position.y;

            if (typeOverride) this.type = typeOverride;
            else this.type = BOT_TYPES.NORMAL;
        } else {
            let x, z;
            const usedDecorations = ws ? ws.decorations : decorations;
            const spawnRange = ws ? ws.config.size * 0.4 : 175;
            let validSpawn = false;

            if (Math.random() < 0.4 && usedDecorations.length > 0) {
                const dec = usedDecorations[Math.floor(Math.random() * usedDecorations.length)];
                const range = (dec.scale - 2) * 0.6;
                if (range > 2) {
                    x = dec.visualMesh.position.x + (Math.random() - 0.5) * 2 * range;
                    z = dec.visualMesh.position.z + (Math.random() - 0.5) * 2 * range;
                    validSpawn = true;
                }
            }

            if (!validSpawn) {
                do {
                    x = (Math.random() - 0.5) * (spawnRange * 2);
                    z = (Math.random() - 0.5) * (spawnRange * 2);
                } while (Math.abs(x) < 20 && Math.abs(z) < 20);
            }

            spawnY = getGroundHeight(x, z);

            let r = Math.random();
            let type = 'NORMAL';
            if (spawnY > 35) {
                if (r < 0.4) type = 'COLOSSUS'; else if (r < 0.9) type = 'TITAN'; else type = 'BRUTE';
            } else if (spawnY > 5) {
                if (r < 0.05) type = 'COLOSSUS'; else if (r < 0.4) type = 'TITAN'; else if (r < 0.8) type = 'BRUTE'; else type = 'NORMAL';
            } else {
                if (r < 0.01) type = 'COLOSSUS'; else if (r < 0.05) type = 'TITAN'; else if (r < 0.20) type = 'BRUTE'; else type = 'NORMAL';
            }
            this.type = BOT_TYPES[type];
            this.mesh.position.set(x, spawnY + this.type.scale, z);
        }

        // --- 2. MESH SETUP ---
        const bodyMat = new THREE.MeshPhysicalMaterial({
            color: this.type.color, metalness: 0.1, roughness: 0.2, clearcoat: 0.5
        });
        this.body = new THREE.Mesh(sharedEnemyGeo, bodyMat);

        if (ws && ws.config.bots > 100) this.body.castShadow = false;
        else this.body.castShadow = true;

        this.body.receiveShadow = true;
        this.mesh.add(this.body);

        this.outline = new THREE.LineSegments(sharedEnemyEdgeGeo, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 }));
        this.outline.scale.setScalar(1.02);
        this.mesh.add(this.outline);

        const eyeGeo = new THREE.SphereGeometry(0.1, 8, 8);
        this.eyeMat = new THREE.MeshBasicMaterial({ color: this.type.eye });
        this.eyeL = new THREE.Mesh(eyeGeo, this.eyeMat);
        this.eyeL.position.set(-0.2, 0.5, 0.5);
        this.eyeR = new THREE.Mesh(eyeGeo, this.eyeMat);
        this.eyeR.position.set(0.2, 0.5, 0.5);
        this.mesh.add(this.eyeL); this.mesh.add(this.eyeR);
        this.mesh.scale.setScalar(this.type.scale);

        this.healthBarGroup = new THREE.Group();
        const barGeo = new THREE.PlaneGeometry(1.2, 0.15);
        const barMat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
        this.healthBar = new THREE.Mesh(barGeo, barMat);
        this.healthBar.position.z = 0.01;
        this.healthBarGroup.add(this.healthBar);
        const bgGeo = new THREE.PlaneGeometry(1.3, 0.25);
        const bgMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
        const bg = new THREE.Mesh(bgGeo, bgMat);
        this.healthBarGroup.add(bg);
        const uiScale = 1 + (this.type.scale - 1) * 0.5;
        this.healthBarGroup.scale.setScalar(uiScale);
        this.healthBarGroup.visible = false;

        if (ws) {
            ws.enemies.push(this);
            ws.group.add(this.mesh);
            ws.group.add(this.healthBarGroup);
        } else {
            enemies.push(this);
            (currentWorldGroup || scene).add(this.mesh);
            (currentWorldGroup || scene).add(this.healthBarGroup);
        }

        // --- 3. STATS & STATE ---
        this.maxHealth = this.type.hp;
        this.health = this.maxHealth;
        this.velocity = new THREE.Vector3();
        this.jumps = 0;
        this.state = initialState;
        this.hasAggroed = initialState === 'AGGRO';
        this.reactionTimer = aggroDelay > 0 ? aggroDelay * 1000 : 0;

        this.targetPos = new THREE.Vector3();
        this.lastKnownPos = new THREE.Vector3();
        this.searchTimer = 0;
        this.pickRoamTarget();

        this.lastAttack = performance.now();
        this.actionTimer = 0;
        this.isSprinting = false;
        this.isSliding = false;
        this.isDeadCorpse = false;
        this.corpseTimer = 0;
        this.confusedTimer = 0;
        this.streak = 0;
        this.lastHitTime = 0;
        this.lastDamageTime = 0;
        this.isRegenerating = false;
        this.isRetreating = false;
        this.pendingRetreat = false;
        this.teleportTimer = 0;
        this.teleportDelay = 0;
        this.personalSpeedMod = 0.8 + Math.random() * 0.4;
        this.portalCooldown = 0;
        this.strafeDir = Math.random() < 0.5 ? 1 : -1;
        this.strafeTimer = 0;
        this.dodgeTimer = 0;
        this.dodgeReactionTimer = 0;
        this.ledgeTimer = 0;
        this.lastPos = new THREE.Vector2(this.mesh.position.x, this.mesh.position.z);
        this.stamina = 10;
        this.maxStamina = 10;
        this.staminaRegen = 3;
        this.visionTimer = Math.random() * 0.5;
        this.canSeePlayerCached = false;

        // Variables for LOD smoothing/logic
        this.targetRotation = this.mesh.rotation.y;
        this.lastGroundHeight = 0;
        this.groundCheckTimer = 0;
        this.currentMoveSpeed = 0;
        this.currentMoveDir = new THREE.Vector3();

        this.updateTheme(currentTheme);
    }

    setHighlight(active) {
        if (active) {
            this.body.material.emissive.setHex(0xff0000);
            this.body.material.emissiveIntensity = 1.0;
            this.outline.material.color.setHex(0xffffff);
            this.outline.material.opacity = 0.8;
        } else {
            this.updateTheme(currentTheme);
            this.outline.scale.setScalar(1.02);
        }
    }

    updateTheme(t) {
        if (t === 2) {
            this.outline.material.color.setHex(0x00ffff);
            this.outline.material.opacity = 0.8;
            this.body.material.color.setHex(0x000000);
            this.body.material.emissive.setHex(0x000000);
            this.body.material.emissiveIntensity = 0;
        } else {
            this.outline.material.color.setHex(0xffffff);
            this.outline.material.opacity = 0.3;
            this.body.material.color.setHex(this.type.color);
            this.body.material.emissiveIntensity = 0;
        }
    }

    pickRoamTarget() {
        const myGround = getGroundHeight(this.mesh.position.x, this.mesh.position.z);
        if (myGround > 2) {
            for (let i = 0; i < 10; i++) {
                const tx = this.mesh.position.x + (Math.random() - 0.5) * 60;
                const tz = this.mesh.position.z + (Math.random() - 0.5) * 60;
                if (Math.abs(tx) > 150 || Math.abs(tz) > 150) continue;
                const tGround = getGroundHeight(tx, tz);
                if (Math.abs(tGround - myGround) < 1.0) {
                    this.targetPos.set(tx, this.mesh.position.y, tz);
                    return;
                }
            }
        }
        const roamRange = WorldManager.current ? WorldManager.current.config.size * 0.3 : 150;
        this.targetPos.set(
            (Math.random() - 0.5) * roamRange,
            this.mesh.position.y,
            (Math.random() - 0.5) * roamRange
        );
    }

    canSeePlayer(playerPos) {
        if (this.isDeadCorpse || this.state === 'CONFUSED') return false;
        return this.canSeePlayerCached;
    }

    checkVision(playerPos) {
        if (this.isDeadCorpse || this.state === 'CONFUSED') return false;
        if (this.mesh.position.distanceTo(playerPos) > 60) return false;
        _vec3_3.copy(this.mesh.position).add(new THREE.Vector3(0, 0.5, 0));
        const distToPlayer = _vec3_3.distanceTo(playerPos);
        _vec3_1.subVectors(playerPos, _vec3_3).normalize();
        globalRaycaster.set(_vec3_3, _vec3_1);
        globalRaycaster.far = 60;
        const hits = globalRaycaster.intersectObjects(walls);
        if (hits.length > 0 && hits[0].distance < distToPlayer) {
            return false;
        }
        return true;
    }

   // --- 4. LOD CONTROLLER ---
    update(dt, playerPos) {
        // Calculate distance ONCE for both Visuals and Physics
        const distSq = this.mesh.position.distanceToSquared(camera.position);
        
        // --- VISUAL LOD (Existing Logic) ---
        let logicInterval = 1;
        if (distSq > 22500) logicInterval = 10;
        else if (distSq > 2500) logicInterval = 3;

        if (distSq > 22500) {
            this.outline.visible = false;
            this.healthBarGroup.visible = false;
            this.eyeL.visible = false;
            this.eyeR.visible = false;
        } else {
            this.outline.visible = true;
            this.eyeL.visible = true;
            this.eyeR.visible = true;
            if (this.hasAggroed && !this.isDeadCorpse) this.healthBarGroup.visible = true;
        }

        // --- LOGIC LOD ---
        const shouldRunLogic = (frameCounter + Math.floor(this.id * 100)) % logicInterval === 0;
        if (shouldRunLogic) {
            this.updateLogic(dt * logicInterval, playerPos, logicInterval);
        }

        // --- PHYSICS LOD (New Hybrid Logic) ---
        // Pass the distSq to updatePhysics so we know which precision mode to use
        this.updatePhysics(dt, distSq);
    }

    // --- 5. LOGIC BRAIN ---
    updateLogic(dt, playerPos, intervalMultiplier) {
        if (this.isDeadCorpse) return;

        // Ground Check
        const distMoved = Math.hypot(this.mesh.position.x - this.lastPos.x, this.mesh.position.z - this.lastPos.y);
        const isInAir = Math.abs(this.mesh.position.y - this.lastGroundHeight) > 2.0;

        if (distMoved > 1.0 || isInAir || this.groundCheckTimer <= 0) {
            this.lastGroundHeight = getGroundHeight(this.mesh.position.x, this.mesh.position.z);
            this.groundCheckTimer = 0.5; 
        } else {
            this.groundCheckTimer -= dt;
        }

        // Timers
        this.visionTimer -= dt;
        if (this.visionTimer <= 0) {
            this.canSeePlayerCached = this.checkVision(playerPos);
            this.visionTimer = 0.3 + Math.random() * 0.2;
        }

        if (this.reactionTimer > 0) {
            this.reactionTimer -= dt * 1000;
            this.currentMoveSpeed = 0;
            return;
        }
        
        // Regen
        const now = performance.now();
        if (now - this.lastDamageTime > CONFIG.regenDelay && this.health < this.maxHealth) {
            this.health += CONFIG.regenRate * dt;
            if (this.health >= this.maxHealth) {
                this.health = this.maxHealth;
                this.isRetreating = false; 
            }
        }
        
        if (this.stamina < this.maxStamina) {
            this.stamina = Math.min(this.maxStamina, this.stamina + this.staminaRegen * dt);
        }

        if (this.teleportTimer > 0) this.teleportTimer -= dt * 1000;
        if (this.teleportDelay > 0) this.teleportDelay -= dt;
        if (this.portalCooldown > 0) this.portalCooldown -= dt;
        if (this.strafeTimer > 0) this.strafeTimer -= dt;
        if (this.dodgeTimer > 0) this.dodgeTimer -= dt;
        if (this.dodgeReactionTimer > 0) this.dodgeReactionTimer -= dt;
        if (this.ledgeTimer > 0) this.ledgeTimer -= dt;

        // Portals
        if(this.portalCooldown <= 0) {
             for(let p of portals) {
                 if(this.mesh.position.distanceTo(p.mesh.position) < 3.0) {
                     p.teleportEntity(this.mesh.position, this.velocity);
                     this.portalCooldown = 0.5;
                 }
             }
        }

        let dest = this.targetPos;
        let speed = (this.isSprinting ? CONFIG.botSprintSpeed : CONFIG.botSpeed) * this.type.speedMod * this.personalSpeedMod;
        const hpPct = this.health / this.maxHealth;
        const groundY = this.lastGroundHeight;

        // --- State Machine ---
        if (this.state === 'ROAM') {
            speed = CONFIG.botRoamSpeed * this.type.speedMod * this.personalSpeedMod;
            if (this.onGroundSafe(groundY)) {
                const forward = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), this.mesh.rotation.y);
                const lookAheadPos = this.mesh.position.clone().addScaledVector(forward, 2.0); 
                const aheadHeight = getGroundHeight(lookAheadPos.x, lookAheadPos.z);
                if (groundY - aheadHeight > 3.0) {
                    if (Math.random() < 0.1 * intervalMultiplier) this.pickRoamTarget();
                }
            }
            if (new THREE.Vector2(this.mesh.position.x - dest.x, this.mesh.position.z - dest.z).length() < 3) {
                this.pickRoamTarget();
            }
            if (this.onGroundSafe(groundY) && Math.random() < 0.005 * intervalMultiplier) {
                this.velocity.y = 16; 
                this.jumps = 1;
                this.mesh.position.y += 0.2; 
            }
        } 
        else if (this.state === 'AGGRO') {
            if (this.canSeePlayer(playerPos)) {
                this.lastKnownPos.copy(playerPos);
                dest = playerPos;
                const dist = this.mesh.position.distanceTo(playerPos);

                // Retreat Logic
                if (hpPct < 0.5 && !this.isRetreating && !this.pendingRetreat) {
                    this.pendingRetreat = true;
                    if (this.teleportDelay <= 0) {
                        this.teleportDelay = getBotReactionTime(this) / 1000;
                    }
                }
                if (this.pendingRetreat && this.teleportDelay <= 0) {
                    this.isRetreating = true;
                    this.pendingRetreat = false;
                }
                if (this.isRetreating) {
                    speed = CONFIG.botSprintSpeed * this.type.speedMod * this.personalSpeedMod * 1.3;
                    this.isSprinting = true;
                    
                    const slideBase = (hpPct < 0.25) ? 0.4 : 0.05;
                    if(!this.isSliding && Math.random() < slideBase * intervalMultiplier) this.isSliding = true;

                    const retreatDir = this.mesh.position.clone().sub(playerPos).normalize();
                    globalRaycaster.set(this.mesh.position, retreatDir);
                    globalRaycaster.far = 5;
                    const wallsAhead = globalRaycaster.intersectObjects(walls);
                    if (wallsAhead.length > 0) {
                        let escapeFound = false;
                        const leftDir = new THREE.Vector3(-retreatDir.z, 0, retreatDir.x);
                        const rightDir = new THREE.Vector3(retreatDir.z, 0, -retreatDir.x);
                        globalRaycaster.set(this.mesh.position, leftDir);
                        if (globalRaycaster.intersectObjects(walls).length === 0) {
                             retreatDir.copy(leftDir);
                             escapeFound = true;
                        } else {
                             globalRaycaster.set(this.mesh.position, rightDir);
                             if (globalRaycaster.intersectObjects(walls).length === 0) {
                                 retreatDir.copy(rightDir);
                                 escapeFound = true;
                             }
                        }
                        if (!escapeFound && dist < 10) {
                            if(this.onGroundSafe(groundY)) {
                                this.velocity.y = 25; 
                                this.jumps = 1;
                                retreatDir.subVectors(playerPos, this.mesh.position).normalize();
                            }
                        } else if (!escapeFound) {
                             retreatDir.set((Math.random()-0.5), 0, (Math.random()-0.5)).normalize();
                        }
                    }
                    dest = this.mesh.position.clone().addScaledVector(retreatDir, 40);
                    this.targetPos.copy(dest); 
                }

                // Teleport Logic
                if (this.teleportTimer <= 0 && this.stamina >= 10 && this.teleportDelay <= 0) {
                    let wantsToTp = false;
                    if (dist < 15 && this.isRetreating) wantsToTp = true;
                    if (dist > 25 && !this.isRetreating) wantsToTp = true; 
                    if (dist < 15 && !this.isRetreating) wantsToTp = true; 
                    if (wantsToTp && !this.teleportReactionPending) {
                        this.teleportDelay = getBotReactionTime(this) / 1000;
                        this.teleportReactionPending = true;
                    }
                    if (this.teleportDelay <= 0 && this.teleportReactionPending) {
                        this.teleportReactionPending = false; 
                        let tpChance = 0.005;
                        if (this.isRetreating) tpChance = 0.05; 
                        if (dist > 25) tpChance = 0.02; 
                        
                        if (Math.random() < tpChance * intervalMultiplier) {
                            let newPos;
                            const minRange = 5;
                            const maxRange = 20;
                            const tpRange = minRange + (1.0 - hpPct) * (maxRange - minRange);
                            if (this.isRetreating) {
                                const escapeDir = this.mesh.position.clone().sub(playerPos).normalize();
                                escapeDir.x += (Math.random()-0.5)*0.5;
                                escapeDir.z += (Math.random()-0.5)*0.5;
                                escapeDir.normalize();
                                newPos = this.mesh.position.clone().addScaledVector(escapeDir, tpRange);
                            } 
                            else if (dist > 25) { 
                                const approachDir = playerPos.clone().sub(this.mesh.position).normalize();
                                const travelDist = dist - 5; 
                                if(travelDist > 5) {
                                    newPos = this.mesh.position.clone().addScaledVector(approachDir, Math.min(travelDist, maxRange));
                                }
                            }
                            else if (dist < 15 && !this.isRetreating) {
                                const offset = new THREE.Vector3((Math.random()-0.5)*10, 0, (Math.random()-0.5)*10);
                                newPos = this.mesh.position.clone().add(offset);
                            }
                            if (newPos) {
                                const tpRayDir = newPos.clone().sub(this.mesh.position).normalize();
                                const tpDist = newPos.distanceTo(this.mesh.position);
                                globalRaycaster.set(this.mesh.position, tpRayDir);
                                globalRaycaster.far = tpDist;
                                const tpHits = globalRaycaster.intersectObjects(walls);
                                if (tpHits.length > 0) {
                                    newPos.copy(tpHits[0].point).addScaledVector(tpRayDir, -1.0);
                                }
                                if(getGroundHeight(newPos.x, newPos.z) > -10) {
                                    spawnParticles(this.mesh.position, 0xff00ff, 15);
                                    this.mesh.position.copy(newPos);
                                    spawnParticles(this.mesh.position, 0xff00ff, 15);
                                    AudioSys.playTeleport();
                                    this.stamina -= 10;
                                    this.teleportTimer = 500; 
                                }
                            }
                        }
                    }
                }
                
                // Attack Logic
                if (dist < 5 * this.type.scale) {
                    const now = performance.now();
                    if (now - this.lastAttack > CONFIG.botAttackCooldown) {
                        this.lastAttack = now;
                        spawnSlash(this.mesh); 
                        AudioSys.playSlash();
                        const lungeDir = playerPos.clone().sub(this.mesh.position).normalize();
                        lungeDir.y = 0; lungeDir.normalize();
                        const lungeForce = 25 + (this.type.scale * 5); 
                        this.velocity.addScaledVector(lungeDir, lungeForce);
                        const hitChance = 1.05 - (this.type.scale * 0.1); 
                        if (Math.random() < hitChance) {
                            if (now - this.lastHitTime > 2000) {
                                this.streak = 0;
                            }
                            let dmg = CONFIG.botDamage * this.type.scale; 
                            dmg += this.streak * 2; 
                            dmg = Math.min(dmg, 40); 
                            this.streak++;
                            this.lastHitTime = now;
                            damagePlayer(dmg); 
                        }
                        else {
                            AudioSys.playMiss();
                            this.streak = 0; 
                        }
                    }
                }
            } else {
                dest = this.lastKnownPos;
                if (this.mesh.position.distanceTo(dest) < 3) {
                    this.state = 'SEARCH';
                    this.searchTimer = 3000; 
                    this.body.material.color.setHex(0xffaa00); 
                }
            }
        } 
        else if (this.state === 'SEARCH') {
            speed = 0; 
            this.searchTimer -= dt * 1000;
            if (this.canSeePlayer(playerPos)) {
                this.state = 'AGGRO';
                this.body.material.color.setHex(0x8b0000);
                this.reactionTimer = CONFIG.botAggroDelay; 
            } else if (this.searchTimer <= 0) {
                this.state = 'ROAM';
                this.body.material.color.setHex(this.type.color);
                this.pickRoamTarget();
            }
        }

        this.actionTimer -= dt;
        if (this.actionTimer <= 0) {
            this.actionTimer = 0.5 + Math.random() * 1.5; 
            let sprintChance = (this.type.skill >= 2 ? 0.7 : 0.3);
            let slideChance = (this.type.skill >= 2 ? 0.4 : 0.1);
            if (Math.random() < sprintChance) this.isSprinting = true;
            else this.isSprinting = false; 
            
            if (this.isSprinting && Math.random() < slideChance) this.isSliding = true;
            else this.isSliding = false;
        }

        // --- Calculate Movement Vector (Intent) ---
        this.currentMoveSpeed = 0;
        
        if (this.type.speedMod !== 0 && this.state !== 'SEARCH' && this.state !== 'CONFUSED') {
            _vec3_1.subVectors(dest, this.mesh.position);
            _vec3_1.y = 0; 
            _vec3_1.normalize();
            _vec3_2.copy(_vec3_1);

            if (this.state === 'AGGRO' && !this.isRetreating) {
                _vec3_2.subVectors(playerPos, this.mesh.position);
                _vec3_2.y = 0; 
                _vec3_2.normalize();
            }

            if (this.state === 'AGGRO' && !this.isRetreating && this.canSeePlayer(playerPos)) {
                const dist = this.mesh.position.distanceTo(playerPos);
                if (this.dodgeTimer <= 0) {
                    const playerAim = new THREE.Vector3();
                    camera.getWorldDirection(playerAim);
                    playerAim.y = 0; playerAim.normalize();
                    const toBot = this.mesh.position.clone().sub(playerPos).normalize();
                    if (playerAim.dot(toBot) > 0.9 && player.velocity.length() > 10) {
                        if (this.dodgeReactionTimer <= 0) {
                             this.dodgeReactionTimer = getBotReactionTime(this) / 1000;
                        }
                    }
                }
                if (this.dodgeReactionTimer > 0 && this.dodgeReactionTimer <= dt && this.dodgeTimer <= 0) {
                    this.strafeDir *= -1; 
                    this.dodgeTimer = 1.0; 
                    this.dodgeReactionTimer = 0;
                }
                if (this.strafeTimer <= 0) {
                    this.strafeDir *= -1;
                    this.strafeTimer = 1.5 + Math.random() * 2.0;
                }
                const idealRange = 1.5 + (3.0 * this.type.scale);
                if (dist < 15 + (10 * this.type.scale)) {
                    const orbitVec = new THREE.Vector3(-_vec3_1.z, 0, _vec3_1.x).multiplyScalar(this.strafeDir);
                    if (dist > idealRange) {
                        _vec3_1.addScaledVector(orbitVec, 0.8).normalize();
                    } else if (dist < idealRange - 2) {
                        _vec3_1.multiplyScalar(-0.5).addScaledVector(orbitVec, 1.0).normalize();
                    } else {
                        const attackReady = (performance.now() - this.lastAttack > CONFIG.botAttackCooldown);
                        if (attackReady) {
                            _vec3_1.addScaledVector(orbitVec, 0.2).normalize(); 
                        } else {
                            _vec3_1.multiplyScalar(0.4).addScaledVector(orbitVec, 0.8).normalize(); 
                        }
                    }
                    const predictPos = this.mesh.position.clone().addScaledVector(_vec3_1, 2.0);
                    if (!this.onGroundSafe(getGroundHeight(predictPos.x, predictPos.z))) {
                        if (this.ledgeTimer <= 0) {
                            this.strafeDir *= -1;
                            this.ledgeTimer = 0.5; 
                        }
                    }
                }
            }
            
            _vec3_1.normalize();
            if (this.isSliding) speed *= 1.5;
            
            // Ledge Stop
            if (this.onGroundSafe(groundY)) {
                 const lookAhead = this.mesh.position.clone().addScaledVector(_vec3_1, 2.0);
                 const nextGround = getGroundHeight(lookAhead.x, lookAhead.z);
                 if (nextGround < groundY - 3) {
                     speed = 0;
                     if (this.state === 'ROAM') this.pickRoamTarget();
                     else this.velocity.set(0,0,0);
                 }
            }

            this.currentMoveDir.copy(_vec3_1);
            this.currentMoveSpeed = speed;

            let lookDir = _vec3_1;
            if (this.state === 'AGGRO' && !this.isRetreating) {
                lookDir = _vec3_2;
            }
            if (lookDir.lengthSq() > 0.1) {
                this.targetRotation = Math.atan2(lookDir.x, lookDir.z);
            }
        }
        
        if (this.isSliding) {
            if (currentTheme === 0 && Math.random() < 0.3 * intervalMultiplier) spawnSnowTrail(this.mesh.position);
        }
    }

    // --- 6. PHYSICS & ANIMATION ---
    updatePhysics(dt, distSq) {
        // Eye Color
        if (this.state === 'AGGRO') this.eyeMat.color.setHex(0xff0000);
        else if (this.state === 'SEARCH') this.eyeMat.color.setHex(0xffaa00);
        else this.eyeMat.color.setHex(this.type.eye);

        // Dead State
        if (this.isDeadCorpse) {
            this.corpseTimer -= dt;
            this.mesh.rotation.x = Math.PI / 2;
            this.mesh.position.y = this.lastGroundHeight + 0.5; 
            this.body.material.opacity = this.corpseTimer / 3.0;
            this.body.material.transparent = true;
            this.eyeMat.opacity = this.corpseTimer / 3.0;
            this.eyeMat.transparent = true;
            if (this.corpseTimer <= 0) {
                this.remove();
            }
            return;
        }

        // Confused State
        if (this.state === 'CONFUSED') {
            this.confusedTimer -= dt;
            this.mesh.rotation.x = -Math.PI / 2; 
            this.mesh.position.y = this.lastGroundHeight + 0.5;
            if (this.confusedTimer <= 0) {
                this.state = this.hasAggroed ? 'AGGRO' : 'ROAM';
                this.mesh.rotation.x = 0;
            }
            this.healthBarGroup.position.copy(this.mesh.position).add(new THREE.Vector3(0, 1.0 * this.type.scale, 0));
            return;
        }

        // Gravity & Ground Physics
        const groundY = this.lastGroundHeight;
        const floorThreshold = groundY + (1 * this.type.scale);
        
        if (this.mesh.position.y > floorThreshold + 0.1) {
            this.velocity.y -= CONFIG.gravity * dt;
            
            // Fall Recovery Jump (Double Jump logic)
            let jumpChance = 0.05; 
            if (this.isRetreating && (this.health/this.maxHealth) < 0.3) jumpChance = 0.3; 
            if (this.velocity.y < -8 && this.jumps < 2 && Math.random() < jumpChance * dt * 60) {
                 this.velocity.y = 18; 
                 this.jumps++;
            }
        } else {
            // Fall Damage / Confused Check
            if (this.velocity.y < -22) { 
                let shouldFall = true;
                if (this.state === 'AGGRO') {
                    if (Math.random() < 0.9) shouldFall = false; 
                }
                if (shouldFall) {
                    this.state = 'CONFUSED';
                    const impactSpeed = Math.abs(this.velocity.y);
                    this.confusedTimer = 3.0 + Math.min(2.0, (impactSpeed - 22) / 5.0);
                    this.velocity.y = 0;
                    return;
                }
            }
            this.velocity.y = 0;
            this.mesh.position.y = floorThreshold;
            this.jumps = 0;
        }

        // Horizontal Movement
        if (this.currentMoveSpeed > 0) {
            this.mesh.position.addScaledVector(this.currentMoveDir, this.currentMoveSpeed * dt);
        }

        // Velocity Application
        this.mesh.position.addScaledVector(this.velocity, dt);
        const drag = Math.exp(-2.0 * dt);
        this.velocity.x *= drag;
        this.velocity.z *= drag;

        // --- OPTIMIZED STUCK LOGIC ---
        // Check "Movement Efficiency" using squared distance (Avoids expensive Sqrt)
        if (this.currentMoveSpeed > 0.5 && this.state !== 'SEARCH') {
             // 1. Calculate actual distance squared
             const dx = this.mesh.position.x - this.lastPos.x;
             const dz = this.mesh.position.z - this.lastPos.y; // Vector2.y holds the Z coord
             const distMovedSq = dx*dx + dz*dz;
             
             // 2. Calculate minimum expected distance squared
             // (We expect to move at least 30% of intended speed)
             const minDist = this.currentMoveSpeed * dt * 0.3;
             const minExpectedSq = minDist * minDist;

             // 3. Compare Squares (Much faster)
             if (distMovedSq < minExpectedSq) {
                 
                 if (this.state === 'ROAM') {
                     // Get current heading
                     const fwdX = this.currentMoveDir.x;
                     const fwdZ = this.currentMoveDir.z;
                     
                     const roll = Math.random();
                     let newDirX, newDirZ;

                     if (roll < 0.4) { 
                         // Turn Right (Swap and invert X)
                         newDirX = -fwdZ; newDirZ = fwdX; 
                     } else if (roll < 0.8) { 
                         // Turn Left (Swap and invert Z)
                         newDirX = fwdZ; newDirZ = -fwdX; 
                     } else { 
                         // Turn Around (Invert both)
                         newDirX = -fwdX; newDirZ = -fwdZ; 
                     }
                     
                     // Project new target 15m away
                     this.targetPos.x = this.mesh.position.x + (newDirX * 15);
                     this.targetPos.z = this.mesh.position.z + (newDirZ * 15);
                     
                 } else if (this.state === 'AGGRO') {
                     // Flip strafe direction
                     this.strafeDir *= -1;
                     this.strafeTimer = 0.5;
                 }
             }
        }
        
        // Update Last Pos
        this.lastPos.set(this.mesh.position.x, this.mesh.position.z);

        // Rotation Smoothing
        if (this.state === 'SEARCH') {
            const lookTime = performance.now() * 0.002;
            this.mesh.rotation.y = Math.sin(lookTime) * Math.PI;
        } else {
            let rotDiff = this.targetRotation - this.mesh.rotation.y;
            while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
            while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
            this.mesh.rotation.y += rotDiff * dt * 8;
        }

        if (this.isSliding) this.mesh.rotation.x = 0.5;
        else if (this.state !== 'CONFUSED') this.mesh.rotation.x = 0;

        // UI Updates
        this.healthBarGroup.position.copy(this.mesh.position).add(new THREE.Vector3(0, 1.3 * this.type.scale, 0));
        this.healthBarGroup.lookAt(camera.position);
        if (this.hasAggroed) {
            this.healthBarGroup.visible = true;
            this.healthBar.scale.x = Math.max(0, this.health / this.maxHealth);
        }

        // --- OPTIMIZED COLLISION BOUNDS ---
        // Use the passed distSq to determine precision
        const isNear = distSq < 2500; // 50 meters (Same as Visual LOD threshold)

        if (isNear) {
            // ACCURATE MODE: Full matrix calculation (Preserves Game Feel for combat)
            _box3_1.setFromObject(this.body);
        } else {
            // FAST MODE: Simple math approximation (Saves CPU for the swarm)
            // We assume the bot is standing upright (which they mostly are)
            const p = this.mesh.position;
            const s = this.type.scale; // Respect the bot type scale (Titan/Brute/etc)
            
            // Hardcoded offset based on bot geometry (1x2x1 box roughly)
            _box3_1.min.set(p.x - 0.5 * s, p.y, p.z - 0.5 * s);
            _box3_1.max.set(p.x + 0.5 * s, p.y + 2 * s, p.z + 0.5 * s);
        }
        
        const botBox = _box3_1;
        
        if(spatialGrid) {
            const nearbyWalls = spatialGrid.query(botBox);
            
            for(const wb of nearbyWalls) {
                if (wb.mesh.userData.isFloor) continue;
                
                // --- FIX: Vertical Clearance Check ---
                // If the bot's center is higher than the box's top (minus a small step margin),
                // we are standing ON it, not walking INTO it. Ignore collision.
                // 0.5 is a safe margin for "step height".
                if (this.mesh.position.y >= wb.box.max.y - 0.5) continue;

                if(botBox.intersectsBox(wb.box)) {
                     const xOverlap = Math.min(botBox.max.x - wb.box.min.x, wb.box.max.x - botBox.min.x);
                     const zOverlap = Math.min(botBox.max.z - wb.box.min.z, wb.box.max.z - botBox.min.z);
                     
                     const wallX = wb.mesh.matrixWorld.elements[12];
                     const wallZ = wb.mesh.matrixWorld.elements[14];
                     
                     if(xOverlap < zOverlap) {
                         const sign = (this.mesh.position.x < wallX) ? -1 : 1;
                         this.mesh.position.x += xOverlap * sign;
                     } else {
                         const sign = (this.mesh.position.z < wallZ) ? -1 : 1;
                         this.mesh.position.z += zOverlap * sign;
                     }
                     
                     // If we hit a wall while roaming, pick a new target immediately
                     if (this.state === 'ROAM' && Math.random() > 0.1) {
                         this.pickRoamTarget();
                     }
                }
            }
        }
    }

    onGroundSafe(groundY) {
         return Math.abs(this.mesh.position.y - (groundY + this.type.scale)) < 0.5;
    }

    takeHit(amt) {
        if(this.isDeadCorpse || this.state === 'CONFUSED') {
            if(this.state === 'CONFUSED') {
                amt *= 2;
                if (this.health < this.maxHealth * 0.3) {
                    this.state = 'AGGRO';
                    this.confusedTimer = 0;
                    this.mesh.rotation.x = 0;
                    this.isRetreating = true;
                    this.velocity.y = 15;
                    this.jumps = 1;
                }
            }
        }
        amt *= this.type.dmgRed;
        this.health -= amt;
        this.lastDamageTime = performance.now(); 
        this.body.material.color.setHex(0xffffff); 
        setTimeout(() => { 
            if(!this.isDeadCorpse && this.state !== 'CONFUSED') {
                if (currentTheme === 2) { 
                    this.body.material.color.setHex(0x000000);
                } else {
                    if(this.state === 'SEARCH') this.body.material.color.setHex(0xffaa00);
                    else if(this.state === 'AGGRO') this.body.material.color.setHex(0x8b0000);
                    else this.body.material.color.setHex(this.type.color);
                }
            }
        }, 100);
        if (this.state !== 'AGGRO' && this.state !== 'CONFUSED') {
            this.state = 'AGGRO'; 
            this.reactionTimer = CONFIG.botAggroDelay; 
            this.hasAggroed = true;
        }
        if (this.health <= 0) {
            addScore(1000 * this.type.scale);
            GameStats.botKills++;
            GameStats.checkKillMilestone();
            spawnParticles(this.mesh.position, 0x8b0000, 20 * this.type.scale);
            AudioSys.playHit();
            let shouldSplit = false;
            let nextType = BOT_TYPES.NORMAL;
            let roll = Math.random();
            if (this.type.name === "COLOSSUS") {
                if (roll < 0.90) { shouldSplit = true; nextType = BOT_TYPES.TITAN; }
            } else if (this.type.name === "TITAN") {
                if (roll < 0.70) { shouldSplit = true; nextType = BOT_TYPES.BRUTE; }
            } else if (this.type.name === "BRUTE") {
                if (roll < 0.40) { shouldSplit = true; nextType = BOT_TYPES.NORMAL; }
            }
            if (!shouldSplit) {
                this.isDeadCorpse = true;
                this.corpseTimer = 3.0;
                this.healthBarGroup.visible = false;
                this.outline.visible = false;
                showKillMessage("THREAT NEUTRALIZED");
            } else {
                const count = Math.random() > 0.5 ? 2 : 1;
                const delays = [0.2, 0.5];
                for(let i=0; i<count; i++) {
                    new Enemy(this.mesh.position, nextType, 'AGGRO', delays[i], WorldManager.current);
                }
                showKillMessage(this.type.name + " SPLIT!");
                this.remove();
            }
        }
    }

    remove() {
        if (this.mesh.parent) {
            this.mesh.parent.remove(this.mesh);
        }
        if (this.healthBarGroup.parent) {
            this.healthBarGroup.parent.remove(this.healthBarGroup);
        }
        const idx = enemies.indexOf(this);
        if(idx > -1) enemies.splice(idx, 1);
    }
}
        
        function damagePlayer(amt) {
            player.health -= amt;
            player.lastDamageTime = performance.now();
            const overlay = document.getElementById('damage-overlay');
            overlay.style.background = "radial-gradient(circle, transparent 20%, rgba(255,0,0,0.6) 100%)";
            setTimeout(() => {
                overlay.style.background = "radial-gradient(circle, transparent 50%, rgba(255,0,0,0.0) 100%)";
            }, 200);
            if(player.health <= 0) {
                if (player.extraLives > 0) {
                    player.extraLives--;
                    player.health = CONFIG.playerMaxHP; 
                    showKillMessage("EXTRA LIFE USED!", "achievement", "#00ff00");
                    AudioSys.playTeleport(); 
                    updateLivesDisplay();
                } else {
                    player.health = 0;
                    player.isDead = true;
                    document.exitPointerLock();
                    showKillMessage("TERMINATED", "achievement");
                    const diff = Date.now() - sessionStartTime;
                    const mins = Math.floor(diff / 60000);
                    const secs = Math.floor((diff % 60000) / 1000);
                    document.getElementById('session-timer').innerText = `Session Time: ${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;
                }
            }
        }
        
        function updateLivesDisplay() {
            const el = document.getElementById('lives-display');
            if (player.extraLives > 0) {
                let hearts = "";
                for(let i=0; i<player.extraLives; i++) hearts += " ";
                el.innerText = hearts;
            } else {
                el.innerText = "";
            }
        }
        
        function addScore(amt) {
            const oldScore = player.score;
            player.score += amt;
            document.getElementById('score-display').innerText = "SCORE: " + player.score;
            if (Math.floor(player.score / 10000) > Math.floor(oldScore / 10000)) {
                if (player.extraLives < 3) {
                    player.extraLives++;
                    showKillMessage("EXTRA LIFE EARNED!", "achievement", "#00ff00");
                    updateLivesDisplay();
                }
            }
        }

        function resetGame() {
            player.health = CONFIG.playerMaxHP;
            player.energy = CONFIG.energyMax; 
            player.score = 0;
            player.extraLives = 0;
            player.isDead = false;
            player.isSliding = false;
            player.isCrouching = false;
            player.velocity.set(0,0,0);
            player.totalHits = 0; 
            camera.position.set(0, 2, 0);
            
            bankedActiveTime = 0;
            totalBreakTime = 0;
            breakCount = 0;
            lastSegmentDuration = 0;
            segmentStartTime = performance.now();
            
            updateLivesDisplay();
            
            // Wipe Active World Enemies
            for(let i=enemies.length-1; i>=0; i--) enemies[i].remove();
            enemies.length = 0;
            
            particles.forEach(p => {
                scene.remove(p.mesh);
                p.mesh.geometry.dispose();
                p.mesh.material.dispose();
            });
            particles.length = 0;
            
            projectiles.forEach(p => {
                scene.remove(p.mesh);
                p.mesh.geometry.dispose();
                p.mesh.material.dispose();
            });
            projectiles.length = 0;
            
            GameStats.reset();
            comboCount = 0;
            updateComboUI();
            document.getElementById('score-display').innerText = "SCORE: 0";
            document.getElementById('health-fill').classList.remove('health-critical');
            document.getElementById('low-health-vignette').style.boxShadow = "inset 0 0 100px rgba(255, 0, 0, 0)";
            
            // Ensure we are in ARENA on reset? 
            // The prompt says "Normal" is default, but maybe they want to restart on the current map.
            // Let's keep current map for now.
        }
        
        function showKillMessage(text, type="", color=null) {
            const feed = document.getElementById('kill-feed');
            const msg = document.createElement('div');
            msg.className = "kill-msg " + type;
            msg.innerHTML = text; 
            if(color) {
                msg.style.color = color;
                msg.style.borderLeftColor = color;
            }
            feed.prepend(msg);
            if(feed.children.length > 6) feed.removeChild(feed.lastChild);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const dt = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;
            frameCounter++;
            
            if(showFPS) {
                fpsFrames++;
                if(now > lastFpsTime + 1000) {
                    document.getElementById('fps-display').innerHTML = '<div class="fps-inner">FPS: ' + fpsFrames + '</div>';
                    fpsFrames = 0;
                    lastFpsTime = now;
                }
            }
            
            if (isLocked && !player.isDead) {
                // Determine spawn cap based on world
                const cap = WorldManager.current ? WorldManager.current.config.bots : 60;
                
                if (Math.random() < 0.05 && enemies.length < cap) {
                    new Enemy(null, null, 'ROAM', 0, WorldManager.current);
                }
                
                player.update(dt);
                updateWeather(dt);
                
                for(let p of portals) p.update(dt);
                
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    projectiles[i].update(dt);
                    if (!projectiles[i].active) {
                        projectiles.splice(i, 1);
                    }
                }
                
                // Optimized Enemy Updates with Logic LOD (Level of Detail)
                const playerPos = camera.position;
                for (let i = enemies.length - 1; i >= 0; i--) {
                    // Just call update. The class now handles skipping logic vs physics internally.
                    // We pass the raw dt, not the multiplied version.
                    enemies[i].update(dt, playerPos);
                }

                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.life -= dt;
                    if (p.type === 'flash') {
                        const progress = 1.0 - (p.life / p.maxLife); 
                        p.mesh.material.opacity = 1.0 - progress;
                        const s = THREE.MathUtils.lerp(p.scaleStart, p.scaleEnd, progress);
                        p.mesh.scale.setScalar(s);
                    } 
                    else if (p.type === 'spark') {
                        p.vel.y -= p.gravity * dt; 
                        p.mesh.position.addScaledVector(p.vel, dt);
                        p.mesh.scale.setScalar(p.life * 1.5); 
                    }
                    else if (p.isStatic) {
                         p.mesh.material.opacity = p.life * 0.4; 
                    } 
                    else if (p.type === 'ripple') {
                        const progress = 1.0 - (p.life / p.maxLife);
                        const ease = 1 - Math.pow(1 - progress, 3); 
                        const scale = 1 + (ease * 1);
                        p.mesh.scale.setScalar(scale);
                        p.mesh.material.opacity = (1.0 - ease) * 0.1;
                    } 
                    else {
                         p.mesh.position.addScaledVector(p.vel, dt);
                         p.mesh.scale.setScalar(p.life * 2); 
                    }
                    if (p.life <= 0) {
                        scene.remove(p.mesh);
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                        particles.splice(i, 1);
                    }
                }
                
                if (comboCount > 0) {
                    comboTimer -= dt;
                    if (comboTimer <= 0) {
                        comboCount = 0;
                        updateComboUI();
                    }
                }
                
                const hpPct = Math.max(0, player.health / (CONFIG.playerMaxHP/100)); 
                const enPct = Math.max(0, (player.energy / CONFIG.energyMax) * 100);
                document.getElementById('health-fill').style.width = hpPct + '%';
                document.getElementById('energy-fill').style.width = enPct + '%';
                
                const btn = document.getElementById('start-btn');
                if (btn.innerText === "b r e a t h e" && isLocked) {
                     btn.innerText = "ENTER ARENA";
                     btn.style.opacity = 1;
                     btn.style.letterSpacing = "2px";
                }
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
